---
title: "Post-run diagnostics and analyses"
date: "2023-03-20"
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{Post-run diagnostics and analyses}
output:
  rmarkdown::html_vignette
---



In this tutorial, we assume that you successfully ran an MCMC on a network
model, and that it is now time to have a critical look at the output of the
run.

This tutorial will present how to check that the MCMC run went fine, but it will explain only very briefly how to check that the model is compatible with the observed data. More details about this important step is presented in the next vignette about [posterior predictive checks](tutorial-100-posterior-predictive-checks.html).

This vignette is using the MCMC run from the [Quick start
tutorial](tutorial-010-quick-start.html). Please go back and run the code of
that vignette to generate the MCMC data if you haven't already!



### Reminder: what is the result format returned by `run_mcmc()`?

<div class="alert-primary" role="alert"> 

<b>Note:</b> This short section is a quick reminder of what you learnt in the previous tutorial [MCMC output format](tutorial-080-mcmc-output-format.html)).

</div>

In the **Quick Start** tutorial, we generated the `run` object by running `run <- run_mcmc(m, iter = 1000)`. The output from `run_mcmc()` is a well-behaved
`mcmc.list` object as implemented in the `coda` package:


```r
is(run, "mcmc.list")
```

```
## [1] TRUE
```

It makes it very easy to use the tools already available for this class of
objects, such as those implemented in the packages `coda`, `bayesplot`,
`ggmcmc` or `MCMCvis`.

In addition to all those existing tools, the `isotracer` package also adds some
extra methods to easily calculate derived parameters from an `mcmc.list`. You
will learn more about how to do this in the vignette [Derived
parameters](tutorial-110-derived-parameters.html).

<div class="alert-primary" role="alert"> 

<b>Tip:</b> `isotracer` uses Stan behind the scenes to run the MCMC. If you prefer to get the raw `stanfit` object instead of the processed `mcmc.list`, you can set `stanfit = TRUE` when you run the model:


```r
run <- run_mcmc(model = m, stanfit = TRUE)
```

This might be especially useful if the MCMC sampling is difficult for your
model and you need the `stanfit` object to perform some in-depth diagnostics.

</div>

## General diagnostics

### Trace plot

You should always run **several chains** when performing a Bayesian MCMC. Trace
plots allow to get a feeling for:

- Chain convergence: did all chains reach the same region of the parameter
  space?
- Mixing: is the mixing of good quality or should we modify the sampler
  settings?

If you are not satisfied with the traces, you need to run a longer run or maybe
to tweak the settings of the Stan run.

This is the trace plot we obtained from the previous vignette:


```r
plot(run)
# Note: the figure below only shows a few of the traceplots for vignette concision
```

<img src="figures/z-fig-090-unnamed-chunk-6-1.jpeg" alt="plot of chunk unnamed-chunk-6" style="display: block; margin: auto;" />

In this case, the chains have converged towards the same region, and the mixing
looks good for all of them. There is no obvious problem visible in those traces.

### Gelman and Rubin's convergence diagnostic

It can be useful to have a more formal test of the convergence of the
chains. The Gelman and Rubin's convergence diagnostic is implemented in the
`coda` package. We can run it with the `coda::gelman.diag()` function. See the
coda documentation `?gelman.diag` for more details about this diagnostic.

Let's have a look at the diagnostic for our chains:


```r
library(coda)
run %>% gelman.diag()
```

```
## Potential scale reduction factors:
## 
##                          Point est. Upper C.I.
## eta                            1.01       1.03
## lambda_algae                   1.02       1.04
## lambda_daphnia                 1.07       1.12
## lambda_NH4                     1.03       1.05
## upsilon_algae_to_daphnia       1.01       1.02
## upsilon_daphnia_to_NH4         1.00       1.01
## upsilon_NH4_to_algae           1.00       1.01
## zeta                           1.07       1.12
## 
## Multivariate psrf
## 
## 1.02
```

The diagnostic values should be very, very close to 1: it looks good in this
case!

If some values were e.g. $>1.05$, this would already be enough to cause us to
wonder about the sampling quality.

### Predicted trajectories

In order to check the quality of the model fit, the consistency between the parameter posteriors and the observed data can be checked by plotting the credible envelopes for the estimated trajectories along with the observed data points. This is called a posterior predictive check and is very important to check that the model can actually predict the observed data reasonably well. If the observed data cannot be satisfactorily predicted from the fitted model, then our model is not a good model of the data!

To do a posterior predictive check, the first step is to generate predictions for the model based on the MCMC posteriors with `predict()`:


```r
# From the Quick Start tutorial:
# 'm' is the network model we used when calling 'run <- run_mcmc(m, iter = 1000)'
predictions <- predict(m, run, probs = 0.95)
```



We can then visualize the predictions along with the observations with the `plot()` method:


```r
plot(predictions)
```

<img src="figures/z-fig-090-unnamed-chunk-10-1.jpeg" alt="plot of chunk unnamed-chunk-10" style="display: block; margin: auto;" />

This plot enables to compare both the **size** and the **proportion** observations with the predictions.

## Post-run analyses

### Parameter estimates

The quickest way to get parameter estimates is to use the `summary()` function
on the posterior:


```r
run %>% summary()
```

```
## 
## Iterations = 501:1000
## Thinning interval = 1 
## Number of chains = 4 
## Sample size per chain = 500 
## 
## 1. Empirical mean and standard deviation for each variable,
##    plus standard error of the mean:
## 
##                             Mean       SD  Naive SE Time-series SE
## eta                      0.13077 0.049152 0.0010991      0.0020033
## lambda_algae             0.10286 0.069802 0.0015608      0.0027276
## lambda_daphnia           0.03406 0.044308 0.0009907      0.0021403
## lambda_NH4               0.08789 0.075928 0.0016978      0.0037739
## upsilon_algae_to_daphnia 0.08117 0.027279 0.0006100      0.0012027
## upsilon_daphnia_to_NH4   0.04883 0.007193 0.0001609      0.0002655
## upsilon_NH4_to_algae     0.33789 0.045259 0.0010120      0.0018630
## zeta                     0.43033 0.274114 0.0061294      0.0151120
## 
## 2. Quantiles for each variable:
## 
##                               2.5%      25%     50%     75%   97.5%
## eta                      0.0669153 0.097014 0.11911 0.15366 0.25784
## lambda_algae             0.0073685 0.051767 0.09321 0.13848 0.27177
## lambda_daphnia           0.0007514 0.008011 0.01924 0.04288 0.16813
## lambda_NH4               0.0028592 0.032424 0.06857 0.12075 0.29253
## upsilon_algae_to_daphnia 0.0455856 0.063812 0.07516 0.09189 0.15350
## upsilon_daphnia_to_NH4   0.0351229 0.044070 0.04860 0.05341 0.06439
## upsilon_NH4_to_algae     0.2544754 0.306396 0.33584 0.36630 0.43583
## zeta                     0.1758005 0.272402 0.34691 0.49108 1.29881
```

If you need to store those values, for example to plot them, you can assign the
output of `summary()` to an object:


```r
estimates <- run %>% summary()
names(estimates)
```

```
## [1] "statistics" "quantiles"  "start"      "end"        "thin"       "nchain"
```

The means and standard deviations are accessible in `$statistics`:


```r
estimates$statistics
```

```
##                                Mean         SD     Naive SE Time-series SE
## eta                      0.13076730 0.04915221 0.0010990768   0.0020033250
## lambda_algae             0.10285856 0.06980185 0.0015608169   0.0027275957
## lambda_daphnia           0.03405795 0.04430761 0.0009907483   0.0021403053
## lambda_NH4               0.08789154 0.07592796 0.0016978007   0.0037738956
## upsilon_algae_to_daphnia 0.08117372 0.02727880 0.0006099724   0.0012027451
## upsilon_daphnia_to_NH4   0.04882637 0.00719345 0.0001608504   0.0002655128
## upsilon_NH4_to_algae     0.33789436 0.04525925 0.0010120277   0.0018629760
## zeta                     0.43033052 0.27411355 0.0061293654   0.0151119895
```

and the quantiles are in `$quantiles`:


```r
estimates$quantiles
```

```
##                                  2.5%         25%        50%        75%      97.5%
## eta                      0.0669153483 0.097013751 0.11910898 0.15366350 0.25783681
## lambda_algae             0.0073685350 0.051766703 0.09320946 0.13848273 0.27177321
## lambda_daphnia           0.0007514397 0.008010983 0.01924270 0.04288098 0.16813339
## lambda_NH4               0.0028591606 0.032424471 0.06857086 0.12075160 0.29253240
## upsilon_algae_to_daphnia 0.0455856417 0.063811924 0.07516373 0.09188825 0.15350357
## upsilon_daphnia_to_NH4   0.0351229456 0.044070018 0.04859819 0.05340884 0.06439157
## upsilon_NH4_to_algae     0.2544754362 0.306395594 0.33583893 0.36630030 0.43583051
## zeta                     0.1758004997 0.272401669 0.34691419 0.49107997 1.29881092
```

### Parameter correlations

The dependencies between your model parameters might be of interest to you. If
you would like to analyse the correlations between parameters during the MCMC
run, you can use a few ready-made functions to get a quick overview of the
correlation structure.

The `isotracer` package comes with the minimalist function `mcmc_heatmap()` to
draw the strength of parameter correlations:


```r
mcmc_heatmap(run)
```

<img src="figures/z-fig-090-unnamed-chunk-15-1.jpeg" alt="plot of chunk unnamed-chunk-15" style="display: block; margin: auto;" />

But of course you could use other functions provided by other packages, such as:

- `ggmcmc` package
    + `ggs_crosscorrelation()`
    + `ggs_pairs()`
- `bayesplot` package
    + `mcmc_pairs()`

### Extracting parameters, trajectories and flows

If you are interested in getting detailed tables containing all the samples of the parameter posteriors, you can use the `tidy_mcmc()` function:


```r
tidy_mcmc(run)
```

```
## # A tibble: 2,000 × 3
##    mcmc.chain mcmc.iteration mcmc.parameters
##         <int>          <int> <list>         
##  1          1              1 <dbl [8]>      
##  2          1              2 <dbl [8]>      
##  3          1              3 <dbl [8]>      
##  4          1              4 <dbl [8]>      
##  5          1              5 <dbl [8]>      
##  6          1              6 <dbl [8]>      
##  7          1              7 <dbl [8]>      
##  8          1              8 <dbl [8]>      
##  9          1              9 <dbl [8]>      
## 10          1             10 <dbl [8]>      
## # … with 1,990 more rows
```

By default the parameter values are nested into a list column, but you can also get a flat table with `spread = TRUE`:


```r
tidy_mcmc(run, spread = TRUE)
```

```
## # A tibble: 2,000 × 10
##    mcmc.chain mcmc.ite…¹    eta lambd…² lambd…³ lambd…⁴ upsil…⁵ upsil…⁶ upsil…⁷  zeta
##         <int>      <int>  <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl> <dbl>
##  1          1          1 0.144   0.0677 0.0108  6.52e-4  0.103   0.0508   0.282 0.192
##  2          1          2 0.122   0.0995 0.0455  5.27e-4  0.0809  0.0504   0.262 0.264
##  3          1          3 0.137   0.186  0.0408  2.01e-3  0.0708  0.0526   0.269 0.422
##  4          1          4 0.0974  0.0853 0.00865 6.47e-3  0.0442  0.0496   0.375 0.203
##  5          1          5 0.119   0.0343 0.0365  1.64e-2  0.0750  0.0597   0.381 0.307
##  6          1          6 0.169   0.0676 0.00201 5.91e-2  0.109   0.0382   0.248 0.314
##  7          1          7 0.106   0.120  0.111   5.93e-2  0.0330  0.0605   0.403 0.952
##  8          1          8 0.117   0.0979 0.128   4.15e-2  0.0433  0.0594   0.381 0.864
##  9          1          9 0.0683  0.117  0.265   1.16e-1  0.0513  0.0575   0.357 1.34 
## 10          1         10 0.0709  0.130  0.216   1.03e-1  0.0469  0.0577   0.352 1.35 
## # … with 1,990 more rows, and abbreviated variable names ¹​mcmc.iteration,
## #   ²​lambda_algae, ³​lambda_daphnia, ⁴​lambda_NH4, ⁵​upsilon_algae_to_daphnia,
## #   ⁶​upsilon_daphnia_to_NH4, ⁷​upsilon_NH4_to_algae
```

The above table only contains the primary parameters. If you are interested in getting the predicted trajectories for individual MCMC samples, you can use the `tidy_trajectories()` function:


```r
# We have to also provide the original network model `m`
tt <- tidy_trajectories(m, run, n = 200)
tt
```


```
## # A tibble: 200 × 4
##    mcmc.chain mcmc.iteration mcmc.parameters trajectories    
##         <int>          <int> <list>          <list>          
##  1          4             28 <dbl [8]>       <tibble [1 × 5]>
##  2          2             87 <dbl [8]>       <tibble [1 × 5]>
##  3          2            319 <dbl [8]>       <tibble [1 × 5]>
##  4          4            295 <dbl [8]>       <tibble [1 × 5]>
##  5          1             71 <dbl [8]>       <tibble [1 × 5]>
##  6          2            184 <dbl [8]>       <tibble [1 × 5]>
##  7          1            371 <dbl [8]>       <tibble [1 × 5]>
##  8          2            257 <dbl [8]>       <tibble [1 × 5]>
##  9          2            198 <dbl [8]>       <tibble [1 × 5]>
## 10          1            307 <dbl [8]>       <tibble [1 × 5]>
## # … with 190 more rows
```

As you can see, the `tt` object is a tidy table which contains the parameter values and the corresponding trajectories calculated for 200 randomly selected MCMC samples. The calculated trajectories are stored in the `trajectories` column and provide the quantities of unmarked and marked tracer (e.g. light and heavy isotope) for each compartment at each time step:


```r
tt$trajectories[[1]]
```

```
## # A tibble: 1 × 5
##   timepoints  unmarked        marked          sizes           proportions    
##   <list>      <list>          <list>          <list>          <list>         
## 1 <dbl [260]> <dbl [260 × 3]> <dbl [260 × 3]> <dbl [260 × 3]> <dbl [260 × 3]>
```

Because each trajectory is itself a table containing a time series for each compartment, the output of `tidy_trajectories()` has several levels of nesting. This makes it a bit cumbersome to manipulate. Note that the output format of this function might change in the future.

Here is an example of what can be done using the predicted trajectories:


```r
algae <- tt %>%
  mutate(prop_algae = map(trajectories, function(tr) {
    tr[["proportions"]][[1]][, "algae"]
  })) %>%
  pull(prop_algae) %>%
  do.call(rbind, .)
time <- tt$trajectories[[1]]$timepoints[[1]]
plot(0, type = "n", xlim = range(time), ylim = range(algae), las = 1,
     xlab = "Time", ylab = "Proportion of marked tracer (algae)",
     main = "Posterior sample of trajectories (for 15N prop. in algae)")
invisible(sapply(seq_len(nrow(algae)), function(i) {
  lines(time, algae[i,], col = adjustcolor("seagreen3", alpha.f = 0.2))
}))
```

<img src="figures/z-fig-090-unnamed-chunk-21-1.jpeg" alt="plot of chunk unnamed-chunk-21" style="display: block; margin: auto;" />

Finally, if what you are interested in are not the trajectories per se but the actual flows of nutrient during the experiment, you can use the `tidy_flows()` function to extract flows in a similar way:


```r
#' Again, note that we also provide the original network model `m`
tf <- tidy_flows(m, run, n = 200)
tf
```


```
## # A tibble: 200 × 4
##    mcmc.chain mcmc.iteration mcmc.parameters flows             
##  *      <int>          <int> <list>          <list>            
##  1          1            372 <dbl [8]>       <gropd_df [6 × 3]>
##  2          2            215 <dbl [8]>       <gropd_df [6 × 3]>
##  3          4            226 <dbl [8]>       <gropd_df [6 × 3]>
##  4          1            172 <dbl [8]>       <gropd_df [6 × 3]>
##  5          1            222 <dbl [8]>       <gropd_df [6 × 3]>
##  6          2            221 <dbl [8]>       <gropd_df [6 × 3]>
##  7          3            310 <dbl [8]>       <gropd_df [6 × 3]>
##  8          2            205 <dbl [8]>       <gropd_df [6 × 3]>
##  9          2             34 <dbl [8]>       <gropd_df [6 × 3]>
## 10          2            110 <dbl [8]>       <gropd_df [6 × 3]>
## # … with 190 more rows
```

The returned object is very similar to the output of `tidy_trajectories()`, except that the `trajectories` column is replaced by a `flows` column:


```r
tf$flows[[1]]
```

```
## # A tibble: 6 × 3
## # Groups:   from [3]
##   from    to      average_flow
##   <chr>   <chr>          <dbl>
## 1 NH4     algae         0.0730
## 2 NH4     <NA>          0.0233
## 3 algae   daphnia       0.0705
## 4 algae   <NA>          0.0568
## 5 daphnia NH4           0.101 
## 6 daphnia <NA>          0.0579
```

The average flow values are given in flow per unit of time. See `?tidy_flows()` for more details, including the possibility of calculating steady state flows for network systems that admits a steady state equilibrium.

The `tidy_trajectories()` and `tidy_flows()` functions are especially useful when you want to do some calculations related to some specific properties of the trajectories or of the nutrient flows over the whole MCMC posterior.

<nav aria-label="Page navigation">
 <ul class="pagination justify-content-end">
  <li class="page-item"><a class="page-link" href="tutorial-080-mcmc-output-format.html">Previous: MCMC output format</a></li>
  <li class="page-item"><a class="page-link" href="tutorial-100-posterior-predictive-checks.html">Next: Posterior predictive checks</a></li>
 </ul>
</nav>
