// Generated by rstantools.  Do not edit by hand.

/*
    myPkg is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    myPkg is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with myPkg.  If not, see <http://www.gnu.org/licenses/>.
*/
#ifndef MODELS_HPP
#define MODELS_HPP
#define STAN__SERVICES__COMMAND_HPP
#ifndef USE_STANC3
#define USE_STANC3
#endif
#include <rstan/rstaninc.hpp>
// Code generated by stanc v2.32.2
#include <stan/model/model_header.hpp>
namespace model_networkModel_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 555> locations_array__ =
  {" (found before start of program)",
  " (in 'networkModel', line 439, column 2 to column 64)",
  " (in 'networkModel', line 440, column 2 to column 56)",
  " (in 'networkModel', line 441, column 2 to column 58)",
  " (in 'networkModel', line 442, column 2 to column 56)",
  " (in 'networkModel', line 443, column 2 to column 64)",
  " (in 'networkModel', line 444, column 2 to column 52)",
  " (in 'networkModel', line 451, column 2 to column 38)",
  " (in 'networkModel', line 453, column 2 to column 88)",
  " (in 'networkModel', line 456, column 2 to column 61)",
  " (in 'networkModel', line 458, column 2 to column 59)",
  " (in 'networkModel', line 460, column 2 to column 55)",
  " (in 'networkModel', line 461, column 2 to column 55)",
  " (in 'networkModel', line 463, column 2 to column 100)",
  " (in 'networkModel', line 464, column 2 to column 101)",
  " (in 'networkModel', line 465, column 2 to column 100)",
  " (in 'networkModel', line 466, column 2 to column 99)",
  " (in 'networkModel', line 467, column 2 to column 101)",
  " (in 'networkModel', line 468, column 2 to column 100)",
  " (in 'networkModel', line 473, column 2 to column 57)",
  " (in 'networkModel', line 474, column 2 to column 62)",
  " (in 'networkModel', line 478, column 2 to column 33)",
  " (in 'networkModel', line 479, column 2 to column 38)",
  " (in 'networkModel', line 480, column 2 to column 39)",
  " (in 'networkModel', line 481, column 2 to column 44)",
  " (in 'networkModel', line 484, column 2 to column 71)",
  " (in 'networkModel', line 485, column 2 to column 73)",
  " (in 'networkModel', line 781, column 2 to column 47)",
  " (in 'networkModel', line 782, column 2 to column 17)",
  " (in 'networkModel', line 783, column 2 to column 25)",
  " (in 'networkModel', line 784, column 2 to column 19)",
  " (in 'networkModel', line 490, column 4 to column 19)",
  " (in 'networkModel', line 494, column 6 to column 36)",
  " (in 'networkModel', line 493, column 39 to line 495, column 5)",
  " (in 'networkModel', line 493, column 4 to line 495, column 5)",
  " (in 'networkModel', line 497, column 6 to column 112)",
  " (in 'networkModel', line 496, column 39 to line 498, column 5)",
  " (in 'networkModel', line 496, column 4 to line 498, column 5)",
  " (in 'networkModel', line 500, column 6 to column 83)",
  " (in 'networkModel', line 499, column 39 to line 501, column 5)",
  " (in 'networkModel', line 499, column 4 to line 501, column 5)",
  " (in 'networkModel', line 503, column 6 to column 77)",
  " (in 'networkModel', line 502, column 39 to line 504, column 5)",
  " (in 'networkModel', line 502, column 4 to line 504, column 5)",
  " (in 'networkModel', line 506, column 6 to column 58)",
  " (in 'networkModel', line 505, column 39 to line 507, column 5)",
  " (in 'networkModel', line 505, column 4 to line 507, column 5)",
  " (in 'networkModel', line 509, column 6 to column 63)",
  " (in 'networkModel', line 508, column 39 to line 510, column 5)",
  " (in 'networkModel', line 508, column 4 to line 510, column 5)",
  " (in 'networkModel', line 512, column 6 to column 57)",
  " (in 'networkModel', line 511, column 39 to line 513, column 5)",
  " (in 'networkModel', line 511, column 4 to line 513, column 5)",
  " (in 'networkModel', line 492, column 23 to line 514, column 3)",
  " (in 'networkModel', line 492, column 2 to line 514, column 3)",
  " (in 'networkModel', line 526, column 6 to line 528, column 78)",
  " (in 'networkModel', line 529, column 6 to column 79)",
  " (in 'networkModel', line 519, column 25 to line 530, column 5)",
  " (in 'networkModel', line 519, column 4 to line 530, column 5)",
  " (in 'networkModel', line 534, column 8 to line 537, column 72)",
  " (in 'networkModel', line 538, column 8 to line 541, column 74)",
  " (in 'networkModel', line 533, column 33 to line 542, column 7)",
  " (in 'networkModel', line 533, column 6 to line 542, column 7)",
  " (in 'networkModel', line 531, column 25 to line 543, column 5)",
  " (in 'networkModel', line 531, column 4 to line 543, column 5)",
  " (in 'networkModel', line 546, column 4 to column 19)",
  " (in 'networkModel', line 550, column 4 to column 56)",
  " (in 'networkModel', line 551, column 4 to column 54)",
  " (in 'networkModel', line 557, column 10 to column 77)",
  " (in 'networkModel', line 558, column 10 to column 75)",
  " (in 'networkModel', line 560, column 10 to column 73)",
  " (in 'networkModel', line 561, column 10 to column 69)",
  " (in 'networkModel', line 555, column 33 to line 562, column 9)",
  " (in 'networkModel', line 555, column 8 to line 562, column 9)",
  " (in 'networkModel', line 554, column 26 to line 563, column 7)",
  " (in 'networkModel', line 554, column 6 to line 563, column 7)",
  " (in 'networkModel', line 553, column 26 to line 564, column 5)",
  " (in 'networkModel', line 553, column 4 to line 564, column 5)",
  " (in 'networkModel', line 569, column 10 to column 102)",
  " (in 'networkModel', line 570, column 10 to column 100)",
  " (in 'networkModel', line 571, column 10 to column 26)",
  " (in 'networkModel', line 573, column 12 to column 18)",
  " (in 'networkModel', line 572, column 44 to line 574, column 11)",
  " (in 'networkModel', line 572, column 10 to line 574, column 11)",
  " (in 'networkModel', line 568, column 55 to line 575, column 9)",
  " (in 'networkModel', line 568, column 8 to line 575, column 9)",
  " (in 'networkModel', line 567, column 41 to line 576, column 7)",
  " (in 'networkModel', line 567, column 6 to line 576, column 7)",
  " (in 'networkModel', line 566, column 29 to line 577, column 5)",
  " (in 'networkModel', line 566, column 4 to line 577, column 5)",
  " (in 'networkModel', line 582, column 6 to column 57)",
  " (in 'networkModel', line 583, column 6 to column 53)",
  " (in 'networkModel', line 591, column 10 to column 74)",
  " (in 'networkModel', line 595, column 12 to column 86)",
  " (in 'networkModel', line 594, column 17 to line 596, column 11)",
  " (in 'networkModel', line 593, column 12 to column 49)",
  " (in 'networkModel', line 592, column 33 to line 594, column 11)",
  " (in 'networkModel', line 592, column 10 to line 596, column 11)",
  " (in 'networkModel', line 597, column 10 to column 99)",
  " (in 'networkModel', line 598, column 10 to column 100)",
  " (in 'networkModel', line 604, column 16 to column 127)",
  " (in 'networkModel', line 605, column 16 to column 125)",
  " (in 'networkModel', line 606, column 16 to column 32)",
  " (in 'networkModel', line 608, column 18 to column 24)",
  " (in 'networkModel', line 607, column 50 to line 609, column 17)",
  " (in 'networkModel', line 607, column 16 to line 609, column 17)",
  " (in 'networkModel', line 603, column 61 to line 610, column 15)",
  " (in 'networkModel', line 603, column 14 to line 610, column 15)",
  " (in 'networkModel', line 602, column 47 to line 611, column 13)",
  " (in 'networkModel', line 602, column 12 to line 611, column 13)",
  " (in 'networkModel', line 601, column 35 to line 612, column 11)",
  " (in 'networkModel', line 601, column 10 to line 612, column 11)",
  " (in 'networkModel', line 589, column 39 to line 613, column 9)",
  " (in 'networkModel', line 589, column 8 to line 613, column 9)",
  " (in 'networkModel', line 588, column 33 to line 614, column 7)",
  " (in 'networkModel', line 588, column 6 to line 614, column 7)",
  " (in 'networkModel', line 618, column 8 to column 73)",
  " (in 'networkModel', line 622, column 10 to column 85)",
  " (in 'networkModel', line 621, column 15 to line 623, column 9)",
  " (in 'networkModel', line 620, column 10 to column 47)",
  " (in 'networkModel', line 619, column 31 to line 621, column 9)",
  " (in 'networkModel', line 619, column 8 to line 623, column 9)",
  " (in 'networkModel', line 624, column 8 to column 96)",
  " (in 'networkModel', line 625, column 8 to column 97)",
  " (in 'networkModel', line 617, column 32 to line 626, column 7)",
  " (in 'networkModel', line 617, column 6 to line 626, column 7)",
  " (in 'networkModel', line 579, column 25 to line 627, column 5)",
  " (in 'networkModel', line 579, column 4 to line 627, column 5)",
  " (in 'networkModel', line 634, column 8 to column 71)",
  " (in 'networkModel', line 635, column 8 to column 72)",
  " (in 'networkModel', line 640, column 12 to column 84)",
  " (in 'networkModel', line 641, column 12 to column 80)",
  " (in 'networkModel', line 639, column 34 to line 642, column 11)",
  " (in 'networkModel', line 639, column 10 to line 642, column 11)",
  " (in 'networkModel', line 638, column 28 to line 643, column 9)",
  " (in 'networkModel', line 638, column 8 to line 643, column 9)",
  " (in 'networkModel', line 649, column 14 to column 108)",
  " (in 'networkModel', line 650, column 14 to column 106)",
  " (in 'networkModel', line 651, column 14 to column 30)",
  " (in 'networkModel', line 653, column 16 to column 22)",
  " (in 'networkModel', line 652, column 48 to line 654, column 15)",
  " (in 'networkModel', line 652, column 14 to line 654, column 15)",
  " (in 'networkModel', line 648, column 61 to line 655, column 13)",
  " (in 'networkModel', line 648, column 12 to line 655, column 13)",
  " (in 'networkModel', line 647, column 45 to line 656, column 11)",
  " (in 'networkModel', line 647, column 10 to line 656, column 11)",
  " (in 'networkModel', line 646, column 33 to line 657, column 9)",
  " (in 'networkModel', line 646, column 8 to line 657, column 9)",
  " (in 'networkModel', line 631, column 33 to line 659, column 7)",
  " (in 'networkModel', line 631, column 6 to line 659, column 7)",
  " (in 'networkModel', line 629, column 25 to line 660, column 5)",
  " (in 'networkModel', line 629, column 4 to line 660, column 5)",
  " (in 'networkModel', line 664, column 4 to line 668, column 56)",
  " (in 'networkModel', line 669, column 4 to line 673, column 56)",
  " (in 'networkModel', line 676, column 6 to column 59)",
  " (in 'networkModel', line 679, column 8 to column 46)",
  " (in 'networkModel', line 680, column 8 to column 67)",
  " (in 'networkModel', line 677, column 27 to line 681, column 7)",
  " (in 'networkModel', line 677, column 6 to line 681, column 7)",
  " (in 'networkModel', line 684, column 8 to column 46)",
  " (in 'networkModel', line 685, column 8 to column 50)",
  " (in 'networkModel', line 682, column 27 to line 686, column 7)",
  " (in 'networkModel', line 682, column 6 to line 686, column 7)",
  " (in 'networkModel', line 675, column 30 to line 687, column 5)",
  " (in 'networkModel', line 675, column 4 to line 687, column 5)",
  " (in 'networkModel', line 689, column 6 to column 58)",
  " (in 'networkModel', line 692, column 8 to column 59)",
  " (in 'networkModel', line 693, column 8 to column 68)",
  " (in 'networkModel', line 690, column 27 to line 694, column 7)",
  " (in 'networkModel', line 690, column 6 to line 694, column 7)",
  " (in 'networkModel', line 697, column 8 to column 46)",
  " (in 'networkModel', line 698, column 8 to column 72)",
  " (in 'networkModel', line 695, column 27 to line 699, column 7)",
  " (in 'networkModel', line 695, column 6 to line 699, column 7)",
  " (in 'networkModel', line 702, column 8 to column 46)",
  " (in 'networkModel', line 703, column 8 to column 49)",
  " (in 'networkModel', line 700, column 27 to line 704, column 7)",
  " (in 'networkModel', line 700, column 6 to line 704, column 7)",
  " (in 'networkModel', line 707, column 8 to column 67)",
  " (in 'networkModel', line 708, column 8 to column 72)",
  " (in 'networkModel', line 705, column 27 to line 709, column 7)",
  " (in 'networkModel', line 705, column 6 to line 709, column 7)",
  " (in 'networkModel', line 688, column 30 to line 710, column 5)",
  " (in 'networkModel', line 688, column 4 to line 710, column 5)",
  " (in 'networkModel', line 516, column 23 to line 712, column 3)",
  " (in 'networkModel', line 516, column 2 to line 712, column 3)",
  " (in 'networkModel', line 489, column 2 to line 713, column 3)",
  " (in 'networkModel', line 785, column 2 to column 19)",
  " (in 'networkModel', line 787, column 2 to column 17)",
  " (in 'networkModel', line 791, column 6 to column 48)",
  " (in 'networkModel', line 792, column 6 to column 22)",
  " (in 'networkModel', line 789, column 39 to line 793, column 5)",
  " (in 'networkModel', line 789, column 4 to line 793, column 5)",
  " (in 'networkModel', line 788, column 23 to line 794, column 3)",
  " (in 'networkModel', line 788, column 2 to line 794, column 3)",
  " (in 'networkModel', line 800, column 8 to column 105)",
  " (in 'networkModel', line 799, column 27 to line 801, column 7)",
  " (in 'networkModel', line 799, column 6 to line 801, column 7)",
  " (in 'networkModel', line 803, column 8 to column 105)",
  " (in 'networkModel', line 802, column 27 to line 804, column 7)",
  " (in 'networkModel', line 802, column 6 to line 804, column 7)",
  " (in 'networkModel', line 798, column 30 to line 805, column 5)",
  " (in 'networkModel', line 798, column 4 to line 805, column 5)",
  " (in 'networkModel', line 806, column 4 to column 33)",
  " (in 'networkModel', line 797, column 23 to line 807, column 3)",
  " (in 'networkModel', line 797, column 2 to line 807, column 3)",
  " (in 'networkModel', line 812, column 8 to column 104)",
  " (in 'networkModel', line 811, column 27 to line 813, column 7)",
  " (in 'networkModel', line 811, column 6 to line 813, column 7)",
  " (in 'networkModel', line 815, column 8 to column 105)",
  " (in 'networkModel', line 814, column 27 to line 816, column 7)",
  " (in 'networkModel', line 814, column 6 to line 816, column 7)",
  " (in 'networkModel', line 818, column 8 to column 105)",
  " (in 'networkModel', line 817, column 27 to line 819, column 7)",
  " (in 'networkModel', line 817, column 6 to line 819, column 7)",
  " (in 'networkModel', line 821, column 8 to column 103)",
  " (in 'networkModel', line 820, column 27 to line 822, column 7)",
  " (in 'networkModel', line 820, column 6 to line 822, column 7)",
  " (in 'networkModel', line 810, column 30 to line 823, column 5)",
  " (in 'networkModel', line 810, column 4 to line 823, column 5)",
  " (in 'networkModel', line 824, column 4 to column 33)",
  " (in 'networkModel', line 809, column 23 to line 825, column 3)",
  " (in 'networkModel', line 809, column 2 to line 825, column 3)",
  " (in 'networkModel', line 721, column 6 to column 63)",
  " (in 'networkModel', line 720, column 39 to line 722, column 5)",
  " (in 'networkModel', line 720, column 4 to line 722, column 5)",
  " (in 'networkModel', line 724, column 6 to column 62)",
  " (in 'networkModel', line 723, column 39 to line 725, column 5)",
  " (in 'networkModel', line 723, column 4 to line 725, column 5)",
  " (in 'networkModel', line 727, column 6 to column 84)",
  " (in 'networkModel', line 726, column 39 to line 728, column 5)",
  " (in 'networkModel', line 726, column 4 to line 728, column 5)",
  " (in 'networkModel', line 730, column 6 to column 95)",
  " (in 'networkModel', line 729, column 39 to line 731, column 5)",
  " (in 'networkModel', line 729, column 4 to line 731, column 5)",
  " (in 'networkModel', line 733, column 6 to column 91)",
  " (in 'networkModel', line 732, column 39 to line 734, column 5)",
  " (in 'networkModel', line 732, column 4 to line 734, column 5)",
  " (in 'networkModel', line 736, column 6 to line 737, column 73)",
  " (in 'networkModel', line 735, column 39 to line 738, column 5)",
  " (in 'networkModel', line 735, column 4 to line 738, column 5)",
  " (in 'networkModel', line 719, column 23 to line 739, column 3)",
  " (in 'networkModel', line 719, column 2 to line 739, column 3)",
  " (in 'networkModel', line 745, column 6 to line 746, column 77)",
  " (in 'networkModel', line 743, column 25 to line 747, column 5)",
  " (in 'networkModel', line 743, column 4 to line 747, column 5)",
  " (in 'networkModel', line 750, column 6 to line 751, column 77)",
  " (in 'networkModel', line 748, column 25 to line 752, column 5)",
  " (in 'networkModel', line 748, column 4 to line 752, column 5)",
  " (in 'networkModel', line 756, column 6 to line 757, column 76)",
  " (in 'networkModel', line 754, column 25 to line 758, column 5)",
  " (in 'networkModel', line 754, column 4 to line 758, column 5)",
  " (in 'networkModel', line 761, column 6 to line 762, column 77)",
  " (in 'networkModel', line 759, column 25 to line 763, column 5)",
  " (in 'networkModel', line 759, column 4 to line 763, column 5)",
  " (in 'networkModel', line 766, column 6 to line 767, column 77)",
  " (in 'networkModel', line 764, column 25 to line 768, column 5)",
  " (in 'networkModel', line 764, column 4 to line 768, column 5)",
  " (in 'networkModel', line 771, column 6 to line 772, column 75)",
  " (in 'networkModel', line 769, column 25 to line 773, column 5)",
  " (in 'networkModel', line 769, column 4 to line 773, column 5)",
  " (in 'networkModel', line 741, column 23 to line 775, column 3)",
  " (in 'networkModel', line 741, column 2 to line 775, column 3)",
  " (in 'networkModel', line 300, column 2 to column 34)",
  " (in 'networkModel', line 303, column 2 to column 22)",
  " (in 'networkModel', line 304, column 2 to column 23)",
  " (in 'networkModel', line 305, column 2 to column 23)",
  " (in 'networkModel', line 307, column 2 to column 34)",
  " (in 'networkModel', line 308, column 2 to column 35)",
  " (in 'networkModel', line 309, column 2 to column 35)",
  " (in 'networkModel', line 310, column 2 to column 32)",
  " (in 'networkModel', line 311, column 2 to column 36)",
  " (in 'networkModel', line 312, column 2 to column 39)",
  " (in 'networkModel', line 313, column 2 to column 33)",
  " (in 'networkModel', line 317, column 8 to column 15)",
  " (in 'networkModel', line 317, column 2 to column 37)",
  " (in 'networkModel', line 320, column 8 to column 15)",
  " (in 'networkModel', line 320, column 2 to column 34)",
  " (in 'networkModel', line 321, column 8 to column 15)",
  " (in 'networkModel', line 321, column 2 to column 34)",
  " (in 'networkModel', line 323, column 8 to column 15)",
  " (in 'networkModel', line 323, column 2 to column 41)",
  " (in 'networkModel', line 325, column 8 to column 15)",
  " (in 'networkModel', line 325, column 2 to column 44)",
  " (in 'networkModel', line 326, column 8 to column 15)",
  " (in 'networkModel', line 326, column 2 to column 43)",
  " (in 'networkModel', line 327, column 8 to column 15)",
  " (in 'networkModel', line 327, column 2 to column 47)",
  " (in 'networkModel', line 329, column 8 to column 15)",
  " (in 'networkModel', line 329, column 2 to column 39)",
  " (in 'networkModel', line 330, column 8 to column 15)",
  " (in 'networkModel', line 330, column 2 to column 37)",
  " (in 'networkModel', line 332, column 8 to column 15)",
  " (in 'networkModel', line 332, column 2 to column 44)",
  " (in 'networkModel', line 334, column 8 to column 15)",
  " (in 'networkModel', line 334, column 2 to column 39)",
  " (in 'networkModel', line 335, column 8 to column 15)",
  " (in 'networkModel', line 335, column 2 to column 38)",
  " (in 'networkModel', line 338, column 8 to column 15)",
  " (in 'networkModel', line 338, column 2 to column 52)",
  " (in 'networkModel', line 339, column 8 to column 15)",
  " (in 'networkModel', line 339, column 2 to column 50)",
  " (in 'networkModel', line 341, column 2 to column 34)",
  " (in 'networkModel', line 349, column 2 to column 34)",
  " (in 'networkModel', line 355, column 8 to column 14)",
  " (in 'networkModel', line 355, column 17 to column 24)",
  " (in 'networkModel', line 355, column 2 to column 58)",
  " (in 'networkModel', line 357, column 2 to column 26)",
  " (in 'networkModel', line 358, column 8 to column 17)",
  " (in 'networkModel', line 358, column 2 to column 40)",
  " (in 'networkModel', line 359, column 8 to column 18)",
  " (in 'networkModel', line 359, column 19 to column 26)",
  " (in 'networkModel', line 359, column 2 to column 55)",
  " (in 'networkModel', line 361, column 2 to column 36)",
  " (in 'networkModel', line 362, column 8 to column 14)",
  " (in 'networkModel', line 362, column 15 to column 22)",
  " (in 'networkModel', line 362, column 2 to column 56)",
  " (in 'networkModel', line 364, column 8 to column 14)",
  " (in 'networkModel', line 364, column 16 to column 23)",
  " (in 'networkModel', line 364, column 2 to column 48)",
  " (in 'networkModel', line 366, column 2 to column 29)",
  " (in 'networkModel', line 368, column 2 to column 28)",
  " (in 'networkModel', line 369, column 8 to column 17)",
  " (in 'networkModel', line 369, column 2 to column 42)",
  " (in 'networkModel', line 370, column 8 to column 20)",
  " (in 'networkModel', line 370, column 23 to column 30)",
  " (in 'networkModel', line 370, column 2 to column 60)",
  " (in 'networkModel', line 373, column 2 to column 27)",
  " (in 'networkModel', line 374, column 8 to column 17)",
  " (in 'networkModel', line 374, column 2 to column 41)",
  " (in 'networkModel', line 375, column 8 to column 19)",
  " (in 'networkModel', line 375, column 22 to column 29)",
  " (in 'networkModel', line 375, column 2 to column 58)",
  " (in 'networkModel', line 378, column 2 to column 31)",
  " (in 'networkModel', line 379, column 8 to column 17)",
  " (in 'networkModel', line 379, column 2 to column 45)",
  " (in 'networkModel', line 380, column 8 to column 23)",
  " (in 'networkModel', line 380, column 26 to column 33)",
  " (in 'networkModel', line 380, column 2 to column 67)",
  " (in 'networkModel', line 381, column 8 to column 23)",
  " (in 'networkModel', line 381, column 26 to column 33)",
  " (in 'networkModel', line 381, column 2 to column 62)",
  " (in 'networkModel', line 384, column 2 to column 28)",
  " (in 'networkModel', line 385, column 2 to column 28)",
  " (in 'networkModel', line 386, column 8 to column 17)",
  " (in 'networkModel', line 386, column 2 to column 42)",
  " (in 'networkModel', line 387, column 8 to column 17)",
  " (in 'networkModel', line 387, column 2 to column 42)",
  " (in 'networkModel', line 388, column 8 to column 20)",
  " (in 'networkModel', line 388, column 23 to column 30)",
  " (in 'networkModel', line 388, column 2 to column 61)",
  " (in 'networkModel', line 389, column 8 to column 20)",
  " (in 'networkModel', line 389, column 23 to column 30)",
  " (in 'networkModel', line 389, column 2 to column 61)",
  " (in 'networkModel', line 390, column 8 to column 20)",
  " (in 'networkModel', line 390, column 22 to column 29)",
  " (in 'networkModel', line 390, column 2 to column 54)",
  " (in 'networkModel', line 391, column 8 to column 20)",
  " (in 'networkModel', line 391, column 22 to column 29)",
  " (in 'networkModel', line 391, column 2 to column 54)",
  " (in 'networkModel', line 396, column 2 to column 33)",
  " (in 'networkModel', line 397, column 8 to column 17)",
  " (in 'networkModel', line 397, column 2 to column 47)",
  " (in 'networkModel', line 398, column 8 to column 25)",
  " (in 'networkModel', line 398, column 26 to column 33)",
  " (in 'networkModel', line 398, column 2 to column 66)",
  " (in 'networkModel', line 402, column 2 to column 28)",
  " (in 'networkModel', line 403, column 8 to column 17)",
  " (in 'networkModel', line 403, column 2 to column 42)",
  " (in 'networkModel', line 404, column 8 to column 15)",
  " (in 'networkModel', line 404, column 16 to column 28)",
  " (in 'networkModel', line 404, column 2 to column 66)",
  " (in 'networkModel', line 405, column 8 to column 15)",
  " (in 'networkModel', line 405, column 16 to column 28)",
  " (in 'networkModel', line 405, column 2 to column 63)",
  " (in 'networkModel', line 409, column 2 to column 29)",
  " (in 'networkModel', line 410, column 8 to column 17)",
  " (in 'networkModel', line 410, column 2 to column 43)",
  " (in 'networkModel', line 411, column 2 to column 29)",
  " (in 'networkModel', line 412, column 8 to column 17)",
  " (in 'networkModel', line 412, column 2 to column 43)",
  " (in 'networkModel', line 413, column 8 to column 21)",
  " (in 'networkModel', line 413, column 22 to column 29)",
  " (in 'networkModel', line 413, column 2 to column 56)",
  " (in 'networkModel', line 414, column 8 to column 21)",
  " (in 'networkModel', line 414, column 22 to column 29)",
  " (in 'networkModel', line 414, column 2 to column 54)",
  " (in 'networkModel', line 419, column 2 to column 22)",
  " (in 'networkModel', line 420, column 2 to column 34)",
  " (in 'networkModel', line 421, column 2 to column 13)",
  " (in 'networkModel', line 425, column 4 to column 42)",
  " (in 'networkModel', line 424, column 23 to line 426, column 3)",
  " (in 'networkModel', line 424, column 2 to line 426, column 3)",
  " (in 'networkModel', line 430, column 4 to column 40)",
  " (in 'networkModel', line 428, column 23 to line 431, column 3)",
  " (in 'networkModel', line 428, column 2 to line 431, column 3)",
  " (in 'networkModel', line 434, column 4 to column 41)",
  " (in 'networkModel', line 432, column 23 to line 435, column 3)",
  " (in 'networkModel', line 432, column 2 to line 435, column 3)",
  " (in 'networkModel', line 439, column 26 to column 45)",
  " (in 'networkModel', line 440, column 18 to column 37)",
  " (in 'networkModel', line 441, column 26 to column 42)",
  " (in 'networkModel', line 442, column 18 to column 38)",
  " (in 'networkModel', line 443, column 18 to column 41)",
  " (in 'networkModel', line 444, column 18 to column 35)",
  " (in 'networkModel', line 451, column 8 to column 15)",
  " (in 'networkModel', line 453, column 8 to column 14)",
  " (in 'networkModel', line 453, column 19 to column 26)",
  " (in 'networkModel', line 456, column 8 to column 15)",
  " (in 'networkModel', line 456, column 17 to column 35)",
  " (in 'networkModel', line 456, column 44 to column 50)",
  " (in 'networkModel', line 458, column 8 to column 15)",
  " (in 'networkModel', line 458, column 17 to column 35)",
  " (in 'networkModel', line 458, column 44 to column 50)",
  " (in 'networkModel', line 460, column 8 to column 20)",
  " (in 'networkModel', line 460, column 22 to column 29)",
  " (in 'networkModel', line 461, column 8 to column 20)",
  " (in 'networkModel', line 461, column 22 to column 29)",
  " (in 'networkModel', line 463, column 8 to column 20)",
  " (in 'networkModel', line 463, column 22 to column 29)",
  " (in 'networkModel', line 464, column 8 to column 20)",
  " (in 'networkModel', line 464, column 22 to column 29)",
  " (in 'networkModel', line 465, column 8 to column 20)",
  " (in 'networkModel', line 465, column 22 to column 29)",
  " (in 'networkModel', line 466, column 8 to column 20)",
  " (in 'networkModel', line 466, column 22 to column 29)",
  " (in 'networkModel', line 467, column 8 to column 20)",
  " (in 'networkModel', line 467, column 22 to column 29)",
  " (in 'networkModel', line 468, column 8 to column 20)",
  " (in 'networkModel', line 468, column 22 to column 29)",
  " (in 'networkModel', line 473, column 8 to column 21)",
  " (in 'networkModel', line 473, column 30 to column 36)",
  " (in 'networkModel', line 473, column 37 to column 43)",
  " (in 'networkModel', line 474, column 8 to column 21)",
  " (in 'networkModel', line 474, column 30 to column 36)",
  " (in 'networkModel', line 474, column 37 to column 43)",
  " (in 'networkModel', line 478, column 9 to column 15)",
  " (in 'networkModel', line 478, column 16 to column 22)",
  " (in 'networkModel', line 479, column 9 to column 15)",
  " (in 'networkModel', line 479, column 16 to column 22)",
  " (in 'networkModel', line 480, column 9 to column 15)",
  " (in 'networkModel', line 480, column 16 to column 22)",
  " (in 'networkModel', line 481, column 9 to column 15)",
  " (in 'networkModel', line 481, column 16 to column 22)",
  " (in 'networkModel', line 484, column 8 to column 25)",
  " (in 'networkModel', line 484, column 34 to column 40)",
  " (in 'networkModel', line 485, column 8 to column 25)",
  " (in 'networkModel', line 485, column 34 to column 40)",
  " (in 'networkModel', line 781, column 9 to column 27)",
  " (in 'networkModel', line 783, column 9 to column 15)",
  " (in 'networkModel', line 54, column 11 to column 17)",
  " (in 'networkModel', line 54, column 19 to column 25)",
  " (in 'networkModel', line 54, column 4 to column 68)",
  " (in 'networkModel', line 55, column 11 to column 17)",
  " (in 'networkModel', line 55, column 4 to column 53)",
  " (in 'networkModel', line 57, column 6 to column 72)",
  " (in 'networkModel', line 58, column 6 to column 58)",
  " (in 'networkModel', line 56, column 27 to line 59, column 5)",
  " (in 'networkModel', line 56, column 4 to line 59, column 5)",
  " (in 'networkModel', line 61, column 6 to column 58)",
  " (in 'networkModel', line 60, column 26 to line 62, column 5)",
  " (in 'networkModel', line 60, column 4 to line 62, column 5)",
  " (in 'networkModel', line 64, column 6 to column 36)",
  " (in 'networkModel', line 63, column 24 to line 65, column 5)",
  " (in 'networkModel', line 63, column 4 to line 65, column 5)",
  " (in 'networkModel', line 69, column 8 to column 56)",
  " (in 'networkModel', line 68, column 27 to line 70, column 7)",
  " (in 'networkModel', line 68, column 6 to line 70, column 7)",
  " (in 'networkModel', line 67, column 21 to line 71, column 5)",
  " (in 'networkModel', line 67, column 4 to line 71, column 5)",
  " (in 'networkModel', line 72, column 4 to column 21)",
  " (in 'networkModel', line 53, column 87 to line 73, column 3)",
  " (in 'networkModel', line 89, column 11 to column 17)",
  " (in 'networkModel', line 89, column 19 to column 25)",
  " (in 'networkModel', line 89, column 4 to column 50)",
  " (in 'networkModel', line 91, column 6 to column 36)",
  " (in 'networkModel', line 90, column 24 to line 92, column 5)",
  " (in 'networkModel', line 90, column 4 to line 92, column 5)",
  " (in 'networkModel', line 93, column 4 to column 21)",
  " (in 'networkModel', line 88, column 53 to line 94, column 3)",
  " (in 'networkModel', line 136, column 11 to column 17)",
  " (in 'networkModel', line 136, column 19 to column 25)",
  " (in 'networkModel', line 136, column 4 to column 70)",
  " (in 'networkModel', line 137, column 11 to column 17)",
  " (in 'networkModel', line 137, column 4 to column 53)",
  " (in 'networkModel', line 139, column 6 to column 74)",
  " (in 'networkModel', line 140, column 6 to column 58)",
  " (in 'networkModel', line 138, column 27 to line 141, column 5)",
  " (in 'networkModel', line 138, column 4 to line 141, column 5)",
  " (in 'networkModel', line 143, column 6 to column 58)",
  " (in 'networkModel', line 142, column 26 to line 144, column 5)",
  " (in 'networkModel', line 142, column 4 to line 144, column 5)",
  " (in 'networkModel', line 145, column 4 to column 21)",
  " (in 'networkModel', line 146, column 4 to column 20)",
  " (in 'networkModel', line 148, column 6 to column 42)",
  " (in 'networkModel', line 147, column 24 to line 149, column 5)",
  " (in 'networkModel', line 147, column 4 to line 149, column 5)",
  " (in 'networkModel', line 150, column 4 to column 23)",
  " (in 'networkModel', line 135, column 61 to line 151, column 3)",
  " (in 'networkModel', line 171, column 11 to column 17)",
  " (in 'networkModel', line 171, column 19 to column 25)",
  " (in 'networkModel', line 171, column 4 to column 54)",
  " (in 'networkModel', line 173, column 6 to column 43)",
  " (in 'networkModel', line 172, column 24 to line 174, column 5)",
  " (in 'networkModel', line 172, column 4 to line 174, column 5)",
  " (in 'networkModel', line 175, column 4 to column 23)",
  " (in 'networkModel', line 170, column 45 to line 176, column 3)",
  " (in 'networkModel', line 211, column 10 to column 17)",
  " (in 'networkModel', line 211, column 4 to column 55)",
  " (in 'networkModel', line 212, column 4 to column 19)",
  " (in 'networkModel', line 213, column 4 to column 17)",
  " (in 'networkModel', line 229, column 8 to column 57)",
  " (in 'networkModel', line 230, column 8 to column 53)",
  " (in 'networkModel', line 231, column 8 to column 38)",
  " (in 'networkModel', line 228, column 24 to line 232, column 7)",
  " (in 'networkModel', line 228, column 6 to line 232, column 7)",
  " (in 'networkModel', line 233, column 6 to column 19)",
  " (in 'networkModel', line 226, column 11 to line 234, column 5)",
  " (in 'networkModel', line 217, column 8 to column 57)",
  " (in 'networkModel', line 218, column 8 to column 53)",
  " (in 'networkModel', line 220, column 10 to column 60)",
  " (in 'networkModel', line 221, column 10 to column 56)",
  " (in 'networkModel', line 219, column 42 to line 222, column 9)",
  " (in 'networkModel', line 219, column 8 to line 222, column 9)",
  " (in 'networkModel', line 223, column 8 to column 38)",
  " (in 'networkModel', line 216, column 24 to line 224, column 7)",
  " (in 'networkModel', line 216, column 6 to line 224, column 7)",
  " (in 'networkModel', line 225, column 6 to column 19)",
  " (in 'networkModel', line 214, column 26 to line 226, column 5)",
  " (in 'networkModel', line 214, column 4 to line 234, column 5)",
  " (in 'networkModel', line 210, column 78 to line 235, column 3)",
  " (in 'networkModel', line 269, column 10 to column 17)",
  " (in 'networkModel', line 269, column 4 to column 55)",
  " (in 'networkModel', line 270, column 4 to column 19)",
  " (in 'networkModel', line 271, column 4 to column 17)",
  " (in 'networkModel', line 287, column 8 to column 57)",
  " (in 'networkModel', line 288, column 8 to column 53)",
  " (in 'networkModel', line 289, column 8 to column 50)",
  " (in 'networkModel', line 286, column 24 to line 290, column 7)",
  " (in 'networkModel', line 286, column 6 to line 290, column 7)",
  " (in 'networkModel', line 291, column 6 to column 19)",
  " (in 'networkModel', line 284, column 11 to line 292, column 5)",
  " (in 'networkModel', line 275, column 8 to column 57)",
  " (in 'networkModel', line 276, column 8 to column 53)",
  " (in 'networkModel', line 278, column 10 to column 60)",
  " (in 'networkModel', line 279, column 10 to column 56)",
  " (in 'networkModel', line 277, column 42 to line 280, column 9)",
  " (in 'networkModel', line 277, column 8 to line 280, column 9)",
  " (in 'networkModel', line 281, column 8 to column 50)",
  " (in 'networkModel', line 274, column 24 to line 282, column 7)",
  " (in 'networkModel', line 274, column 6 to line 282, column 7)",
  " (in 'networkModel', line 283, column 4 to column 17)",
  " (in 'networkModel', line 272, column 26 to line 284, column 5)",
  " (in 'networkModel', line 272, column 4 to line 292, column 5)",
  " (in 'networkModel', line 268, column 78 to line 293, column 3)"};
template <typename T7__,
          stan::require_all_t<stan::is_stan_scalar<T7__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<T7__>,-1,-1>
buildTransferMatrix(const int& nComps, const int& nSteady,
                    const std::vector<int>& steadyIndices, const int&
                    nUpsilons, const std::vector<std::vector<int>>& mappingU,
                    const int& nLambdas, const std::vector<std::vector<int>>&
                    mappingL, const std::vector<T7__>& params, std::ostream*
                    pstream__);
template <typename T1__, typename T2__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T1__>,
                              stan::is_vt_not_complex<T1__>,
                              stan::is_stan_scalar<T2__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T1__>, T2__>,-1,-1>
buildTransferMatrixDecay(const int& nComps, const T1__& transferRef_arg__,
                         const T2__& lambda_decay, std::ostream* pstream__);
template <typename T5__, typename T6__,
          stan::require_all_t<stan::is_stan_scalar<T5__>,
                              stan::is_stan_scalar<T6__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<T5__, T6__>,-1,-1>
buildTransitionMatrix(const int& nComps, const int& nUpsilons,
                      const std::vector<std::vector<int>>& mappingU,
                      const int& nLambdas,
                      const std::vector<std::vector<int>>& mappingL,
                      const T5__& dt, const std::vector<T6__>& params,
                      std::ostream* pstream__);
template <typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T1__>,
                              stan::is_vt_not_complex<T1__>,
                              stan::is_stan_scalar<T2__>,
                              stan::is_stan_scalar<T3__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T1__>, T2__, T3__>,-1,-1>
buildTransitionMatrixDecay(const int& nComps, const T1__&
                           transitionRef_arg__, const T2__& lambda_decay,
                           const T3__& dt, std::ostream* pstream__);
template <typename T3__, typename T4__, typename T8__,
          stan::require_all_t<stan::is_stan_scalar<T3__>,
                              stan::is_stan_scalar<T4__>,
                              stan::is_stan_scalar<T8__>>* = nullptr>
std::vector<stan::promote_args_t<T3__, T4__, T8__>>
buildSizePredictions(const int& nObs, const int& currentGroup, const int&
                     maxNobs, const std::vector<Eigen::Matrix<T3__,-1,1>>&
                     unmarked, const std::vector<Eigen::Matrix<T4__,-1,1>>&
                     marked, const std::vector<std::vector<int>>& indices,
                     const int& splitPresent, const std::vector<int>&
                     splitComps, const std::vector<std::vector<T8__>>&
                     initRefr, std::ostream* pstream__);
template <typename T3__, typename T4__, typename T8__,
          stan::require_all_t<stan::is_stan_scalar<T3__>,
                              stan::is_stan_scalar<T4__>,
                              stan::is_stan_scalar<T8__>>* = nullptr>
std::vector<stan::promote_args_t<T3__, T4__, T8__>>
buildPropPredictions(const int& nObs, const int& currentGroup, const int&
                     maxNobs, const std::vector<Eigen::Matrix<T3__,-1,1>>&
                     unmarked, const std::vector<Eigen::Matrix<T4__,-1,1>>&
                     marked, const std::vector<std::vector<int>>& indices,
                     const int& splitPresent, const std::vector<int>&
                     splitComps, const std::vector<std::vector<T8__>>&
                     initRefr, std::ostream* pstream__);
template <typename T7__, stan::require_all_t<stan::is_stan_scalar<T7__>>*>
Eigen::Matrix<stan::promote_args_t<T7__>,-1,-1>
buildTransferMatrix(const int& nComps, const int& nSteady,
                    const std::vector<int>& steadyIndices, const int&
                    nUpsilons, const std::vector<std::vector<int>>& mappingU,
                    const int& nLambdas, const std::vector<std::vector<int>>&
                    mappingL, const std::vector<T7__>& params, std::ostream*
                    pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T7__>;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 450;
    stan::math::validate_non_negative_index("transfer", "nComps", nComps);
    current_statement__ = 451;
    stan::math::validate_non_negative_index("transfer", "nComps", nComps);
    Eigen::Matrix<local_scalar_t__,-1,-1> transfer =
      Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nComps, nComps,
        DUMMY_VAR__);
    current_statement__ = 452;
    stan::model::assign(transfer, stan::math::rep_matrix(0, nComps, nComps),
      "assigning variable transfer");
    current_statement__ = 453;
    stan::math::validate_non_negative_index("lossRates", "nComps", nComps);
    Eigen::Matrix<local_scalar_t__,-1,1> lossRates =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant(nComps, DUMMY_VAR__);
    current_statement__ = 454;
    stan::model::assign(lossRates, stan::math::rep_vector(0, nComps),
      "assigning variable lossRates");
    current_statement__ = 458;
    for (int k = 1; k <= nUpsilons; ++k) {
      current_statement__ = 455;
      stan::model::assign(transfer,
        stan::model::rvalue(params, "params",
          stan::model::index_uni(
            stan::model::rvalue(mappingU, "mappingU",
              stan::model::index_uni(k), stan::model::index_uni(3)))),
        "assigning variable transfer",
        stan::model::index_uni(
          stan::model::rvalue(mappingU, "mappingU",
            stan::model::index_uni(k), stan::model::index_uni(2))),
        stan::model::index_uni(
          stan::model::rvalue(mappingU, "mappingU",
            stan::model::index_uni(k), stan::model::index_uni(1))));
      current_statement__ = 456;
      stan::model::assign(lossRates,
        (stan::model::rvalue(lossRates, "lossRates",
           stan::model::index_uni(
             stan::model::rvalue(mappingU, "mappingU",
               stan::model::index_uni(k), stan::model::index_uni(1)))) +
        stan::model::rvalue(params, "params",
          stan::model::index_uni(
            stan::model::rvalue(mappingU, "mappingU",
              stan::model::index_uni(k), stan::model::index_uni(3))))),
        "assigning variable lossRates",
        stan::model::index_uni(
          stan::model::rvalue(mappingU, "mappingU",
            stan::model::index_uni(k), stan::model::index_uni(1))));
    }
    current_statement__ = 461;
    for (int k = 1; k <= nLambdas; ++k) {
      current_statement__ = 459;
      stan::model::assign(lossRates,
        (stan::model::rvalue(lossRates, "lossRates",
           stan::model::index_uni(
             stan::model::rvalue(mappingL, "mappingL",
               stan::model::index_uni(k), stan::model::index_uni(1)))) +
        stan::model::rvalue(params, "params",
          stan::model::index_uni(
            stan::model::rvalue(mappingL, "mappingL",
              stan::model::index_uni(k), stan::model::index_uni(2))))),
        "assigning variable lossRates",
        stan::model::index_uni(
          stan::model::rvalue(mappingL, "mappingL",
            stan::model::index_uni(k), stan::model::index_uni(1))));
    }
    current_statement__ = 464;
    for (int k = 1; k <= nComps; ++k) {
      current_statement__ = 462;
      stan::model::assign(transfer,
        (stan::model::rvalue(transfer, "transfer", stan::model::index_uni(k),
           stan::model::index_uni(k)) -
        stan::model::rvalue(lossRates, "lossRates", stan::model::index_uni(k))),
        "assigning variable transfer", stan::model::index_uni(k),
        stan::model::index_uni(k));
    }
    current_statement__ = 469;
    if (stan::math::logical_gt(nSteady, 0)) {
      current_statement__ = 467;
      for (int k = 1; k <= nSteady; ++k) {
        current_statement__ = 465;
        stan::model::assign(transfer, 0, "assigning variable transfer",
          stan::model::index_uni(
            stan::model::rvalue(steadyIndices, "steadyIndices",
              stan::model::index_uni(k))),
          stan::model::index_uni(
            stan::model::rvalue(steadyIndices, "steadyIndices",
              stan::model::index_uni(k))));
      }
    }
    current_statement__ = 470;
    return transfer;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T1__, typename T2__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T1__>,
                              stan::is_vt_not_complex<T1__>,
                              stan::is_stan_scalar<T2__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T1__>, T2__>,-1,-1>
buildTransferMatrixDecay(const int& nComps, const T1__& transferRef_arg__,
                         const T2__& lambda_decay, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T1__>,
                             T2__>;
  int current_statement__ = 0;
  const auto& transferRef = stan::math::to_ref(transferRef_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 472;
    stan::math::validate_non_negative_index("transfer", "nComps", nComps);
    current_statement__ = 473;
    stan::math::validate_non_negative_index("transfer", "nComps", nComps);
    Eigen::Matrix<local_scalar_t__,-1,-1> transfer =
      Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nComps, nComps,
        DUMMY_VAR__);
    current_statement__ = 474;
    stan::model::assign(transfer, transferRef, "assigning variable transfer");
    current_statement__ = 477;
    for (int k = 1; k <= nComps; ++k) {
      current_statement__ = 475;
      stan::model::assign(transfer,
        (stan::model::rvalue(transfer, "transfer", stan::model::index_uni(k),
           stan::model::index_uni(k)) - lambda_decay),
        "assigning variable transfer", stan::model::index_uni(k),
        stan::model::index_uni(k));
    }
    current_statement__ = 478;
    return transfer;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T5__, typename T6__,
          stan::require_all_t<stan::is_stan_scalar<T5__>,
                              stan::is_stan_scalar<T6__>>*>
Eigen::Matrix<stan::promote_args_t<T5__, T6__>,-1,-1>
buildTransitionMatrix(const int& nComps, const int& nUpsilons,
                      const std::vector<std::vector<int>>& mappingU,
                      const int& nLambdas,
                      const std::vector<std::vector<int>>& mappingL,
                      const T5__& dt, const std::vector<T6__>& params,
                      std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T5__, T6__>;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 480;
    stan::math::validate_non_negative_index("transition", "nComps", nComps);
    current_statement__ = 481;
    stan::math::validate_non_negative_index("transition", "nComps", nComps);
    Eigen::Matrix<local_scalar_t__,-1,-1> transition =
      Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nComps, nComps,
        DUMMY_VAR__);
    current_statement__ = 482;
    stan::model::assign(transition,
      stan::math::rep_matrix(0, nComps, nComps),
      "assigning variable transition");
    current_statement__ = 483;
    stan::math::validate_non_negative_index("lossRates", "nComps", nComps);
    Eigen::Matrix<local_scalar_t__,-1,1> lossRates =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant(nComps, DUMMY_VAR__);
    current_statement__ = 484;
    stan::model::assign(lossRates, stan::math::rep_vector(0, nComps),
      "assigning variable lossRates");
    current_statement__ = 488;
    for (int k = 1; k <= nUpsilons; ++k) {
      current_statement__ = 485;
      stan::model::assign(transition,
        stan::model::rvalue(params, "params",
          stan::model::index_uni(
            stan::model::rvalue(mappingU, "mappingU",
              stan::model::index_uni(k), stan::model::index_uni(3)))),
        "assigning variable transition",
        stan::model::index_uni(
          stan::model::rvalue(mappingU, "mappingU",
            stan::model::index_uni(k), stan::model::index_uni(2))),
        stan::model::index_uni(
          stan::model::rvalue(mappingU, "mappingU",
            stan::model::index_uni(k), stan::model::index_uni(1))));
      current_statement__ = 486;
      stan::model::assign(lossRates,
        (stan::model::rvalue(lossRates, "lossRates",
           stan::model::index_uni(
             stan::model::rvalue(mappingU, "mappingU",
               stan::model::index_uni(k), stan::model::index_uni(1)))) +
        stan::model::rvalue(params, "params",
          stan::model::index_uni(
            stan::model::rvalue(mappingU, "mappingU",
              stan::model::index_uni(k), stan::model::index_uni(3))))),
        "assigning variable lossRates",
        stan::model::index_uni(
          stan::model::rvalue(mappingU, "mappingU",
            stan::model::index_uni(k), stan::model::index_uni(1))));
    }
    current_statement__ = 491;
    for (int k = 1; k <= nLambdas; ++k) {
      current_statement__ = 489;
      stan::model::assign(lossRates,
        (stan::model::rvalue(lossRates, "lossRates",
           stan::model::index_uni(
             stan::model::rvalue(mappingL, "mappingL",
               stan::model::index_uni(k), stan::model::index_uni(1)))) +
        stan::model::rvalue(params, "params",
          stan::model::index_uni(
            stan::model::rvalue(mappingL, "mappingL",
              stan::model::index_uni(k), stan::model::index_uni(2))))),
        "assigning variable lossRates",
        stan::model::index_uni(
          stan::model::rvalue(mappingL, "mappingL",
            stan::model::index_uni(k), stan::model::index_uni(1))));
    }
    current_statement__ = 492;
    stan::model::assign(transition,
      stan::math::multiply(stan::model::deep_copy(transition), dt),
      "assigning variable transition");
    current_statement__ = 493;
    stan::model::assign(lossRates,
      stan::math::multiply(stan::model::deep_copy(lossRates), dt),
      "assigning variable lossRates");
    current_statement__ = 496;
    for (int k = 1; k <= nComps; ++k) {
      current_statement__ = 494;
      stan::model::assign(transition,
        (stan::model::rvalue(transition, "transition",
           stan::model::index_uni(k), stan::model::index_uni(k)) + (1 -
        stan::model::rvalue(lossRates, "lossRates", stan::model::index_uni(k)))),
        "assigning variable transition", stan::model::index_uni(k),
        stan::model::index_uni(k));
    }
    current_statement__ = 497;
    return transition;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T1__>,
                              stan::is_vt_not_complex<T1__>,
                              stan::is_stan_scalar<T2__>,
                              stan::is_stan_scalar<T3__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T1__>, T2__, T3__>,-1,-1>
buildTransitionMatrixDecay(const int& nComps, const T1__&
                           transitionRef_arg__, const T2__& lambda_decay,
                           const T3__& dt, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T1__>,
                             T2__, T3__>;
  int current_statement__ = 0;
  const auto& transitionRef = stan::math::to_ref(transitionRef_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 499;
    stan::math::validate_non_negative_index("transition", "nComps", nComps);
    current_statement__ = 500;
    stan::math::validate_non_negative_index("transition", "nComps", nComps);
    Eigen::Matrix<local_scalar_t__,-1,-1> transition =
      Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nComps, nComps,
        DUMMY_VAR__);
    current_statement__ = 501;
    stan::model::assign(transition, transitionRef,
      "assigning variable transition");
    current_statement__ = 504;
    for (int k = 1; k <= nComps; ++k) {
      current_statement__ = 502;
      stan::model::assign(transition,
        (stan::model::rvalue(transition, "transition",
           stan::model::index_uni(k), stan::model::index_uni(k)) -
        (lambda_decay * dt)), "assigning variable transition",
        stan::model::index_uni(k), stan::model::index_uni(k));
    }
    current_statement__ = 505;
    return transition;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T3__, typename T4__, typename T8__,
          stan::require_all_t<stan::is_stan_scalar<T3__>,
                              stan::is_stan_scalar<T4__>,
                              stan::is_stan_scalar<T8__>>*>
std::vector<stan::promote_args_t<T3__, T4__, T8__>>
buildSizePredictions(const int& nObs, const int& currentGroup, const int&
                     maxNobs, const std::vector<Eigen::Matrix<T3__,-1,1>>&
                     unmarked, const std::vector<Eigen::Matrix<T4__,-1,1>>&
                     marked, const std::vector<std::vector<int>>& indices,
                     const int& splitPresent, const std::vector<int>&
                     splitComps, const std::vector<std::vector<T8__>>&
                     initRefr, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T3__, T4__, T8__>;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 507;
    stan::math::validate_non_negative_index("pred", "maxNobs", maxNobs);
    std::vector<local_scalar_t__> pred =
      std::vector<local_scalar_t__>(maxNobs, DUMMY_VAR__);
    current_statement__ = 508;
    stan::model::assign(pred, stan::math::rep_array(0.0, maxNobs),
      "assigning variable pred");
    local_scalar_t__ unmarkedQ = DUMMY_VAR__;
    local_scalar_t__ markedQ = DUMMY_VAR__;
    current_statement__ = 529;
    if (stan::math::logical_gt(splitPresent, 0)) {
      current_statement__ = 526;
      for (int k = 1; k <= nObs; ++k) {
        current_statement__ = 518;
        unmarkedQ = stan::model::rvalue(
                      stan::model::rvalue(unmarked, "unmarked",
                        stan::model::index_uni(
                          stan::model::rvalue(indices, "indices",
                            stan::model::index_uni(k),
                            stan::model::index_uni(2)))),
                      "unmarked[indices[k, 2]]",
                      stan::model::index_uni(
                        stan::model::rvalue(indices, "indices",
                          stan::model::index_uni(k),
                          stan::model::index_uni(1))));
        current_statement__ = 519;
        markedQ = stan::model::rvalue(
                    stan::model::rvalue(marked, "marked",
                      stan::model::index_uni(
                        stan::model::rvalue(indices, "indices",
                          stan::model::index_uni(k),
                          stan::model::index_uni(2)))),
                    "marked[indices[k, 2]]",
                    stan::model::index_uni(
                      stan::model::rvalue(indices, "indices",
                        stan::model::index_uni(k), stan::model::index_uni(1))));
        current_statement__ = 523;
        if (stan::math::logical_gt(
              stan::model::rvalue(splitComps, "splitComps",
                stan::model::index_uni(
                  stan::model::rvalue(indices, "indices",
                    stan::model::index_uni(k), stan::model::index_uni(1)))),
              0)) {
          current_statement__ = 520;
          unmarkedQ = (unmarkedQ +
            stan::model::rvalue(initRefr, "initRefr",
              stan::model::index_uni(
                stan::model::rvalue(indices, "indices",
                  stan::model::index_uni(k), stan::model::index_uni(1))),
              stan::model::index_uni(1)));
          current_statement__ = 521;
          markedQ = (markedQ +
            stan::model::rvalue(initRefr, "initRefr",
              stan::model::index_uni(
                stan::model::rvalue(indices, "indices",
                  stan::model::index_uni(k), stan::model::index_uni(1))),
              stan::model::index_uni(2)));
        }
        current_statement__ = 524;
        stan::model::assign(pred, (unmarkedQ + markedQ),
          "assigning variable pred", stan::model::index_uni(k));
      }
      current_statement__ = 527;
      return pred;
    } else {
      current_statement__ = 515;
      for (int k = 1; k <= nObs; ++k) {
        current_statement__ = 511;
        unmarkedQ = stan::model::rvalue(
                      stan::model::rvalue(unmarked, "unmarked",
                        stan::model::index_uni(
                          stan::model::rvalue(indices, "indices",
                            stan::model::index_uni(k),
                            stan::model::index_uni(2)))),
                      "unmarked[indices[k, 2]]",
                      stan::model::index_uni(
                        stan::model::rvalue(indices, "indices",
                          stan::model::index_uni(k),
                          stan::model::index_uni(1))));
        current_statement__ = 512;
        markedQ = stan::model::rvalue(
                    stan::model::rvalue(marked, "marked",
                      stan::model::index_uni(
                        stan::model::rvalue(indices, "indices",
                          stan::model::index_uni(k),
                          stan::model::index_uni(2)))),
                    "marked[indices[k, 2]]",
                    stan::model::index_uni(
                      stan::model::rvalue(indices, "indices",
                        stan::model::index_uni(k), stan::model::index_uni(1))));
        current_statement__ = 513;
        stan::model::assign(pred, (unmarkedQ + markedQ),
          "assigning variable pred", stan::model::index_uni(k));
      }
      current_statement__ = 516;
      return pred;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T3__, typename T4__, typename T8__,
          stan::require_all_t<stan::is_stan_scalar<T3__>,
                              stan::is_stan_scalar<T4__>,
                              stan::is_stan_scalar<T8__>>*>
std::vector<stan::promote_args_t<T3__, T4__, T8__>>
buildPropPredictions(const int& nObs, const int& currentGroup, const int&
                     maxNobs, const std::vector<Eigen::Matrix<T3__,-1,1>>&
                     unmarked, const std::vector<Eigen::Matrix<T4__,-1,1>>&
                     marked, const std::vector<std::vector<int>>& indices,
                     const int& splitPresent, const std::vector<int>&
                     splitComps, const std::vector<std::vector<T8__>>&
                     initRefr, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T3__, T4__, T8__>;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 531;
    stan::math::validate_non_negative_index("pred", "maxNobs", maxNobs);
    std::vector<local_scalar_t__> pred =
      std::vector<local_scalar_t__>(maxNobs, DUMMY_VAR__);
    current_statement__ = 532;
    stan::model::assign(pred, stan::math::rep_array(0.0, maxNobs),
      "assigning variable pred");
    local_scalar_t__ unmarkedQ = DUMMY_VAR__;
    local_scalar_t__ markedQ = DUMMY_VAR__;
    current_statement__ = 553;
    if (stan::math::logical_gt(splitPresent, 0)) {
      current_statement__ = 550;
      for (int k = 1; k <= nObs; ++k) {
        current_statement__ = 542;
        unmarkedQ = stan::model::rvalue(
                      stan::model::rvalue(unmarked, "unmarked",
                        stan::model::index_uni(
                          stan::model::rvalue(indices, "indices",
                            stan::model::index_uni(k),
                            stan::model::index_uni(2)))),
                      "unmarked[indices[k, 2]]",
                      stan::model::index_uni(
                        stan::model::rvalue(indices, "indices",
                          stan::model::index_uni(k),
                          stan::model::index_uni(1))));
        current_statement__ = 543;
        markedQ = stan::model::rvalue(
                    stan::model::rvalue(marked, "marked",
                      stan::model::index_uni(
                        stan::model::rvalue(indices, "indices",
                          stan::model::index_uni(k),
                          stan::model::index_uni(2)))),
                    "marked[indices[k, 2]]",
                    stan::model::index_uni(
                      stan::model::rvalue(indices, "indices",
                        stan::model::index_uni(k), stan::model::index_uni(1))));
        current_statement__ = 547;
        if (stan::math::logical_gt(
              stan::model::rvalue(splitComps, "splitComps",
                stan::model::index_uni(
                  stan::model::rvalue(indices, "indices",
                    stan::model::index_uni(k), stan::model::index_uni(1)))),
              0)) {
          current_statement__ = 544;
          unmarkedQ = (unmarkedQ +
            stan::model::rvalue(initRefr, "initRefr",
              stan::model::index_uni(
                stan::model::rvalue(indices, "indices",
                  stan::model::index_uni(k), stan::model::index_uni(1))),
              stan::model::index_uni(1)));
          current_statement__ = 545;
          markedQ = (markedQ +
            stan::model::rvalue(initRefr, "initRefr",
              stan::model::index_uni(
                stan::model::rvalue(indices, "indices",
                  stan::model::index_uni(k), stan::model::index_uni(1))),
              stan::model::index_uni(2)));
        }
        current_statement__ = 548;
        stan::model::assign(pred, (markedQ / (unmarkedQ + markedQ)),
          "assigning variable pred", stan::model::index_uni(k));
      }
      current_statement__ = 551;
      return pred;
    } else {
      current_statement__ = 539;
      for (int k = 1; k <= nObs; ++k) {
        current_statement__ = 535;
        unmarkedQ = stan::model::rvalue(
                      stan::model::rvalue(unmarked, "unmarked",
                        stan::model::index_uni(
                          stan::model::rvalue(indices, "indices",
                            stan::model::index_uni(k),
                            stan::model::index_uni(2)))),
                      "unmarked[indices[k, 2]]",
                      stan::model::index_uni(
                        stan::model::rvalue(indices, "indices",
                          stan::model::index_uni(k),
                          stan::model::index_uni(1))));
        current_statement__ = 536;
        markedQ = stan::model::rvalue(
                    stan::model::rvalue(marked, "marked",
                      stan::model::index_uni(
                        stan::model::rvalue(indices, "indices",
                          stan::model::index_uni(k),
                          stan::model::index_uni(2)))),
                    "marked[indices[k, 2]]",
                    stan::model::index_uni(
                      stan::model::rvalue(indices, "indices",
                        stan::model::index_uni(k), stan::model::index_uni(1))));
        current_statement__ = 537;
        stan::model::assign(pred, (markedQ / (unmarkedQ + markedQ)),
          "assigning variable pred", stan::model::index_uni(k));
      }
      current_statement__ = 540;
      return pred;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
#include <stan_meta_header.hpp>
class model_networkModel final : public model_base_crtp<model_networkModel> {
private:
  int ode_method;
  int nComps;
  int nGroups;
  int nParams;
  int nNonConstantPriors;
  int nPriorUniform_code1;
  int nPriorHcauchy_code2;
  int nPriorBeta_code3;
  int nPriorTrNormal_code4;
  int nPriorExponential_code5;
  int nPriorGamma_code6;
  std::vector<double> constantParams;
  std::vector<double> lowerParams;
  std::vector<double> upperParams;
  std::vector<double> hcauchyScaleParams;
  std::vector<double> rawBetaAlpha;
  std::vector<double> rawBetaBeta;
  std::vector<double> betaScaleParams;
  std::vector<double> trNormMeanParams;
  std::vector<double> trNormSdParams;
  std::vector<double> exponentialRateParams;
  std::vector<double> gammaAlphaParams;
  std::vector<double> gammaBetaParams;
  std::vector<int> mappingParamPriorType;
  std::vector<int> mappingParamPriorID;
  int propFamily;
  int sizeFamily;
  std::vector<std::vector<std::vector<double>>> initialQuantities;
  int maxNsteady;
  std::vector<int> nSteady;
  std::vector<std::vector<int>> steadyIndices;
  int splitPresent;
  std::vector<std::vector<int>> splitComps;
  std::vector<std::vector<int>> piMapping;
  double lambda_decay;
  int maxNupsilons;
  std::vector<int> nUpsilons;
  std::vector<std::vector<std::vector<int>>> upsilonMapping;
  int maxNlambdas;
  std::vector<int> nLambdas;
  std::vector<std::vector<std::vector<int>>> lambdaMapping;
  int maxNpulseEvents;
  std::vector<int> nPulseEvents;
  std::vector<std::vector<std::vector<int>>> pulseEventsIndices;
  std::vector<std::vector<std::vector<double>>> pulseEventsQuantities;
  int maxNsizesObs;
  int maxNpropsObs;
  std::vector<int> nSizesObs;
  std::vector<int> nPropsObs;
  std::vector<std::vector<std::vector<int>>> sizesObsIndices;
  std::vector<std::vector<std::vector<int>>> propsObsIndices;
  std::vector<std::vector<double>> sizesObs;
  std::vector<std::vector<double>> propsObs;
  int maxNtimeIntervals;
  std::vector<int> nTimeIntervals;
  std::vector<std::vector<double>> intervalsLengths;
  int maxNobsTimes;
  std::vector<int> nObsTimes;
  std::vector<std::vector<double>> elapsedTimeSinceEvent;
  std::vector<std::vector<int>> obsIntervalsIndices;
  int maxNtimesteps;
  std::vector<int> nTimesteps;
  int maxNuniqueDts;
  std::vector<int> nUniqueDts;
  std::vector<std::vector<double>> unique_dts;
  std::vector<std::vector<int>> timesteps;
  int nTotal;
  int n_quantity_records;
public:
  ~model_networkModel() {}
  model_networkModel(stan::io::var_context& context__, unsigned int
                     random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "model_networkModel_namespace::model_networkModel";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 263;
      context__.validate_dims("data initialization", "ode_method", "int",
        std::vector<size_t>{});
      ode_method = std::numeric_limits<int>::min();
      current_statement__ = 263;
      ode_method = context__.vals_i("ode_method")[(1 - 1)];
      current_statement__ = 263;
      stan::math::check_greater_or_equal(function__, "ode_method",
        ode_method, 1);
      current_statement__ = 263;
      stan::math::check_less_or_equal(function__, "ode_method", ode_method, 2);
      current_statement__ = 264;
      context__.validate_dims("data initialization", "nComps", "int",
        std::vector<size_t>{});
      nComps = std::numeric_limits<int>::min();
      current_statement__ = 264;
      nComps = context__.vals_i("nComps")[(1 - 1)];
      current_statement__ = 264;
      stan::math::check_greater_or_equal(function__, "nComps", nComps, 1);
      current_statement__ = 265;
      context__.validate_dims("data initialization", "nGroups", "int",
        std::vector<size_t>{});
      nGroups = std::numeric_limits<int>::min();
      current_statement__ = 265;
      nGroups = context__.vals_i("nGroups")[(1 - 1)];
      current_statement__ = 265;
      stan::math::check_greater_or_equal(function__, "nGroups", nGroups, 0);
      current_statement__ = 266;
      context__.validate_dims("data initialization", "nParams", "int",
        std::vector<size_t>{});
      nParams = std::numeric_limits<int>::min();
      current_statement__ = 266;
      nParams = context__.vals_i("nParams")[(1 - 1)];
      current_statement__ = 266;
      stan::math::check_greater_or_equal(function__, "nParams", nParams, 0);
      current_statement__ = 267;
      context__.validate_dims("data initialization", "nNonConstantPriors",
        "int", std::vector<size_t>{});
      nNonConstantPriors = std::numeric_limits<int>::min();
      current_statement__ = 267;
      nNonConstantPriors = context__.vals_i("nNonConstantPriors")[(1 - 1)];
      current_statement__ = 267;
      stan::math::check_greater_or_equal(function__, "nNonConstantPriors",
        nNonConstantPriors, 1);
      current_statement__ = 268;
      context__.validate_dims("data initialization", "nPriorUniform_code1",
        "int", std::vector<size_t>{});
      nPriorUniform_code1 = std::numeric_limits<int>::min();
      current_statement__ = 268;
      nPriorUniform_code1 = context__.vals_i("nPriorUniform_code1")[(1 - 1)];
      current_statement__ = 268;
      stan::math::check_greater_or_equal(function__, "nPriorUniform_code1",
        nPriorUniform_code1, 0);
      current_statement__ = 269;
      context__.validate_dims("data initialization", "nPriorHcauchy_code2",
        "int", std::vector<size_t>{});
      nPriorHcauchy_code2 = std::numeric_limits<int>::min();
      current_statement__ = 269;
      nPriorHcauchy_code2 = context__.vals_i("nPriorHcauchy_code2")[(1 - 1)];
      current_statement__ = 269;
      stan::math::check_greater_or_equal(function__, "nPriorHcauchy_code2",
        nPriorHcauchy_code2, 0);
      current_statement__ = 270;
      context__.validate_dims("data initialization", "nPriorBeta_code3",
        "int", std::vector<size_t>{});
      nPriorBeta_code3 = std::numeric_limits<int>::min();
      current_statement__ = 270;
      nPriorBeta_code3 = context__.vals_i("nPriorBeta_code3")[(1 - 1)];
      current_statement__ = 270;
      stan::math::check_greater_or_equal(function__, "nPriorBeta_code3",
        nPriorBeta_code3, 0);
      current_statement__ = 271;
      context__.validate_dims("data initialization", "nPriorTrNormal_code4",
        "int", std::vector<size_t>{});
      nPriorTrNormal_code4 = std::numeric_limits<int>::min();
      current_statement__ = 271;
      nPriorTrNormal_code4 = context__.vals_i("nPriorTrNormal_code4")[(1 -
        1)];
      current_statement__ = 271;
      stan::math::check_greater_or_equal(function__, "nPriorTrNormal_code4",
        nPriorTrNormal_code4, 0);
      current_statement__ = 272;
      context__.validate_dims("data initialization",
        "nPriorExponential_code5", "int", std::vector<size_t>{});
      nPriorExponential_code5 = std::numeric_limits<int>::min();
      current_statement__ = 272;
      nPriorExponential_code5 = context__.vals_i("nPriorExponential_code5")[(1
        - 1)];
      current_statement__ = 272;
      stan::math::check_greater_or_equal(function__,
        "nPriorExponential_code5", nPriorExponential_code5, 0);
      current_statement__ = 273;
      context__.validate_dims("data initialization", "nPriorGamma_code6",
        "int", std::vector<size_t>{});
      nPriorGamma_code6 = std::numeric_limits<int>::min();
      current_statement__ = 273;
      nPriorGamma_code6 = context__.vals_i("nPriorGamma_code6")[(1 - 1)];
      current_statement__ = 273;
      stan::math::check_greater_or_equal(function__, "nPriorGamma_code6",
        nPriorGamma_code6, 0);
      current_statement__ = 274;
      stan::math::validate_non_negative_index("constantParams", "nParams",
        nParams);
      current_statement__ = 275;
      context__.validate_dims("data initialization", "constantParams",
        "double", std::vector<size_t>{static_cast<size_t>(nParams)});
      constantParams = std::vector<double>(nParams,
                         std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 275;
      constantParams = context__.vals_r("constantParams");
      current_statement__ = 276;
      stan::math::validate_non_negative_index("lowerParams", "nParams",
        nParams);
      current_statement__ = 277;
      context__.validate_dims("data initialization", "lowerParams", "double",
        std::vector<size_t>{static_cast<size_t>(nParams)});
      lowerParams = std::vector<double>(nParams,
                      std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 277;
      lowerParams = context__.vals_r("lowerParams");
      current_statement__ = 278;
      stan::math::validate_non_negative_index("upperParams", "nParams",
        nParams);
      current_statement__ = 279;
      context__.validate_dims("data initialization", "upperParams", "double",
        std::vector<size_t>{static_cast<size_t>(nParams)});
      upperParams = std::vector<double>(nParams,
                      std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 279;
      upperParams = context__.vals_r("upperParams");
      current_statement__ = 280;
      stan::math::validate_non_negative_index("hcauchyScaleParams",
        "nParams", nParams);
      current_statement__ = 281;
      context__.validate_dims("data initialization", "hcauchyScaleParams",
        "double", std::vector<size_t>{static_cast<size_t>(nParams)});
      hcauchyScaleParams = std::vector<double>(nParams,
                             std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 281;
      hcauchyScaleParams = context__.vals_r("hcauchyScaleParams");
      current_statement__ = 282;
      stan::math::validate_non_negative_index("rawBetaAlpha", "nParams",
        nParams);
      current_statement__ = 283;
      context__.validate_dims("data initialization", "rawBetaAlpha",
        "double", std::vector<size_t>{static_cast<size_t>(nParams)});
      rawBetaAlpha = std::vector<double>(nParams,
                       std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 283;
      rawBetaAlpha = context__.vals_r("rawBetaAlpha");
      current_statement__ = 283;
      stan::math::check_greater_or_equal(function__, "rawBetaAlpha",
        rawBetaAlpha, 0);
      current_statement__ = 284;
      stan::math::validate_non_negative_index("rawBetaBeta", "nParams",
        nParams);
      current_statement__ = 285;
      context__.validate_dims("data initialization", "rawBetaBeta", "double",
        std::vector<size_t>{static_cast<size_t>(nParams)});
      rawBetaBeta = std::vector<double>(nParams,
                      std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 285;
      rawBetaBeta = context__.vals_r("rawBetaBeta");
      current_statement__ = 285;
      stan::math::check_greater_or_equal(function__, "rawBetaBeta",
        rawBetaBeta, 0);
      current_statement__ = 286;
      stan::math::validate_non_negative_index("betaScaleParams", "nParams",
        nParams);
      current_statement__ = 287;
      context__.validate_dims("data initialization", "betaScaleParams",
        "double", std::vector<size_t>{static_cast<size_t>(nParams)});
      betaScaleParams = std::vector<double>(nParams,
                          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 287;
      betaScaleParams = context__.vals_r("betaScaleParams");
      current_statement__ = 287;
      stan::math::check_greater_or_equal(function__, "betaScaleParams",
        betaScaleParams, 0);
      current_statement__ = 288;
      stan::math::validate_non_negative_index("trNormMeanParams", "nParams",
        nParams);
      current_statement__ = 289;
      context__.validate_dims("data initialization", "trNormMeanParams",
        "double", std::vector<size_t>{static_cast<size_t>(nParams)});
      trNormMeanParams = std::vector<double>(nParams,
                           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 289;
      trNormMeanParams = context__.vals_r("trNormMeanParams");
      current_statement__ = 290;
      stan::math::validate_non_negative_index("trNormSdParams", "nParams",
        nParams);
      current_statement__ = 291;
      context__.validate_dims("data initialization", "trNormSdParams",
        "double", std::vector<size_t>{static_cast<size_t>(nParams)});
      trNormSdParams = std::vector<double>(nParams,
                         std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 291;
      trNormSdParams = context__.vals_r("trNormSdParams");
      current_statement__ = 292;
      stan::math::validate_non_negative_index("exponentialRateParams",
        "nParams", nParams);
      current_statement__ = 293;
      context__.validate_dims("data initialization", "exponentialRateParams",
        "double", std::vector<size_t>{static_cast<size_t>(nParams)});
      exponentialRateParams = std::vector<double>(nParams,
                                std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 293;
      exponentialRateParams = context__.vals_r("exponentialRateParams");
      current_statement__ = 294;
      stan::math::validate_non_negative_index("gammaAlphaParams", "nParams",
        nParams);
      current_statement__ = 295;
      context__.validate_dims("data initialization", "gammaAlphaParams",
        "double", std::vector<size_t>{static_cast<size_t>(nParams)});
      gammaAlphaParams = std::vector<double>(nParams,
                           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 295;
      gammaAlphaParams = context__.vals_r("gammaAlphaParams");
      current_statement__ = 296;
      stan::math::validate_non_negative_index("gammaBetaParams", "nParams",
        nParams);
      current_statement__ = 297;
      context__.validate_dims("data initialization", "gammaBetaParams",
        "double", std::vector<size_t>{static_cast<size_t>(nParams)});
      gammaBetaParams = std::vector<double>(nParams,
                          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 297;
      gammaBetaParams = context__.vals_r("gammaBetaParams");
      current_statement__ = 298;
      stan::math::validate_non_negative_index("mappingParamPriorType",
        "nParams", nParams);
      current_statement__ = 299;
      context__.validate_dims("data initialization", "mappingParamPriorType",
        "int", std::vector<size_t>{static_cast<size_t>(nParams)});
      mappingParamPriorType = std::vector<int>(nParams,
                                std::numeric_limits<int>::min());
      current_statement__ = 299;
      mappingParamPriorType = context__.vals_i("mappingParamPriorType");
      current_statement__ = 299;
      stan::math::check_greater_or_equal(function__, "mappingParamPriorType",
        mappingParamPriorType, 0);
      current_statement__ = 300;
      stan::math::validate_non_negative_index("mappingParamPriorID",
        "nParams", nParams);
      current_statement__ = 301;
      context__.validate_dims("data initialization", "mappingParamPriorID",
        "int", std::vector<size_t>{static_cast<size_t>(nParams)});
      mappingParamPriorID = std::vector<int>(nParams,
                              std::numeric_limits<int>::min());
      current_statement__ = 301;
      mappingParamPriorID = context__.vals_i("mappingParamPriorID");
      current_statement__ = 301;
      stan::math::check_greater_or_equal(function__, "mappingParamPriorID",
        mappingParamPriorID, 0);
      current_statement__ = 302;
      context__.validate_dims("data initialization", "propFamily", "int",
        std::vector<size_t>{});
      propFamily = std::numeric_limits<int>::min();
      current_statement__ = 302;
      propFamily = context__.vals_i("propFamily")[(1 - 1)];
      current_statement__ = 302;
      stan::math::check_greater_or_equal(function__, "propFamily",
        propFamily, 1);
      current_statement__ = 302;
      stan::math::check_less_or_equal(function__, "propFamily", propFamily, 4);
      current_statement__ = 303;
      context__.validate_dims("data initialization", "sizeFamily", "int",
        std::vector<size_t>{});
      sizeFamily = std::numeric_limits<int>::min();
      current_statement__ = 303;
      sizeFamily = context__.vals_i("sizeFamily")[(1 - 1)];
      current_statement__ = 303;
      stan::math::check_greater_or_equal(function__, "sizeFamily",
        sizeFamily, 1);
      current_statement__ = 303;
      stan::math::check_less_or_equal(function__, "sizeFamily", sizeFamily, 2);
      current_statement__ = 304;
      stan::math::validate_non_negative_index("initialQuantities", "nComps",
        nComps);
      current_statement__ = 305;
      stan::math::validate_non_negative_index("initialQuantities", "nGroups",
        nGroups);
      current_statement__ = 306;
      context__.validate_dims("data initialization", "initialQuantities",
        "double",
        std::vector<size_t>{static_cast<size_t>(nComps),
          static_cast<size_t>(2), static_cast<size_t>(nGroups)});
      initialQuantities = std::vector<std::vector<std::vector<double>>>(nComps,
                            std::vector<std::vector<double>>(2,
                              std::vector<double>(nGroups,
                                std::numeric_limits<double>::quiet_NaN())));
      {
        std::vector<local_scalar_t__> initialQuantities_flat__;
        current_statement__ = 306;
        initialQuantities_flat__ = context__.vals_r("initialQuantities");
        current_statement__ = 306;
        pos__ = 1;
        current_statement__ = 306;
        for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
          current_statement__ = 306;
          for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
            current_statement__ = 306;
            for (int sym3__ = 1; sym3__ <= nComps; ++sym3__) {
              current_statement__ = 306;
              stan::model::assign(initialQuantities,
                initialQuantities_flat__[(pos__ - 1)],
                "assigning variable initialQuantities",
                stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              current_statement__ = 306;
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      current_statement__ = 306;
      stan::math::check_greater_or_equal(function__, "initialQuantities",
        initialQuantities, 0);
      current_statement__ = 307;
      context__.validate_dims("data initialization", "maxNsteady", "int",
        std::vector<size_t>{});
      maxNsteady = std::numeric_limits<int>::min();
      current_statement__ = 307;
      maxNsteady = context__.vals_i("maxNsteady")[(1 - 1)];
      current_statement__ = 307;
      stan::math::check_greater_or_equal(function__, "maxNsteady",
        maxNsteady, 0);
      current_statement__ = 308;
      stan::math::validate_non_negative_index("nSteady", "nGroups + 1",
        (nGroups + 1));
      current_statement__ = 309;
      context__.validate_dims("data initialization", "nSteady", "int",
        std::vector<size_t>{static_cast<size_t>((nGroups + 1))});
      nSteady = std::vector<int>((nGroups + 1),
                  std::numeric_limits<int>::min());
      current_statement__ = 309;
      nSteady = context__.vals_i("nSteady");
      current_statement__ = 309;
      stan::math::check_greater_or_equal(function__, "nSteady", nSteady, 0);
      current_statement__ = 310;
      stan::math::validate_non_negative_index("steadyIndices", "maxNsteady",
        maxNsteady);
      current_statement__ = 311;
      stan::math::validate_non_negative_index("steadyIndices", "nGroups",
        nGroups);
      current_statement__ = 312;
      context__.validate_dims("data initialization", "steadyIndices", "int",
        std::vector<size_t>{static_cast<size_t>(maxNsteady),
          static_cast<size_t>(nGroups)});
      steadyIndices = std::vector<std::vector<int>>(maxNsteady,
                        std::vector<int>(nGroups,
                          std::numeric_limits<int>::min()));
      {
        std::vector<int> steadyIndices_flat__;
        current_statement__ = 312;
        steadyIndices_flat__ = context__.vals_i("steadyIndices");
        current_statement__ = 312;
        pos__ = 1;
        current_statement__ = 312;
        for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
          current_statement__ = 312;
          for (int sym2__ = 1; sym2__ <= maxNsteady; ++sym2__) {
            current_statement__ = 312;
            stan::model::assign(steadyIndices, steadyIndices_flat__[(pos__ -
              1)], "assigning variable steadyIndices",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            current_statement__ = 312;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 312;
      stan::math::check_greater_or_equal(function__, "steadyIndices",
        steadyIndices, 0);
      current_statement__ = 313;
      context__.validate_dims("data initialization", "splitPresent", "int",
        std::vector<size_t>{});
      splitPresent = std::numeric_limits<int>::min();
      current_statement__ = 313;
      splitPresent = context__.vals_i("splitPresent")[(1 - 1)];
      current_statement__ = 313;
      stan::math::check_greater_or_equal(function__, "splitPresent",
        splitPresent, 0);
      current_statement__ = 313;
      stan::math::check_less_or_equal(function__, "splitPresent",
        splitPresent, 1);
      current_statement__ = 314;
      stan::math::validate_non_negative_index("splitComps", "nComps", nComps);
      current_statement__ = 315;
      stan::math::validate_non_negative_index("splitComps", "nGroups",
        nGroups);
      current_statement__ = 316;
      context__.validate_dims("data initialization", "splitComps", "int",
        std::vector<size_t>{static_cast<size_t>(nComps),
          static_cast<size_t>(nGroups)});
      splitComps = std::vector<std::vector<int>>(nComps,
                     std::vector<int>(nGroups,
                       std::numeric_limits<int>::min()));
      {
        std::vector<int> splitComps_flat__;
        current_statement__ = 316;
        splitComps_flat__ = context__.vals_i("splitComps");
        current_statement__ = 316;
        pos__ = 1;
        current_statement__ = 316;
        for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
          current_statement__ = 316;
          for (int sym2__ = 1; sym2__ <= nComps; ++sym2__) {
            current_statement__ = 316;
            stan::model::assign(splitComps, splitComps_flat__[(pos__ - 1)],
              "assigning variable splitComps",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            current_statement__ = 316;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 316;
      stan::math::check_greater_or_equal(function__, "splitComps",
        splitComps, 0);
      current_statement__ = 316;
      stan::math::check_less_or_equal(function__, "splitComps", splitComps, 1);
      current_statement__ = 317;
      stan::math::validate_non_negative_index("piMapping", "nComps", nComps);
      current_statement__ = 318;
      stan::math::validate_non_negative_index("piMapping", "nGroups", nGroups);
      current_statement__ = 319;
      context__.validate_dims("data initialization", "piMapping", "int",
        std::vector<size_t>{static_cast<size_t>(nComps),
          static_cast<size_t>(nGroups)});
      piMapping = std::vector<std::vector<int>>(nComps,
                    std::vector<int>(nGroups,
                      std::numeric_limits<int>::min()));
      {
        std::vector<int> piMapping_flat__;
        current_statement__ = 319;
        piMapping_flat__ = context__.vals_i("piMapping");
        current_statement__ = 319;
        pos__ = 1;
        current_statement__ = 319;
        for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
          current_statement__ = 319;
          for (int sym2__ = 1; sym2__ <= nComps; ++sym2__) {
            current_statement__ = 319;
            stan::model::assign(piMapping, piMapping_flat__[(pos__ - 1)],
              "assigning variable piMapping", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            current_statement__ = 319;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 319;
      stan::math::check_greater_or_equal(function__, "piMapping", piMapping,
        0);
      current_statement__ = 320;
      context__.validate_dims("data initialization", "lambda_decay",
        "double", std::vector<size_t>{});
      lambda_decay = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 320;
      lambda_decay = context__.vals_r("lambda_decay")[(1 - 1)];
      current_statement__ = 320;
      stan::math::check_greater_or_equal(function__, "lambda_decay",
        lambda_decay, 0);
      current_statement__ = 321;
      context__.validate_dims("data initialization", "maxNupsilons", "int",
        std::vector<size_t>{});
      maxNupsilons = std::numeric_limits<int>::min();
      current_statement__ = 321;
      maxNupsilons = context__.vals_i("maxNupsilons")[(1 - 1)];
      current_statement__ = 321;
      stan::math::check_greater_or_equal(function__, "maxNupsilons",
        maxNupsilons, 0);
      current_statement__ = 322;
      stan::math::validate_non_negative_index("nUpsilons", "nGroups + 1",
        (nGroups + 1));
      current_statement__ = 323;
      context__.validate_dims("data initialization", "nUpsilons", "int",
        std::vector<size_t>{static_cast<size_t>((nGroups + 1))});
      nUpsilons = std::vector<int>((nGroups + 1),
                    std::numeric_limits<int>::min());
      current_statement__ = 323;
      nUpsilons = context__.vals_i("nUpsilons");
      current_statement__ = 323;
      stan::math::check_greater_or_equal(function__, "nUpsilons", nUpsilons,
        0);
      current_statement__ = 324;
      stan::math::validate_non_negative_index("upsilonMapping",
        "maxNupsilons", maxNupsilons);
      current_statement__ = 325;
      stan::math::validate_non_negative_index("upsilonMapping", "nGroups",
        nGroups);
      current_statement__ = 326;
      context__.validate_dims("data initialization", "upsilonMapping", "int",
        std::vector<size_t>{static_cast<size_t>(maxNupsilons),
          static_cast<size_t>(3), static_cast<size_t>(nGroups)});
      upsilonMapping = std::vector<std::vector<std::vector<int>>>(maxNupsilons,
                         std::vector<std::vector<int>>(3,
                           std::vector<int>(nGroups,
                             std::numeric_limits<int>::min())));
      {
        std::vector<int> upsilonMapping_flat__;
        current_statement__ = 326;
        upsilonMapping_flat__ = context__.vals_i("upsilonMapping");
        current_statement__ = 326;
        pos__ = 1;
        current_statement__ = 326;
        for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
          current_statement__ = 326;
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            current_statement__ = 326;
            for (int sym3__ = 1; sym3__ <= maxNupsilons; ++sym3__) {
              current_statement__ = 326;
              stan::model::assign(upsilonMapping,
                upsilonMapping_flat__[(pos__ - 1)],
                "assigning variable upsilonMapping",
                stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              current_statement__ = 326;
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      current_statement__ = 326;
      stan::math::check_greater_or_equal(function__, "upsilonMapping",
        upsilonMapping, 0);
      current_statement__ = 327;
      context__.validate_dims("data initialization", "maxNlambdas", "int",
        std::vector<size_t>{});
      maxNlambdas = std::numeric_limits<int>::min();
      current_statement__ = 327;
      maxNlambdas = context__.vals_i("maxNlambdas")[(1 - 1)];
      current_statement__ = 327;
      stan::math::check_greater_or_equal(function__, "maxNlambdas",
        maxNlambdas, 0);
      current_statement__ = 328;
      stan::math::validate_non_negative_index("nLambdas", "nGroups + 1",
        (nGroups + 1));
      current_statement__ = 329;
      context__.validate_dims("data initialization", "nLambdas", "int",
        std::vector<size_t>{static_cast<size_t>((nGroups + 1))});
      nLambdas = std::vector<int>((nGroups + 1),
                   std::numeric_limits<int>::min());
      current_statement__ = 329;
      nLambdas = context__.vals_i("nLambdas");
      current_statement__ = 329;
      stan::math::check_greater_or_equal(function__, "nLambdas", nLambdas, 0);
      current_statement__ = 330;
      stan::math::validate_non_negative_index("lambdaMapping", "maxNlambdas",
        maxNlambdas);
      current_statement__ = 331;
      stan::math::validate_non_negative_index("lambdaMapping", "nGroups",
        nGroups);
      current_statement__ = 332;
      context__.validate_dims("data initialization", "lambdaMapping", "int",
        std::vector<size_t>{static_cast<size_t>(maxNlambdas),
          static_cast<size_t>(2), static_cast<size_t>(nGroups)});
      lambdaMapping = std::vector<std::vector<std::vector<int>>>(maxNlambdas,
                        std::vector<std::vector<int>>(2,
                          std::vector<int>(nGroups,
                            std::numeric_limits<int>::min())));
      {
        std::vector<int> lambdaMapping_flat__;
        current_statement__ = 332;
        lambdaMapping_flat__ = context__.vals_i("lambdaMapping");
        current_statement__ = 332;
        pos__ = 1;
        current_statement__ = 332;
        for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
          current_statement__ = 332;
          for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
            current_statement__ = 332;
            for (int sym3__ = 1; sym3__ <= maxNlambdas; ++sym3__) {
              current_statement__ = 332;
              stan::model::assign(lambdaMapping, lambdaMapping_flat__[(pos__
                - 1)], "assigning variable lambdaMapping",
                stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              current_statement__ = 332;
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      current_statement__ = 332;
      stan::math::check_greater_or_equal(function__, "lambdaMapping",
        lambdaMapping, 0);
      current_statement__ = 333;
      context__.validate_dims("data initialization", "maxNpulseEvents",
        "int", std::vector<size_t>{});
      maxNpulseEvents = std::numeric_limits<int>::min();
      current_statement__ = 333;
      maxNpulseEvents = context__.vals_i("maxNpulseEvents")[(1 - 1)];
      current_statement__ = 333;
      stan::math::check_greater_or_equal(function__, "maxNpulseEvents",
        maxNpulseEvents, 0);
      current_statement__ = 334;
      stan::math::validate_non_negative_index("nPulseEvents", "nGroups + 1",
        (nGroups + 1));
      current_statement__ = 335;
      context__.validate_dims("data initialization", "nPulseEvents", "int",
        std::vector<size_t>{static_cast<size_t>((nGroups + 1))});
      nPulseEvents = std::vector<int>((nGroups + 1),
                       std::numeric_limits<int>::min());
      current_statement__ = 335;
      nPulseEvents = context__.vals_i("nPulseEvents");
      current_statement__ = 335;
      stan::math::check_greater_or_equal(function__, "nPulseEvents",
        nPulseEvents, 0);
      current_statement__ = 336;
      stan::math::validate_non_negative_index("pulseEventsIndices",
        "maxNpulseEvents", maxNpulseEvents);
      current_statement__ = 337;
      stan::math::validate_non_negative_index("pulseEventsIndices",
        "nGroups", nGroups);
      current_statement__ = 338;
      context__.validate_dims("data initialization", "pulseEventsIndices",
        "int",
        std::vector<size_t>{static_cast<size_t>(maxNpulseEvents),
          static_cast<size_t>(2), static_cast<size_t>(nGroups)});
      pulseEventsIndices = std::vector<std::vector<std::vector<int>>>(maxNpulseEvents,
                             std::vector<std::vector<int>>(2,
                               std::vector<int>(nGroups,
                                 std::numeric_limits<int>::min())));
      {
        std::vector<int> pulseEventsIndices_flat__;
        current_statement__ = 338;
        pulseEventsIndices_flat__ = context__.vals_i("pulseEventsIndices");
        current_statement__ = 338;
        pos__ = 1;
        current_statement__ = 338;
        for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
          current_statement__ = 338;
          for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
            current_statement__ = 338;
            for (int sym3__ = 1; sym3__ <= maxNpulseEvents; ++sym3__) {
              current_statement__ = 338;
              stan::model::assign(pulseEventsIndices,
                pulseEventsIndices_flat__[(pos__ - 1)],
                "assigning variable pulseEventsIndices",
                stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              current_statement__ = 338;
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      current_statement__ = 338;
      stan::math::check_greater_or_equal(function__, "pulseEventsIndices",
        pulseEventsIndices, 0);
      current_statement__ = 339;
      stan::math::validate_non_negative_index("pulseEventsQuantities",
        "maxNpulseEvents", maxNpulseEvents);
      current_statement__ = 340;
      stan::math::validate_non_negative_index("pulseEventsQuantities",
        "nGroups", nGroups);
      current_statement__ = 341;
      context__.validate_dims("data initialization", "pulseEventsQuantities",
        "double",
        std::vector<size_t>{static_cast<size_t>(maxNpulseEvents),
          static_cast<size_t>(2), static_cast<size_t>(nGroups)});
      pulseEventsQuantities = std::vector<std::vector<std::vector<double>>>(maxNpulseEvents,
                                std::vector<std::vector<double>>(2,
                                  std::vector<double>(nGroups,
                                    std::numeric_limits<double>::quiet_NaN())));
      {
        std::vector<local_scalar_t__> pulseEventsQuantities_flat__;
        current_statement__ = 341;
        pulseEventsQuantities_flat__ = context__.vals_r("pulseEventsQuantities");
        current_statement__ = 341;
        pos__ = 1;
        current_statement__ = 341;
        for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
          current_statement__ = 341;
          for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
            current_statement__ = 341;
            for (int sym3__ = 1; sym3__ <= maxNpulseEvents; ++sym3__) {
              current_statement__ = 341;
              stan::model::assign(pulseEventsQuantities,
                pulseEventsQuantities_flat__[(pos__ - 1)],
                "assigning variable pulseEventsQuantities",
                stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              current_statement__ = 341;
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      current_statement__ = 342;
      context__.validate_dims("data initialization", "maxNsizesObs", "int",
        std::vector<size_t>{});
      maxNsizesObs = std::numeric_limits<int>::min();
      current_statement__ = 342;
      maxNsizesObs = context__.vals_i("maxNsizesObs")[(1 - 1)];
      current_statement__ = 342;
      stan::math::check_greater_or_equal(function__, "maxNsizesObs",
        maxNsizesObs, 0);
      current_statement__ = 343;
      context__.validate_dims("data initialization", "maxNpropsObs", "int",
        std::vector<size_t>{});
      maxNpropsObs = std::numeric_limits<int>::min();
      current_statement__ = 343;
      maxNpropsObs = context__.vals_i("maxNpropsObs")[(1 - 1)];
      current_statement__ = 343;
      stan::math::check_greater_or_equal(function__, "maxNpropsObs",
        maxNpropsObs, 0);
      current_statement__ = 344;
      stan::math::validate_non_negative_index("nSizesObs", "nGroups + 1",
        (nGroups + 1));
      current_statement__ = 345;
      context__.validate_dims("data initialization", "nSizesObs", "int",
        std::vector<size_t>{static_cast<size_t>((nGroups + 1))});
      nSizesObs = std::vector<int>((nGroups + 1),
                    std::numeric_limits<int>::min());
      current_statement__ = 345;
      nSizesObs = context__.vals_i("nSizesObs");
      current_statement__ = 345;
      stan::math::check_greater_or_equal(function__, "nSizesObs", nSizesObs,
        0);
      current_statement__ = 346;
      stan::math::validate_non_negative_index("nPropsObs", "nGroups + 1",
        (nGroups + 1));
      current_statement__ = 347;
      context__.validate_dims("data initialization", "nPropsObs", "int",
        std::vector<size_t>{static_cast<size_t>((nGroups + 1))});
      nPropsObs = std::vector<int>((nGroups + 1),
                    std::numeric_limits<int>::min());
      current_statement__ = 347;
      nPropsObs = context__.vals_i("nPropsObs");
      current_statement__ = 347;
      stan::math::check_greater_or_equal(function__, "nPropsObs", nPropsObs,
        0);
      current_statement__ = 348;
      stan::math::validate_non_negative_index("sizesObsIndices",
        "maxNsizesObs", maxNsizesObs);
      current_statement__ = 349;
      stan::math::validate_non_negative_index("sizesObsIndices", "nGroups",
        nGroups);
      current_statement__ = 350;
      context__.validate_dims("data initialization", "sizesObsIndices",
        "int",
        std::vector<size_t>{static_cast<size_t>(maxNsizesObs),
          static_cast<size_t>(3), static_cast<size_t>(nGroups)});
      sizesObsIndices = std::vector<std::vector<std::vector<int>>>(maxNsizesObs,
                          std::vector<std::vector<int>>(3,
                            std::vector<int>(nGroups,
                              std::numeric_limits<int>::min())));
      {
        std::vector<int> sizesObsIndices_flat__;
        current_statement__ = 350;
        sizesObsIndices_flat__ = context__.vals_i("sizesObsIndices");
        current_statement__ = 350;
        pos__ = 1;
        current_statement__ = 350;
        for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
          current_statement__ = 350;
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            current_statement__ = 350;
            for (int sym3__ = 1; sym3__ <= maxNsizesObs; ++sym3__) {
              current_statement__ = 350;
              stan::model::assign(sizesObsIndices,
                sizesObsIndices_flat__[(pos__ - 1)],
                "assigning variable sizesObsIndices",
                stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              current_statement__ = 350;
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      current_statement__ = 350;
      stan::math::check_greater_or_equal(function__, "sizesObsIndices",
        sizesObsIndices, 0);
      current_statement__ = 351;
      stan::math::validate_non_negative_index("propsObsIndices",
        "maxNpropsObs", maxNpropsObs);
      current_statement__ = 352;
      stan::math::validate_non_negative_index("propsObsIndices", "nGroups",
        nGroups);
      current_statement__ = 353;
      context__.validate_dims("data initialization", "propsObsIndices",
        "int",
        std::vector<size_t>{static_cast<size_t>(maxNpropsObs),
          static_cast<size_t>(3), static_cast<size_t>(nGroups)});
      propsObsIndices = std::vector<std::vector<std::vector<int>>>(maxNpropsObs,
                          std::vector<std::vector<int>>(3,
                            std::vector<int>(nGroups,
                              std::numeric_limits<int>::min())));
      {
        std::vector<int> propsObsIndices_flat__;
        current_statement__ = 353;
        propsObsIndices_flat__ = context__.vals_i("propsObsIndices");
        current_statement__ = 353;
        pos__ = 1;
        current_statement__ = 353;
        for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
          current_statement__ = 353;
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            current_statement__ = 353;
            for (int sym3__ = 1; sym3__ <= maxNpropsObs; ++sym3__) {
              current_statement__ = 353;
              stan::model::assign(propsObsIndices,
                propsObsIndices_flat__[(pos__ - 1)],
                "assigning variable propsObsIndices",
                stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              current_statement__ = 353;
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      current_statement__ = 353;
      stan::math::check_greater_or_equal(function__, "propsObsIndices",
        propsObsIndices, 0);
      current_statement__ = 354;
      stan::math::validate_non_negative_index("sizesObs", "maxNsizesObs",
        maxNsizesObs);
      current_statement__ = 355;
      stan::math::validate_non_negative_index("sizesObs", "nGroups", nGroups);
      current_statement__ = 356;
      context__.validate_dims("data initialization", "sizesObs", "double",
        std::vector<size_t>{static_cast<size_t>(maxNsizesObs),
          static_cast<size_t>(nGroups)});
      sizesObs = std::vector<std::vector<double>>(maxNsizesObs,
                   std::vector<double>(nGroups,
                     std::numeric_limits<double>::quiet_NaN()));
      {
        std::vector<local_scalar_t__> sizesObs_flat__;
        current_statement__ = 356;
        sizesObs_flat__ = context__.vals_r("sizesObs");
        current_statement__ = 356;
        pos__ = 1;
        current_statement__ = 356;
        for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
          current_statement__ = 356;
          for (int sym2__ = 1; sym2__ <= maxNsizesObs; ++sym2__) {
            current_statement__ = 356;
            stan::model::assign(sizesObs, sizesObs_flat__[(pos__ - 1)],
              "assigning variable sizesObs", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            current_statement__ = 356;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 356;
      stan::math::check_greater_or_equal(function__, "sizesObs", sizesObs, 0);
      current_statement__ = 357;
      stan::math::validate_non_negative_index("propsObs", "maxNpropsObs",
        maxNpropsObs);
      current_statement__ = 358;
      stan::math::validate_non_negative_index("propsObs", "nGroups", nGroups);
      current_statement__ = 359;
      context__.validate_dims("data initialization", "propsObs", "double",
        std::vector<size_t>{static_cast<size_t>(maxNpropsObs),
          static_cast<size_t>(nGroups)});
      propsObs = std::vector<std::vector<double>>(maxNpropsObs,
                   std::vector<double>(nGroups,
                     std::numeric_limits<double>::quiet_NaN()));
      {
        std::vector<local_scalar_t__> propsObs_flat__;
        current_statement__ = 359;
        propsObs_flat__ = context__.vals_r("propsObs");
        current_statement__ = 359;
        pos__ = 1;
        current_statement__ = 359;
        for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
          current_statement__ = 359;
          for (int sym2__ = 1; sym2__ <= maxNpropsObs; ++sym2__) {
            current_statement__ = 359;
            stan::model::assign(propsObs, propsObs_flat__[(pos__ - 1)],
              "assigning variable propsObs", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            current_statement__ = 359;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 359;
      stan::math::check_greater_or_equal(function__, "propsObs", propsObs, 0);
      current_statement__ = 360;
      context__.validate_dims("data initialization", "maxNtimeIntervals",
        "int", std::vector<size_t>{});
      maxNtimeIntervals = std::numeric_limits<int>::min();
      current_statement__ = 360;
      maxNtimeIntervals = context__.vals_i("maxNtimeIntervals")[(1 - 1)];
      current_statement__ = 360;
      stan::math::check_greater_or_equal(function__, "maxNtimeIntervals",
        maxNtimeIntervals, 0);
      current_statement__ = 361;
      stan::math::validate_non_negative_index("nTimeIntervals",
        "nGroups + 1", (nGroups + 1));
      current_statement__ = 362;
      context__.validate_dims("data initialization", "nTimeIntervals", "int",
        std::vector<size_t>{static_cast<size_t>((nGroups + 1))});
      nTimeIntervals = std::vector<int>((nGroups + 1),
                         std::numeric_limits<int>::min());
      current_statement__ = 362;
      nTimeIntervals = context__.vals_i("nTimeIntervals");
      current_statement__ = 362;
      stan::math::check_greater_or_equal(function__, "nTimeIntervals",
        nTimeIntervals, 0);
      current_statement__ = 363;
      stan::math::validate_non_negative_index("intervalsLengths",
        "maxNtimeIntervals", maxNtimeIntervals);
      current_statement__ = 364;
      stan::math::validate_non_negative_index("intervalsLengths", "nGroups",
        nGroups);
      current_statement__ = 365;
      context__.validate_dims("data initialization", "intervalsLengths",
        "double",
        std::vector<size_t>{static_cast<size_t>(maxNtimeIntervals),
          static_cast<size_t>(nGroups)});
      intervalsLengths = std::vector<std::vector<double>>(maxNtimeIntervals,
                           std::vector<double>(nGroups,
                             std::numeric_limits<double>::quiet_NaN()));
      {
        std::vector<local_scalar_t__> intervalsLengths_flat__;
        current_statement__ = 365;
        intervalsLengths_flat__ = context__.vals_r("intervalsLengths");
        current_statement__ = 365;
        pos__ = 1;
        current_statement__ = 365;
        for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
          current_statement__ = 365;
          for (int sym2__ = 1; sym2__ <= maxNtimeIntervals; ++sym2__) {
            current_statement__ = 365;
            stan::model::assign(intervalsLengths,
              intervalsLengths_flat__[(pos__ - 1)],
              "assigning variable intervalsLengths",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            current_statement__ = 365;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 365;
      stan::math::check_greater_or_equal(function__, "intervalsLengths",
        intervalsLengths, 0);
      current_statement__ = 366;
      context__.validate_dims("data initialization", "maxNobsTimes", "int",
        std::vector<size_t>{});
      maxNobsTimes = std::numeric_limits<int>::min();
      current_statement__ = 366;
      maxNobsTimes = context__.vals_i("maxNobsTimes")[(1 - 1)];
      current_statement__ = 366;
      stan::math::check_greater_or_equal(function__, "maxNobsTimes",
        maxNobsTimes, 0);
      current_statement__ = 367;
      stan::math::validate_non_negative_index("nObsTimes", "nGroups + 1",
        (nGroups + 1));
      current_statement__ = 368;
      context__.validate_dims("data initialization", "nObsTimes", "int",
        std::vector<size_t>{static_cast<size_t>((nGroups + 1))});
      nObsTimes = std::vector<int>((nGroups + 1),
                    std::numeric_limits<int>::min());
      current_statement__ = 368;
      nObsTimes = context__.vals_i("nObsTimes");
      current_statement__ = 368;
      stan::math::check_greater_or_equal(function__, "nObsTimes", nObsTimes,
        0);
      current_statement__ = 369;
      stan::math::validate_non_negative_index("elapsedTimeSinceEvent",
        "nGroups", nGroups);
      current_statement__ = 370;
      stan::math::validate_non_negative_index("elapsedTimeSinceEvent",
        "maxNobsTimes", maxNobsTimes);
      current_statement__ = 371;
      context__.validate_dims("data initialization", "elapsedTimeSinceEvent",
        "double",
        std::vector<size_t>{static_cast<size_t>(nGroups),
          static_cast<size_t>(maxNobsTimes)});
      elapsedTimeSinceEvent = std::vector<std::vector<double>>(nGroups,
                                std::vector<double>(maxNobsTimes,
                                  std::numeric_limits<double>::quiet_NaN()));
      {
        std::vector<local_scalar_t__> elapsedTimeSinceEvent_flat__;
        current_statement__ = 371;
        elapsedTimeSinceEvent_flat__ = context__.vals_r("elapsedTimeSinceEvent");
        current_statement__ = 371;
        pos__ = 1;
        current_statement__ = 371;
        for (int sym1__ = 1; sym1__ <= maxNobsTimes; ++sym1__) {
          current_statement__ = 371;
          for (int sym2__ = 1; sym2__ <= nGroups; ++sym2__) {
            current_statement__ = 371;
            stan::model::assign(elapsedTimeSinceEvent,
              elapsedTimeSinceEvent_flat__[(pos__ - 1)],
              "assigning variable elapsedTimeSinceEvent",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            current_statement__ = 371;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 371;
      stan::math::check_greater_or_equal(function__, "elapsedTimeSinceEvent",
        elapsedTimeSinceEvent, 0);
      current_statement__ = 372;
      stan::math::validate_non_negative_index("obsIntervalsIndices",
        "nGroups", nGroups);
      current_statement__ = 373;
      stan::math::validate_non_negative_index("obsIntervalsIndices",
        "maxNobsTimes", maxNobsTimes);
      current_statement__ = 374;
      context__.validate_dims("data initialization", "obsIntervalsIndices",
        "int",
        std::vector<size_t>{static_cast<size_t>(nGroups),
          static_cast<size_t>(maxNobsTimes)});
      obsIntervalsIndices = std::vector<std::vector<int>>(nGroups,
                              std::vector<int>(maxNobsTimes,
                                std::numeric_limits<int>::min()));
      {
        std::vector<int> obsIntervalsIndices_flat__;
        current_statement__ = 374;
        obsIntervalsIndices_flat__ = context__.vals_i("obsIntervalsIndices");
        current_statement__ = 374;
        pos__ = 1;
        current_statement__ = 374;
        for (int sym1__ = 1; sym1__ <= maxNobsTimes; ++sym1__) {
          current_statement__ = 374;
          for (int sym2__ = 1; sym2__ <= nGroups; ++sym2__) {
            current_statement__ = 374;
            stan::model::assign(obsIntervalsIndices,
              obsIntervalsIndices_flat__[(pos__ - 1)],
              "assigning variable obsIntervalsIndices",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            current_statement__ = 374;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 374;
      stan::math::check_greater_or_equal(function__, "obsIntervalsIndices",
        obsIntervalsIndices, 0);
      current_statement__ = 375;
      context__.validate_dims("data initialization", "maxNtimesteps", "int",
        std::vector<size_t>{});
      maxNtimesteps = std::numeric_limits<int>::min();
      current_statement__ = 375;
      maxNtimesteps = context__.vals_i("maxNtimesteps")[(1 - 1)];
      current_statement__ = 375;
      stan::math::check_greater_or_equal(function__, "maxNtimesteps",
        maxNtimesteps, 2);
      current_statement__ = 376;
      stan::math::validate_non_negative_index("nTimesteps", "nGroups + 1",
        (nGroups + 1));
      current_statement__ = 377;
      context__.validate_dims("data initialization", "nTimesteps", "int",
        std::vector<size_t>{static_cast<size_t>((nGroups + 1))});
      nTimesteps = std::vector<int>((nGroups + 1),
                     std::numeric_limits<int>::min());
      current_statement__ = 377;
      nTimesteps = context__.vals_i("nTimesteps");
      current_statement__ = 377;
      stan::math::check_greater_or_equal(function__, "nTimesteps",
        nTimesteps, 0);
      current_statement__ = 378;
      context__.validate_dims("data initialization", "maxNuniqueDts", "int",
        std::vector<size_t>{});
      maxNuniqueDts = std::numeric_limits<int>::min();
      current_statement__ = 378;
      maxNuniqueDts = context__.vals_i("maxNuniqueDts")[(1 - 1)];
      current_statement__ = 378;
      stan::math::check_greater_or_equal(function__, "maxNuniqueDts",
        maxNuniqueDts, 1);
      current_statement__ = 379;
      stan::math::validate_non_negative_index("nUniqueDts", "nGroups + 1",
        (nGroups + 1));
      current_statement__ = 380;
      context__.validate_dims("data initialization", "nUniqueDts", "int",
        std::vector<size_t>{static_cast<size_t>((nGroups + 1))});
      nUniqueDts = std::vector<int>((nGroups + 1),
                     std::numeric_limits<int>::min());
      current_statement__ = 380;
      nUniqueDts = context__.vals_i("nUniqueDts");
      current_statement__ = 380;
      stan::math::check_greater_or_equal(function__, "nUniqueDts",
        nUniqueDts, 0);
      current_statement__ = 381;
      stan::math::validate_non_negative_index("unique_dts", "maxNuniqueDts",
        maxNuniqueDts);
      current_statement__ = 382;
      stan::math::validate_non_negative_index("unique_dts", "nGroups",
        nGroups);
      current_statement__ = 383;
      context__.validate_dims("data initialization", "unique_dts", "double",
        std::vector<size_t>{static_cast<size_t>(maxNuniqueDts),
          static_cast<size_t>(nGroups)});
      unique_dts = std::vector<std::vector<double>>(maxNuniqueDts,
                     std::vector<double>(nGroups,
                       std::numeric_limits<double>::quiet_NaN()));
      {
        std::vector<local_scalar_t__> unique_dts_flat__;
        current_statement__ = 383;
        unique_dts_flat__ = context__.vals_r("unique_dts");
        current_statement__ = 383;
        pos__ = 1;
        current_statement__ = 383;
        for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
          current_statement__ = 383;
          for (int sym2__ = 1; sym2__ <= maxNuniqueDts; ++sym2__) {
            current_statement__ = 383;
            stan::model::assign(unique_dts, unique_dts_flat__[(pos__ - 1)],
              "assigning variable unique_dts",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            current_statement__ = 383;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 383;
      stan::math::check_greater_or_equal(function__, "unique_dts",
        unique_dts, 0);
      current_statement__ = 384;
      stan::math::validate_non_negative_index("timesteps", "maxNtimesteps",
        maxNtimesteps);
      current_statement__ = 385;
      stan::math::validate_non_negative_index("timesteps", "nGroups", nGroups);
      current_statement__ = 386;
      context__.validate_dims("data initialization", "timesteps", "int",
        std::vector<size_t>{static_cast<size_t>(maxNtimesteps),
          static_cast<size_t>(nGroups)});
      timesteps = std::vector<std::vector<int>>(maxNtimesteps,
                    std::vector<int>(nGroups,
                      std::numeric_limits<int>::min()));
      {
        std::vector<int> timesteps_flat__;
        current_statement__ = 386;
        timesteps_flat__ = context__.vals_i("timesteps");
        current_statement__ = 386;
        pos__ = 1;
        current_statement__ = 386;
        for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
          current_statement__ = 386;
          for (int sym2__ = 1; sym2__ <= maxNtimesteps; ++sym2__) {
            current_statement__ = 386;
            stan::model::assign(timesteps, timesteps_flat__[(pos__ - 1)],
              "assigning variable timesteps", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            current_statement__ = 386;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 386;
      stan::math::check_greater_or_equal(function__, "timesteps", timesteps,
        0);
      current_statement__ = 387;
      nTotal = std::numeric_limits<int>::min();
      current_statement__ = 388;
      n_quantity_records = std::numeric_limits<int>::min();
      current_statement__ = 389;
      nTotal = 0;
      current_statement__ = 392;
      for (int g = 1; g <= nGroups; ++g) {
        current_statement__ = 390;
        nTotal = (nTotal +
          (stan::model::rvalue(nSizesObs, "nSizesObs",
             stan::model::index_uni(g))
          +
          stan::model::rvalue(nPropsObs, "nPropsObs",
            stan::model::index_uni(g))));
      }
      current_statement__ = 395;
      if (stan::math::logical_eq(ode_method, 1)) {
        current_statement__ = 393;
        n_quantity_records = (maxNobsTimes + 1);
      }
      current_statement__ = 398;
      if (stan::math::logical_eq(ode_method, 2)) {
        current_statement__ = 396;
        n_quantity_records = (maxNtimesteps + 1);
      }
      current_statement__ = 387;
      stan::math::check_greater_or_equal(function__, "nTotal", nTotal, 0);
      current_statement__ = 388;
      stan::math::check_greater_or_equal(function__, "n_quantity_records",
        n_quantity_records, 0);
      current_statement__ = 399;
      stan::math::validate_non_negative_index("rawUniformParams",
        "nPriorUniform_code1", nPriorUniform_code1);
      current_statement__ = 400;
      stan::math::validate_non_negative_index("rawHcauchyParams",
        "nPriorHcauchy_code2", nPriorHcauchy_code2);
      current_statement__ = 401;
      stan::math::validate_non_negative_index("rawBetaParams",
        "nPriorBeta_code3", nPriorBeta_code3);
      current_statement__ = 402;
      stan::math::validate_non_negative_index("rawTrNormParams",
        "nPriorTrNormal_code4", nPriorTrNormal_code4);
      current_statement__ = 403;
      stan::math::validate_non_negative_index("rawExponentialParams",
        "nPriorExponential_code5", nPriorExponential_code5);
      current_statement__ = 404;
      stan::math::validate_non_negative_index("rawGammaParams",
        "nPriorGamma_code6", nPriorGamma_code6);
      current_statement__ = 405;
      stan::math::validate_non_negative_index("params", "nParams", nParams);
      current_statement__ = 406;
      stan::math::validate_non_negative_index("initRefr", "nComps", nComps);
      current_statement__ = 407;
      stan::math::validate_non_negative_index("initRefr", "nGroups", nGroups);
      current_statement__ = 408;
      stan::math::validate_non_negative_index("unmarked", "nGroups", nGroups);
      current_statement__ = 409;
      stan::math::validate_non_negative_index("unmarked",
        "n_quantity_records", n_quantity_records);
      current_statement__ = 410;
      stan::math::validate_non_negative_index("unmarked", "nComps", nComps);
      current_statement__ = 411;
      stan::math::validate_non_negative_index("marked", "nGroups", nGroups);
      current_statement__ = 412;
      stan::math::validate_non_negative_index("marked", "n_quantity_records",
        n_quantity_records);
      current_statement__ = 413;
      stan::math::validate_non_negative_index("marked", "nComps", nComps);
      current_statement__ = 414;
      stan::math::validate_non_negative_index("sizesPred", "maxNsizesObs",
        maxNsizesObs);
      current_statement__ = 415;
      stan::math::validate_non_negative_index("sizesPred", "nGroups", nGroups);
      current_statement__ = 416;
      stan::math::validate_non_negative_index("propsPred", "maxNpropsObs",
        maxNpropsObs);
      current_statement__ = 417;
      stan::math::validate_non_negative_index("propsPred", "nGroups", nGroups);
      current_statement__ = 418;
      stan::math::validate_non_negative_index("sizesPred_zeta",
        "maxNsizesObs", maxNsizesObs);
      current_statement__ = 419;
      stan::math::validate_non_negative_index("sizesPred_zeta", "nGroups",
        nGroups);
      current_statement__ = 420;
      stan::math::validate_non_negative_index("sizesPred_alpha",
        "maxNsizesObs", maxNsizesObs);
      current_statement__ = 421;
      stan::math::validate_non_negative_index("sizesPred_alpha", "nGroups",
        nGroups);
      current_statement__ = 422;
      stan::math::validate_non_negative_index("sizesPred_beta",
        "maxNsizesObs", maxNsizesObs);
      current_statement__ = 423;
      stan::math::validate_non_negative_index("sizesPred_beta", "nGroups",
        nGroups);
      current_statement__ = 424;
      stan::math::validate_non_negative_index("propsPred_eta",
        "maxNpropsObs", maxNpropsObs);
      current_statement__ = 425;
      stan::math::validate_non_negative_index("propsPred_eta", "nGroups",
        nGroups);
      current_statement__ = 426;
      stan::math::validate_non_negative_index("propsPred_alpha",
        "maxNpropsObs", maxNpropsObs);
      current_statement__ = 427;
      stan::math::validate_non_negative_index("propsPred_alpha", "nGroups",
        nGroups);
      current_statement__ = 428;
      stan::math::validate_non_negative_index("propsPred_beta",
        "maxNpropsObs", maxNpropsObs);
      current_statement__ = 429;
      stan::math::validate_non_negative_index("propsPred_beta", "nGroups",
        nGroups);
      current_statement__ = 430;
      stan::math::validate_non_negative_index("transitions", "maxNuniqueDts",
        maxNuniqueDts);
      current_statement__ = 431;
      stan::math::validate_non_negative_index("transitions", "nComps", nComps);
      current_statement__ = 432;
      stan::math::validate_non_negative_index("transitions", "nComps", nComps);
      current_statement__ = 433;
      stan::math::validate_non_negative_index("transitionsDecay",
        "maxNuniqueDts", maxNuniqueDts);
      current_statement__ = 434;
      stan::math::validate_non_negative_index("transitionsDecay", "nComps",
        nComps);
      current_statement__ = 435;
      stan::math::validate_non_negative_index("transitionsDecay", "nComps",
        nComps);
      current_statement__ = 436;
      stan::math::validate_non_negative_index("transfer", "nComps", nComps);
      current_statement__ = 437;
      stan::math::validate_non_negative_index("transfer", "nComps", nComps);
      current_statement__ = 438;
      stan::math::validate_non_negative_index("transferDecay", "nComps",
        nComps);
      current_statement__ = 439;
      stan::math::validate_non_negative_index("transferDecay", "nComps",
        nComps);
      current_statement__ = 440;
      stan::math::validate_non_negative_index("transition_tmp", "nComps",
        nComps);
      current_statement__ = 441;
      stan::math::validate_non_negative_index("transition_tmp", "nComps",
        nComps);
      current_statement__ = 442;
      stan::math::validate_non_negative_index("transitionDecay_tmp",
        "nComps", nComps);
      current_statement__ = 443;
      stan::math::validate_non_negative_index("transitionDecay_tmp",
        "nComps", nComps);
      current_statement__ = 444;
      stan::math::validate_non_negative_index("intervals_init_states_marked",
        "maxNtimeIntervals", maxNtimeIntervals);
      current_statement__ = 445;
      stan::math::validate_non_negative_index("intervals_init_states_marked",
        "nComps", nComps);
      current_statement__ = 446;
      stan::math::validate_non_negative_index(
        "intervals_init_states_unmarked", "maxNtimeIntervals",
        maxNtimeIntervals);
      current_statement__ = 447;
      stan::math::validate_non_negative_index(
        "intervals_init_states_unmarked", "nComps", nComps);
      current_statement__ = 448;
      stan::math::validate_non_negative_index("nonConstantParams",
        "nNonConstantPriors", nNonConstantPriors);
      current_statement__ = 449;
      stan::math::validate_non_negative_index("log_lik", "nTotal", nTotal);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = nPriorUniform_code1 + nPriorHcauchy_code2 +
      nPriorBeta_code3 + nPriorTrNormal_code4 + nPriorExponential_code5 +
      nPriorGamma_code6;
  }
  inline std::string model_name() const final {
    return "model_networkModel";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = stanc3 v2.32.2",
             "stancflags = --allow-undefined"};
  }
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "model_networkModel_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<local_scalar_t__,-1,1> rawUniformParams =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(nPriorUniform_code1,
          DUMMY_VAR__);
      current_statement__ = 1;
      rawUniformParams = in__.template read_constrain_lub<
                           Eigen::Matrix<local_scalar_t__,-1,1>,
                           jacobian__>(0, 1, lp__, nPriorUniform_code1);
      Eigen::Matrix<local_scalar_t__,-1,1> rawHcauchyParams =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(nPriorHcauchy_code2,
          DUMMY_VAR__);
      current_statement__ = 2;
      rawHcauchyParams = in__.template read_constrain_lb<
                           Eigen::Matrix<local_scalar_t__,-1,1>,
                           jacobian__>(0, lp__, nPriorHcauchy_code2);
      Eigen::Matrix<local_scalar_t__,-1,1> rawBetaParams =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(nPriorBeta_code3,
          DUMMY_VAR__);
      current_statement__ = 3;
      rawBetaParams = in__.template read_constrain_lub<
                        Eigen::Matrix<local_scalar_t__,-1,1>, jacobian__>(0,
                        1, lp__, nPriorBeta_code3);
      Eigen::Matrix<local_scalar_t__,-1,1> rawTrNormParams =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(nPriorTrNormal_code4,
          DUMMY_VAR__);
      current_statement__ = 4;
      rawTrNormParams = in__.template read_constrain_lb<
                          Eigen::Matrix<local_scalar_t__,-1,1>,
                          jacobian__>(0, lp__, nPriorTrNormal_code4);
      Eigen::Matrix<local_scalar_t__,-1,1> rawExponentialParams =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(nPriorExponential_code5,
          DUMMY_VAR__);
      current_statement__ = 5;
      rawExponentialParams = in__.template read_constrain_lb<
                               Eigen::Matrix<local_scalar_t__,-1,1>,
                               jacobian__>(0, lp__, nPriorExponential_code5);
      Eigen::Matrix<local_scalar_t__,-1,1> rawGammaParams =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(nPriorGamma_code6,
          DUMMY_VAR__);
      current_statement__ = 6;
      rawGammaParams = in__.template read_constrain_lb<
                         Eigen::Matrix<local_scalar_t__,-1,1>, jacobian__>(0,
                         lp__, nPriorGamma_code6);
      std::vector<local_scalar_t__> params =
        std::vector<local_scalar_t__>(nParams, DUMMY_VAR__);
      std::vector<std::vector<std::vector<local_scalar_t__>>> initRefr =
        std::vector<std::vector<std::vector<local_scalar_t__>>>(nComps,
          std::vector<std::vector<local_scalar_t__>>(2,
            std::vector<local_scalar_t__>(nGroups, DUMMY_VAR__)));
      current_statement__ = 8;
      stan::model::assign(initRefr,
        stan::math::rep_array(0.0, nComps, 2, nGroups),
        "assigning variable initRefr");
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>
        unmarked =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(nGroups,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(n_quantity_records,
            Eigen::Matrix<local_scalar_t__,-1,1>::Constant(nComps,
              DUMMY_VAR__)));
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>> marked =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(nGroups,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(n_quantity_records,
            Eigen::Matrix<local_scalar_t__,-1,1>::Constant(nComps,
              DUMMY_VAR__)));
      std::vector<std::vector<local_scalar_t__>> sizesPred =
        std::vector<std::vector<local_scalar_t__>>(maxNsizesObs,
          std::vector<local_scalar_t__>(nGroups, DUMMY_VAR__));
      std::vector<std::vector<local_scalar_t__>> propsPred =
        std::vector<std::vector<local_scalar_t__>>(maxNpropsObs,
          std::vector<local_scalar_t__>(nGroups, DUMMY_VAR__));
      std::vector<std::vector<local_scalar_t__>> sizesPred_zeta =
        std::vector<std::vector<local_scalar_t__>>(maxNsizesObs,
          std::vector<local_scalar_t__>(nGroups, DUMMY_VAR__));
      current_statement__ = 13;
      stan::model::assign(sizesPred_zeta,
        stan::math::rep_array(0.0, maxNsizesObs, nGroups),
        "assigning variable sizesPred_zeta");
      std::vector<std::vector<local_scalar_t__>> sizesPred_alpha =
        std::vector<std::vector<local_scalar_t__>>(maxNsizesObs,
          std::vector<local_scalar_t__>(nGroups, DUMMY_VAR__));
      current_statement__ = 14;
      stan::model::assign(sizesPred_alpha,
        stan::math::rep_array(0.0, maxNsizesObs, nGroups),
        "assigning variable sizesPred_alpha");
      std::vector<std::vector<local_scalar_t__>> sizesPred_beta =
        std::vector<std::vector<local_scalar_t__>>(maxNsizesObs,
          std::vector<local_scalar_t__>(nGroups, DUMMY_VAR__));
      current_statement__ = 15;
      stan::model::assign(sizesPred_beta,
        stan::math::rep_array(0.0, maxNsizesObs, nGroups),
        "assigning variable sizesPred_beta");
      std::vector<std::vector<local_scalar_t__>> propsPred_eta =
        std::vector<std::vector<local_scalar_t__>>(maxNpropsObs,
          std::vector<local_scalar_t__>(nGroups, DUMMY_VAR__));
      current_statement__ = 16;
      stan::model::assign(propsPred_eta,
        stan::math::rep_array(0.0, maxNpropsObs, nGroups),
        "assigning variable propsPred_eta");
      std::vector<std::vector<local_scalar_t__>> propsPred_alpha =
        std::vector<std::vector<local_scalar_t__>>(maxNpropsObs,
          std::vector<local_scalar_t__>(nGroups, DUMMY_VAR__));
      current_statement__ = 17;
      stan::model::assign(propsPred_alpha,
        stan::math::rep_array(0.0, maxNpropsObs, nGroups),
        "assigning variable propsPred_alpha");
      std::vector<std::vector<local_scalar_t__>> propsPred_beta =
        std::vector<std::vector<local_scalar_t__>>(maxNpropsObs,
          std::vector<local_scalar_t__>(nGroups, DUMMY_VAR__));
      current_statement__ = 18;
      stan::model::assign(propsPred_beta,
        stan::math::rep_array(0.0, maxNpropsObs, nGroups),
        "assigning variable propsPred_beta");
      std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>> transitions =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(maxNuniqueDts,
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nComps, nComps,
            DUMMY_VAR__));
      std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>> transitionsDecay =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(maxNuniqueDts,
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nComps, nComps,
            DUMMY_VAR__));
      Eigen::Matrix<local_scalar_t__,-1,-1> transfer =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nComps, nComps,
          DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,-1> transferDecay =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nComps, nComps,
          DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,-1> transition_tmp =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nComps, nComps,
          DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,-1> transitionDecay_tmp =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nComps, nComps,
          DUMMY_VAR__);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>
        intervals_init_states_marked =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(maxNtimeIntervals,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(nComps, DUMMY_VAR__));
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>
        intervals_init_states_unmarked =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(maxNtimeIntervals,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(nComps, DUMMY_VAR__));
      {
        int pulseIndex = std::numeric_limits<int>::min();
        current_statement__ = 54;
        for (int i = 1; i <= nParams; ++i) {
          current_statement__ = 34;
          if (stan::math::logical_eq(
                stan::model::rvalue(mappingParamPriorType,
                  "mappingParamPriorType", stan::model::index_uni(i)), 0)) {
            current_statement__ = 32;
            stan::model::assign(params,
              stan::model::rvalue(constantParams, "constantParams",
                stan::model::index_uni(i)), "assigning variable params",
              stan::model::index_uni(i));
          }
          current_statement__ = 37;
          if (stan::math::logical_eq(
                stan::model::rvalue(mappingParamPriorType,
                  "mappingParamPriorType", stan::model::index_uni(i)), 1)) {
            current_statement__ = 35;
            stan::model::assign(params,
              (stan::model::rvalue(lowerParams, "lowerParams",
                 stan::model::index_uni(i)) +
              ((stan::model::rvalue(upperParams, "upperParams",
                  stan::model::index_uni(i)) -
              stan::model::rvalue(lowerParams, "lowerParams",
                stan::model::index_uni(i))) *
              stan::model::rvalue(rawUniformParams, "rawUniformParams",
                stan::model::index_uni(
                  stan::model::rvalue(mappingParamPriorID,
                    "mappingParamPriorID", stan::model::index_uni(i)))))),
              "assigning variable params", stan::model::index_uni(i));
          }
          current_statement__ = 40;
          if (stan::math::logical_eq(
                stan::model::rvalue(mappingParamPriorType,
                  "mappingParamPriorType", stan::model::index_uni(i)), 2)) {
            current_statement__ = 38;
            stan::model::assign(params,
              (stan::model::rvalue(hcauchyScaleParams, "hcauchyScaleParams",
                 stan::model::index_uni(i)) *
              stan::model::rvalue(rawHcauchyParams, "rawHcauchyParams",
                stan::model::index_uni(
                  stan::model::rvalue(mappingParamPriorID,
                    "mappingParamPriorID", stan::model::index_uni(i))))),
              "assigning variable params", stan::model::index_uni(i));
          }
          current_statement__ = 43;
          if (stan::math::logical_eq(
                stan::model::rvalue(mappingParamPriorType,
                  "mappingParamPriorType", stan::model::index_uni(i)), 3)) {
            current_statement__ = 41;
            stan::model::assign(params,
              (stan::model::rvalue(betaScaleParams, "betaScaleParams",
                 stan::model::index_uni(i)) *
              stan::model::rvalue(rawBetaParams, "rawBetaParams",
                stan::model::index_uni(
                  stan::model::rvalue(mappingParamPriorID,
                    "mappingParamPriorID", stan::model::index_uni(i))))),
              "assigning variable params", stan::model::index_uni(i));
          }
          current_statement__ = 46;
          if (stan::math::logical_eq(
                stan::model::rvalue(mappingParamPriorType,
                  "mappingParamPriorType", stan::model::index_uni(i)), 4)) {
            current_statement__ = 44;
            stan::model::assign(params,
              stan::model::rvalue(rawTrNormParams, "rawTrNormParams",
                stan::model::index_uni(
                  stan::model::rvalue(mappingParamPriorID,
                    "mappingParamPriorID", stan::model::index_uni(i)))),
              "assigning variable params", stan::model::index_uni(i));
          }
          current_statement__ = 49;
          if (stan::math::logical_eq(
                stan::model::rvalue(mappingParamPriorType,
                  "mappingParamPriorType", stan::model::index_uni(i)), 5)) {
            current_statement__ = 47;
            stan::model::assign(params,
              stan::model::rvalue(rawExponentialParams,
                "rawExponentialParams",
                stan::model::index_uni(
                  stan::model::rvalue(mappingParamPriorID,
                    "mappingParamPriorID", stan::model::index_uni(i)))),
              "assigning variable params", stan::model::index_uni(i));
          }
          current_statement__ = 52;
          if (stan::math::logical_eq(
                stan::model::rvalue(mappingParamPriorType,
                  "mappingParamPriorType", stan::model::index_uni(i)), 6)) {
            current_statement__ = 50;
            stan::model::assign(params,
              stan::model::rvalue(rawGammaParams, "rawGammaParams",
                stan::model::index_uni(
                  stan::model::rvalue(mappingParamPriorID,
                    "mappingParamPriorID", stan::model::index_uni(i)))),
              "assigning variable params", stan::model::index_uni(i));
          }
        }
        current_statement__ = 185;
        for (int g = 1; g <= nGroups; ++g) {
          current_statement__ = 58;
          if (stan::math::logical_eq(ode_method, 1)) {
            current_statement__ = 55;
            stan::model::assign(transfer,
              buildTransferMatrix(nComps,
                stan::model::rvalue(nSteady, "nSteady",
                  stan::model::index_uni(g)),
                stan::model::rvalue(steadyIndices, "steadyIndices",
                  stan::model::index_omni(), stan::model::index_uni(g)),
                stan::model::rvalue(nUpsilons, "nUpsilons",
                  stan::model::index_uni(g)),
                stan::model::rvalue(upsilonMapping, "upsilonMapping",
                  stan::model::index_omni(), stan::model::index_omni(),
                  stan::model::index_uni(g)),
                stan::model::rvalue(nLambdas, "nLambdas",
                  stan::model::index_uni(g)),
                stan::model::rvalue(lambdaMapping, "lambdaMapping",
                  stan::model::index_omni(), stan::model::index_omni(),
                  stan::model::index_uni(g)), params, pstream__),
              "assigning variable transfer");
            current_statement__ = 56;
            stan::model::assign(transferDecay,
              buildTransferMatrixDecay(nComps, transfer, lambda_decay,
                pstream__), "assigning variable transferDecay");
          }
          current_statement__ = 64;
          if (stan::math::logical_eq(ode_method, 2)) {
            current_statement__ = 62;
            for (int i = 1; i <=
                 stan::model::rvalue(nUniqueDts, "nUniqueDts",
                   stan::model::index_uni(g)); ++i) {
              current_statement__ = 59;
              stan::model::assign(transitions,
                buildTransitionMatrix(nComps,
                  stan::model::rvalue(nUpsilons, "nUpsilons",
                    stan::model::index_uni(g)),
                  stan::model::rvalue(upsilonMapping, "upsilonMapping",
                    stan::model::index_omni(), stan::model::index_omni(),
                    stan::model::index_uni(g)),
                  stan::model::rvalue(nLambdas, "nLambdas",
                    stan::model::index_uni(g)),
                  stan::model::rvalue(lambdaMapping, "lambdaMapping",
                    stan::model::index_omni(), stan::model::index_omni(),
                    stan::model::index_uni(g)),
                  stan::model::rvalue(unique_dts, "unique_dts",
                    stan::model::index_uni(i), stan::model::index_uni(g)),
                  params, pstream__), "assigning variable transitions",
                stan::model::index_uni(i));
              current_statement__ = 60;
              stan::model::assign(transitionsDecay,
                buildTransitionMatrixDecay(nComps,
                  stan::model::rvalue(transitions, "transitions",
                    stan::model::index_uni(i)), lambda_decay,
                  stan::model::rvalue(unique_dts, "unique_dts",
                    stan::model::index_uni(i), stan::model::index_uni(g)),
                  pstream__), "assigning variable transitionsDecay",
                stan::model::index_uni(i));
            }
          }
          current_statement__ = 65;
          pulseIndex = 1;
          current_statement__ = 66;
          stan::model::assign(unmarked,
            stan::math::to_vector(
              stan::model::rvalue(initialQuantities, "initialQuantities",
                stan::model::index_omni(), stan::model::index_uni(1),
                stan::model::index_uni(g))), "assigning variable unmarked",
            stan::model::index_uni(g), stan::model::index_uni(1));
          current_statement__ = 67;
          stan::model::assign(marked,
            stan::math::to_vector(
              stan::model::rvalue(initialQuantities, "initialQuantities",
                stan::model::index_omni(), stan::model::index_uni(2),
                stan::model::index_uni(g))), "assigning variable marked",
            stan::model::index_uni(g), stan::model::index_uni(1));
          current_statement__ = 77;
          if (stan::math::logical_gt(splitPresent, 0)) {
            current_statement__ = 75;
            for (int j = 1; j <= nComps; ++j) {
              current_statement__ = 73;
              if (stan::math::logical_gt(
                    stan::model::rvalue(splitComps, "splitComps",
                      stan::model::index_uni(j), stan::model::index_uni(g)),
                    0)) {
                current_statement__ = 68;
                stan::model::assign(initRefr,
                  (stan::model::rvalue(
                     stan::model::rvalue(unmarked, "unmarked",
                       stan::model::index_uni(g), stan::model::index_uni(1)),
                     "unmarked[g, 1]", stan::model::index_uni(j)) * (1 -
                  stan::model::rvalue(params, "params",
                    stan::model::index_uni(
                      stan::model::rvalue(piMapping, "piMapping",
                        stan::model::index_uni(j), stan::model::index_uni(g)))))),
                  "assigning variable initRefr", stan::model::index_uni(j),
                  stan::model::index_uni(1), stan::model::index_uni(g));
                current_statement__ = 69;
                stan::model::assign(initRefr,
                  (stan::model::rvalue(
                     stan::model::rvalue(marked, "marked",
                       stan::model::index_uni(g), stan::model::index_uni(1)),
                     "marked[g, 1]", stan::model::index_uni(j)) * (1 -
                  stan::model::rvalue(params, "params",
                    stan::model::index_uni(
                      stan::model::rvalue(piMapping, "piMapping",
                        stan::model::index_uni(j), stan::model::index_uni(g)))))),
                  "assigning variable initRefr", stan::model::index_uni(j),
                  stan::model::index_uni(2), stan::model::index_uni(g));
                current_statement__ = 70;
                stan::model::assign(unmarked,
                  (stan::model::rvalue(
                     stan::model::rvalue(unmarked, "unmarked",
                       stan::model::index_uni(g), stan::model::index_uni(1)),
                     "unmarked[g, 1]", stan::model::index_uni(j)) *
                  stan::model::rvalue(params, "params",
                    stan::model::index_uni(
                      stan::model::rvalue(piMapping, "piMapping",
                        stan::model::index_uni(j), stan::model::index_uni(g))))),
                  "assigning variable unmarked", stan::model::index_uni(g),
                  stan::model::index_uni(1), stan::model::index_uni(j));
                current_statement__ = 71;
                stan::model::assign(marked,
                  (stan::model::rvalue(
                     stan::model::rvalue(marked, "marked",
                       stan::model::index_uni(g), stan::model::index_uni(1)),
                     "marked[g, 1]", stan::model::index_uni(j)) *
                  stan::model::rvalue(params, "params",
                    stan::model::index_uni(
                      stan::model::rvalue(piMapping, "piMapping",
                        stan::model::index_uni(j), stan::model::index_uni(g))))),
                  "assigning variable marked", stan::model::index_uni(g),
                  stan::model::index_uni(1), stan::model::index_uni(j));
              }
            }
          }
          current_statement__ = 89;
          if (stan::math::logical_gt(
                stan::model::rvalue(nPulseEvents, "nPulseEvents",
                  stan::model::index_uni(g)), 0)) {
            current_statement__ = 87;
            if (stan::math::logical_lte(pulseIndex,
                  stan::model::rvalue(nPulseEvents, "nPulseEvents",
                    stan::model::index_uni(g)))) {
              current_statement__ = 85;
              while (stan::math::logical_eq(
                       stan::model::rvalue(pulseEventsIndices,
                         "pulseEventsIndices",
                         stan::model::index_uni(pulseIndex),
                         stan::model::index_uni(1), stan::model::index_uni(g)),
                       1)) {
                current_statement__ = 78;
                stan::model::assign(unmarked,
                  (stan::model::rvalue(unmarked, "unmarked",
                     stan::model::index_uni(g), stan::model::index_uni(1),
                     stan::model::index_uni(
                       stan::model::rvalue(pulseEventsIndices,
                         "pulseEventsIndices",
                         stan::model::index_uni(pulseIndex),
                         stan::model::index_uni(2), stan::model::index_uni(g))))
                  +
                  stan::model::rvalue(pulseEventsQuantities,
                    "pulseEventsQuantities",
                    stan::model::index_uni(pulseIndex),
                    stan::model::index_uni(1), stan::model::index_uni(g))),
                  "assigning variable unmarked", stan::model::index_uni(g),
                  stan::model::index_uni(1),
                  stan::model::index_uni(
                    stan::model::rvalue(pulseEventsIndices,
                      "pulseEventsIndices",
                      stan::model::index_uni(pulseIndex),
                      stan::model::index_uni(2), stan::model::index_uni(g))));
                current_statement__ = 79;
                stan::model::assign(marked,
                  (stan::model::rvalue(marked, "marked",
                     stan::model::index_uni(g), stan::model::index_uni(1),
                     stan::model::index_uni(
                       stan::model::rvalue(pulseEventsIndices,
                         "pulseEventsIndices",
                         stan::model::index_uni(pulseIndex),
                         stan::model::index_uni(2), stan::model::index_uni(g))))
                  +
                  stan::model::rvalue(pulseEventsQuantities,
                    "pulseEventsQuantities",
                    stan::model::index_uni(pulseIndex),
                    stan::model::index_uni(2), stan::model::index_uni(g))),
                  "assigning variable marked", stan::model::index_uni(g),
                  stan::model::index_uni(1),
                  stan::model::index_uni(
                    stan::model::rvalue(pulseEventsIndices,
                      "pulseEventsIndices",
                      stan::model::index_uni(pulseIndex),
                      stan::model::index_uni(2), stan::model::index_uni(g))));
                current_statement__ = 80;
                pulseIndex = (pulseIndex + 1);
                current_statement__ = 83;
                if (stan::math::logical_gt(pulseIndex,
                      stan::model::rvalue(nPulseEvents, "nPulseEvents",
                        stan::model::index_uni(g)))) {
                  break;
                }
              }
            }
          }
          current_statement__ = 127;
          if (stan::math::logical_eq(ode_method, 1)) {
            current_statement__ = 90;
            stan::model::assign(intervals_init_states_unmarked,
              stan::model::rvalue(unmarked, "unmarked",
                stan::model::index_uni(g), stan::model::index_uni(1)),
              "assigning variable intervals_init_states_unmarked",
              stan::model::index_uni(1));
            current_statement__ = 91;
            stan::model::assign(intervals_init_states_marked,
              stan::model::rvalue(marked, "marked",
                stan::model::index_uni(g), stan::model::index_uni(1)),
              "assigning variable intervals_init_states_marked",
              stan::model::index_uni(1));
            current_statement__ = 115;
            if (stan::math::logical_gt(
                  stan::model::rvalue(nTimeIntervals, "nTimeIntervals",
                    stan::model::index_uni(g)), 1)) {
              current_statement__ = 113;
              for (int t = 2; t <=
                   stan::model::rvalue(nTimeIntervals, "nTimeIntervals",
                     stan::model::index_uni(g)); ++t) {
                current_statement__ = 92;
                stan::model::assign(transition_tmp,
                  stan::math::matrix_exp(
                    stan::math::multiply(
                      stan::model::rvalue(intervalsLengths,
                        "intervalsLengths", stan::model::index_uni((t - 1)),
                        stan::model::index_uni(g)), transfer)),
                  "assigning variable transition_tmp");
                current_statement__ = 97;
                if (stan::math::logical_eq(lambda_decay, 0)) {
                  current_statement__ = 95;
                  stan::model::assign(transitionDecay_tmp, transition_tmp,
                    "assigning variable transitionDecay_tmp");
                } else {
                  current_statement__ = 93;
                  stan::model::assign(transitionDecay_tmp,
                    stan::math::matrix_exp(
                      stan::math::multiply(
                        stan::model::rvalue(intervalsLengths,
                          "intervalsLengths",
                          stan::model::index_uni((t - 1)),
                          stan::model::index_uni(g)), transferDecay)),
                    "assigning variable transitionDecay_tmp");
                }
                current_statement__ = 98;
                stan::model::assign(intervals_init_states_unmarked,
                  stan::math::multiply(transition_tmp,
                    stan::model::deep_copy(
                      stan::model::rvalue(intervals_init_states_unmarked,
                        "intervals_init_states_unmarked",
                        stan::model::index_uni((t - 1))))),
                  "assigning variable intervals_init_states_unmarked",
                  stan::model::index_uni(t));
                current_statement__ = 99;
                stan::model::assign(intervals_init_states_marked,
                  stan::math::multiply(transitionDecay_tmp,
                    stan::model::deep_copy(
                      stan::model::rvalue(intervals_init_states_marked,
                        "intervals_init_states_marked",
                        stan::model::index_uni((t - 1))))),
                  "assigning variable intervals_init_states_marked",
                  stan::model::index_uni(t));
                current_statement__ = 111;
                if (stan::math::logical_gt(
                      stan::model::rvalue(nPulseEvents, "nPulseEvents",
                        stan::model::index_uni(g)), 0)) {
                  current_statement__ = 109;
                  if (stan::math::logical_lte(pulseIndex,
                        stan::model::rvalue(nPulseEvents, "nPulseEvents",
                          stan::model::index_uni(g)))) {
                    current_statement__ = 107;
                    while (stan::math::logical_eq(
                             stan::model::rvalue(pulseEventsIndices,
                               "pulseEventsIndices",
                               stan::model::index_uni(pulseIndex),
                               stan::model::index_uni(1),
                               stan::model::index_uni(g)), t)) {
                      current_statement__ = 100;
                      stan::model::assign(intervals_init_states_unmarked,
                        (stan::model::rvalue(intervals_init_states_unmarked,
                           "intervals_init_states_unmarked",
                           stan::model::index_uni(t),
                           stan::model::index_uni(
                             stan::model::rvalue(pulseEventsIndices,
                               "pulseEventsIndices",
                               stan::model::index_uni(pulseIndex),
                               stan::model::index_uni(2),
                               stan::model::index_uni(g)))) +
                        stan::model::rvalue(pulseEventsQuantities,
                          "pulseEventsQuantities",
                          stan::model::index_uni(pulseIndex),
                          stan::model::index_uni(1),
                          stan::model::index_uni(g))),
                        "assigning variable intervals_init_states_unmarked",
                        stan::model::index_uni(t),
                        stan::model::index_uni(
                          stan::model::rvalue(pulseEventsIndices,
                            "pulseEventsIndices",
                            stan::model::index_uni(pulseIndex),
                            stan::model::index_uni(2),
                            stan::model::index_uni(g))));
                      current_statement__ = 101;
                      stan::model::assign(intervals_init_states_marked,
                        (stan::model::rvalue(intervals_init_states_marked,
                           "intervals_init_states_marked",
                           stan::model::index_uni(t),
                           stan::model::index_uni(
                             stan::model::rvalue(pulseEventsIndices,
                               "pulseEventsIndices",
                               stan::model::index_uni(pulseIndex),
                               stan::model::index_uni(2),
                               stan::model::index_uni(g)))) +
                        stan::model::rvalue(pulseEventsQuantities,
                          "pulseEventsQuantities",
                          stan::model::index_uni(pulseIndex),
                          stan::model::index_uni(2),
                          stan::model::index_uni(g))),
                        "assigning variable intervals_init_states_marked",
                        stan::model::index_uni(t),
                        stan::model::index_uni(
                          stan::model::rvalue(pulseEventsIndices,
                            "pulseEventsIndices",
                            stan::model::index_uni(pulseIndex),
                            stan::model::index_uni(2),
                            stan::model::index_uni(g))));
                      current_statement__ = 102;
                      pulseIndex = (pulseIndex + 1);
                      current_statement__ = 105;
                      if (stan::math::logical_gt(pulseIndex,
                            stan::model::rvalue(nPulseEvents, "nPulseEvents",
                              stan::model::index_uni(g)))) {
                        break;
                      }
                    }
                  }
                }
              }
            }
            current_statement__ = 125;
            for (int k = 1; k <=
                 stan::model::rvalue(nObsTimes, "nObsTimes",
                   stan::model::index_uni(g)); ++k) {
              current_statement__ = 116;
              stan::model::assign(transition_tmp,
                stan::math::matrix_exp(
                  stan::math::multiply(
                    stan::model::rvalue(elapsedTimeSinceEvent,
                      "elapsedTimeSinceEvent", stan::model::index_uni(g),
                      stan::model::index_uni(k)), transfer)),
                "assigning variable transition_tmp");
              current_statement__ = 121;
              if (stan::math::logical_eq(lambda_decay, 0)) {
                current_statement__ = 119;
                stan::model::assign(transitionDecay_tmp, transition_tmp,
                  "assigning variable transitionDecay_tmp");
              } else {
                current_statement__ = 117;
                stan::model::assign(transitionDecay_tmp,
                  stan::math::matrix_exp(
                    stan::math::multiply(
                      stan::model::rvalue(elapsedTimeSinceEvent,
                        "elapsedTimeSinceEvent", stan::model::index_uni(g),
                        stan::model::index_uni(k)), transferDecay)),
                  "assigning variable transitionDecay_tmp");
              }
              current_statement__ = 122;
              stan::model::assign(unmarked,
                stan::math::multiply(transition_tmp,
                  stan::model::rvalue(intervals_init_states_unmarked,
                    "intervals_init_states_unmarked",
                    stan::model::index_uni(
                      stan::model::rvalue(obsIntervalsIndices,
                        "obsIntervalsIndices", stan::model::index_uni(g),
                        stan::model::index_uni(k))))),
                "assigning variable unmarked", stan::model::index_uni(g),
                stan::model::index_uni(k));
              current_statement__ = 123;
              stan::model::assign(marked,
                stan::math::multiply(transitionDecay_tmp,
                  stan::model::rvalue(intervals_init_states_marked,
                    "intervals_init_states_marked",
                    stan::model::index_uni(
                      stan::model::rvalue(obsIntervalsIndices,
                        "obsIntervalsIndices", stan::model::index_uni(g),
                        stan::model::index_uni(k))))),
                "assigning variable marked", stan::model::index_uni(g),
                stan::model::index_uni(k));
            }
          }
          current_statement__ = 151;
          if (stan::math::logical_eq(ode_method, 2)) {
            current_statement__ = 149;
            for (int t = 1; t <=
                 stan::model::rvalue(nTimesteps, "nTimesteps",
                   stan::model::index_uni(g)); ++t) {
              current_statement__ = 128;
              stan::model::assign(unmarked,
                stan::math::multiply(
                  stan::model::rvalue(transitions, "transitions",
                    stan::model::index_uni(
                      stan::model::rvalue(timesteps, "timesteps",
                        stan::model::index_uni(t), stan::model::index_uni(g)))),
                  stan::model::deep_copy(
                    stan::model::rvalue(unmarked, "unmarked",
                      stan::model::index_uni(g), stan::model::index_uni(t)))),
                "assigning variable unmarked", stan::model::index_uni(g),
                stan::model::index_uni((t + 1)));
              current_statement__ = 129;
              stan::model::assign(marked,
                stan::math::multiply(
                  stan::model::rvalue(transitionsDecay, "transitionsDecay",
                    stan::model::index_uni(
                      stan::model::rvalue(timesteps, "timesteps",
                        stan::model::index_uni(t), stan::model::index_uni(g)))),
                  stan::model::deep_copy(
                    stan::model::rvalue(marked, "marked",
                      stan::model::index_uni(g), stan::model::index_uni(t)))),
                "assigning variable marked", stan::model::index_uni(g),
                stan::model::index_uni((t + 1)));
              current_statement__ = 135;
              if (stan::math::logical_gt(
                    stan::model::rvalue(nSteady, "nSteady",
                      stan::model::index_uni(g)), 0)) {
                current_statement__ = 133;
                for (int k = 1; k <=
                     stan::model::rvalue(nSteady, "nSteady",
                       stan::model::index_uni(g)); ++k) {
                  current_statement__ = 130;
                  stan::model::assign(unmarked,
                    stan::model::rvalue(
                      stan::model::rvalue(unmarked, "unmarked",
                        stan::model::index_uni(g), stan::model::index_uni(t)),
                      "unmarked[g, t]",
                      stan::model::index_uni(
                        stan::model::rvalue(steadyIndices, "steadyIndices",
                          stan::model::index_uni(k),
                          stan::model::index_uni(g)))),
                    "assigning variable unmarked", stan::model::index_uni(g),
                    stan::model::index_uni((t + 1)),
                    stan::model::index_uni(
                      stan::model::rvalue(steadyIndices, "steadyIndices",
                        stan::model::index_uni(k), stan::model::index_uni(g))));
                  current_statement__ = 131;
                  stan::model::assign(marked,
                    stan::model::rvalue(
                      stan::model::rvalue(marked, "marked",
                        stan::model::index_uni(g), stan::model::index_uni(t)),
                      "marked[g, t]",
                      stan::model::index_uni(
                        stan::model::rvalue(steadyIndices, "steadyIndices",
                          stan::model::index_uni(k),
                          stan::model::index_uni(g)))),
                    "assigning variable marked", stan::model::index_uni(g),
                    stan::model::index_uni((t + 1)),
                    stan::model::index_uni(
                      stan::model::rvalue(steadyIndices, "steadyIndices",
                        stan::model::index_uni(k), stan::model::index_uni(g))));
                }
              }
              current_statement__ = 147;
              if (stan::math::logical_gt(
                    stan::model::rvalue(nPulseEvents, "nPulseEvents",
                      stan::model::index_uni(g)), 0)) {
                current_statement__ = 145;
                if (stan::math::logical_lte(pulseIndex,
                      stan::model::rvalue(nPulseEvents, "nPulseEvents",
                        stan::model::index_uni(g)))) {
                  current_statement__ = 143;
                  while (stan::math::logical_eq(
                           stan::model::rvalue(pulseEventsIndices,
                             "pulseEventsIndices",
                             stan::model::index_uni(pulseIndex),
                             stan::model::index_uni(1),
                             stan::model::index_uni(g)), (t + 1))) {
                    current_statement__ = 136;
                    stan::model::assign(unmarked,
                      (stan::model::rvalue(unmarked, "unmarked",
                         stan::model::index_uni(g),
                         stan::model::index_uni((t + 1)),
                         stan::model::index_uni(
                           stan::model::rvalue(pulseEventsIndices,
                             "pulseEventsIndices",
                             stan::model::index_uni(pulseIndex),
                             stan::model::index_uni(2),
                             stan::model::index_uni(g)))) +
                      stan::model::rvalue(pulseEventsQuantities,
                        "pulseEventsQuantities",
                        stan::model::index_uni(pulseIndex),
                        stan::model::index_uni(1), stan::model::index_uni(g))),
                      "assigning variable unmarked",
                      stan::model::index_uni(g),
                      stan::model::index_uni((t + 1)),
                      stan::model::index_uni(
                        stan::model::rvalue(pulseEventsIndices,
                          "pulseEventsIndices",
                          stan::model::index_uni(pulseIndex),
                          stan::model::index_uni(2),
                          stan::model::index_uni(g))));
                    current_statement__ = 137;
                    stan::model::assign(marked,
                      (stan::model::rvalue(marked, "marked",
                         stan::model::index_uni(g),
                         stan::model::index_uni((t + 1)),
                         stan::model::index_uni(
                           stan::model::rvalue(pulseEventsIndices,
                             "pulseEventsIndices",
                             stan::model::index_uni(pulseIndex),
                             stan::model::index_uni(2),
                             stan::model::index_uni(g)))) +
                      stan::model::rvalue(pulseEventsQuantities,
                        "pulseEventsQuantities",
                        stan::model::index_uni(pulseIndex),
                        stan::model::index_uni(2), stan::model::index_uni(g))),
                      "assigning variable marked", stan::model::index_uni(g),
                      stan::model::index_uni((t + 1)),
                      stan::model::index_uni(
                        stan::model::rvalue(pulseEventsIndices,
                          "pulseEventsIndices",
                          stan::model::index_uni(pulseIndex),
                          stan::model::index_uni(2),
                          stan::model::index_uni(g))));
                    current_statement__ = 138;
                    pulseIndex = (pulseIndex + 1);
                    current_statement__ = 141;
                    if (stan::math::logical_gt(pulseIndex,
                          stan::model::rvalue(nPulseEvents, "nPulseEvents",
                            stan::model::index_uni(g)))) {
                      break;
                    }
                  }
                }
              }
            }
          }
          current_statement__ = 152;
          stan::model::assign(sizesPred,
            buildSizePredictions(
              stan::model::rvalue(nSizesObs, "nSizesObs",
                stan::model::index_uni(g)), g, maxNsizesObs,
              stan::model::rvalue(unmarked, "unmarked",
                stan::model::index_uni(g), stan::model::index_omni()),
              stan::model::rvalue(marked, "marked",
                stan::model::index_uni(g), stan::model::index_omni()),
              stan::model::rvalue(sizesObsIndices, "sizesObsIndices",
                stan::model::index_omni(), stan::model::index_omni(),
                stan::model::index_uni(g)), splitPresent,
              stan::model::rvalue(splitComps, "splitComps",
                stan::model::index_omni(), stan::model::index_uni(g)),
              stan::model::rvalue(initRefr, "initRefr",
                stan::model::index_omni(), stan::model::index_omni(),
                stan::model::index_uni(g)), pstream__),
            "assigning variable sizesPred", stan::model::index_omni(),
            stan::model::index_uni(g));
          current_statement__ = 153;
          stan::model::assign(propsPred,
            buildPropPredictions(
              stan::model::rvalue(nPropsObs, "nPropsObs",
                stan::model::index_uni(g)), g, maxNpropsObs,
              stan::model::rvalue(unmarked, "unmarked",
                stan::model::index_uni(g), stan::model::index_omni()),
              stan::model::rvalue(marked, "marked",
                stan::model::index_uni(g), stan::model::index_omni()),
              stan::model::rvalue(propsObsIndices, "propsObsIndices",
                stan::model::index_omni(), stan::model::index_omni(),
                stan::model::index_uni(g)), splitPresent,
              stan::model::rvalue(splitComps, "splitComps",
                stan::model::index_omni(), stan::model::index_uni(g)),
              stan::model::rvalue(initRefr, "initRefr",
                stan::model::index_omni(), stan::model::index_omni(),
                stan::model::index_uni(g)), pstream__),
            "assigning variable propsPred", stan::model::index_omni(),
            stan::model::index_uni(g));
          current_statement__ = 164;
          for (int k = 1; k <=
               stan::model::rvalue(nSizesObs, "nSizesObs",
                 stan::model::index_uni(g)); ++k) {
            current_statement__ = 154;
            stan::model::assign(sizesPred_zeta,
              stan::model::rvalue(params, "params",
                stan::model::index_uni(
                  stan::model::rvalue(sizesObsIndices, "sizesObsIndices",
                    stan::model::index_uni(k), stan::model::index_uni(3),
                    stan::model::index_uni(g)))),
              "assigning variable sizesPred_zeta", stan::model::index_uni(k),
              stan::model::index_uni(g));
            current_statement__ = 158;
            if (stan::math::logical_eq(sizeFamily, 1)) {
              current_statement__ = 155;
              stan::model::assign(sizesPred_alpha,
                stan::model::rvalue(sizesPred, "sizesPred",
                  stan::model::index_uni(k), stan::model::index_uni(g)),
                "assigning variable sizesPred_alpha",
                stan::model::index_uni(k), stan::model::index_uni(g));
              current_statement__ = 156;
              stan::model::assign(sizesPred_beta,
                (stan::model::rvalue(sizesPred_zeta, "sizesPred_zeta",
                   stan::model::index_uni(k), stan::model::index_uni(g)) *
                stan::model::rvalue(sizesPred, "sizesPred",
                  stan::model::index_uni(k), stan::model::index_uni(g))),
                "assigning variable sizesPred_beta",
                stan::model::index_uni(k), stan::model::index_uni(g));
            }
            current_statement__ = 162;
            if (stan::math::logical_eq(sizeFamily, 2)) {
              current_statement__ = 159;
              stan::model::assign(sizesPred_alpha,
                stan::model::rvalue(sizesPred, "sizesPred",
                  stan::model::index_uni(k), stan::model::index_uni(g)),
                "assigning variable sizesPred_alpha",
                stan::model::index_uni(k), stan::model::index_uni(g));
              current_statement__ = 160;
              stan::model::assign(sizesPred_beta,
                stan::model::rvalue(sizesPred_zeta, "sizesPred_zeta",
                  stan::model::index_uni(k), stan::model::index_uni(g)),
                "assigning variable sizesPred_beta",
                stan::model::index_uni(k), stan::model::index_uni(g));
            }
          }
          current_statement__ = 183;
          for (int k = 1; k <=
               stan::model::rvalue(nPropsObs, "nPropsObs",
                 stan::model::index_uni(g)); ++k) {
            current_statement__ = 165;
            stan::model::assign(propsPred_eta,
              stan::model::rvalue(params, "params",
                stan::model::index_uni(
                  stan::model::rvalue(propsObsIndices, "propsObsIndices",
                    stan::model::index_uni(k), stan::model::index_uni(3),
                    stan::model::index_uni(g)))),
              "assigning variable propsPred_eta", stan::model::index_uni(k),
              stan::model::index_uni(g));
            current_statement__ = 169;
            if (stan::math::logical_eq(propFamily, 1)) {
              current_statement__ = 166;
              stan::model::assign(propsPred_alpha,
                stan::math::pow(
                  stan::model::rvalue(propsPred_eta, "propsPred_eta",
                    stan::model::index_uni(k), stan::model::index_uni(g)), -2),
                "assigning variable propsPred_alpha",
                stan::model::index_uni(k), stan::model::index_uni(g));
              current_statement__ = 167;
              stan::model::assign(propsPred_beta,
                (stan::model::rvalue(propsPred_alpha, "propsPred_alpha",
                   stan::model::index_uni(k), stan::model::index_uni(g)) /
                stan::model::rvalue(propsPred, "propsPred",
                  stan::model::index_uni(k), stan::model::index_uni(g))),
                "assigning variable propsPred_beta",
                stan::model::index_uni(k), stan::model::index_uni(g));
            }
            current_statement__ = 173;
            if (stan::math::logical_eq(propFamily, 2)) {
              current_statement__ = 170;
              stan::model::assign(propsPred_alpha,
                stan::model::rvalue(propsPred, "propsPred",
                  stan::model::index_uni(k), stan::model::index_uni(g)),
                "assigning variable propsPred_alpha",
                stan::model::index_uni(k), stan::model::index_uni(g));
              current_statement__ = 171;
              stan::model::assign(propsPred_beta,
                (stan::model::rvalue(propsPred_eta, "propsPred_eta",
                   stan::model::index_uni(k), stan::model::index_uni(g)) *
                stan::model::rvalue(propsPred_alpha, "propsPred_alpha",
                  stan::model::index_uni(k), stan::model::index_uni(g))),
                "assigning variable propsPred_beta",
                stan::model::index_uni(k), stan::model::index_uni(g));
            }
            current_statement__ = 177;
            if (stan::math::logical_eq(propFamily, 3)) {
              current_statement__ = 174;
              stan::model::assign(propsPred_alpha,
                stan::model::rvalue(propsPred, "propsPred",
                  stan::model::index_uni(k), stan::model::index_uni(g)),
                "assigning variable propsPred_alpha",
                stan::model::index_uni(k), stan::model::index_uni(g));
              current_statement__ = 175;
              stan::model::assign(propsPred_beta,
                stan::model::rvalue(propsPred_eta, "propsPred_eta",
                  stan::model::index_uni(k), stan::model::index_uni(g)),
                "assigning variable propsPred_beta",
                stan::model::index_uni(k), stan::model::index_uni(g));
            }
            current_statement__ = 181;
            if (stan::math::logical_eq(propFamily, 4)) {
              current_statement__ = 178;
              stan::model::assign(propsPred_alpha,
                (stan::model::rvalue(propsPred, "propsPred",
                   stan::model::index_uni(k), stan::model::index_uni(g)) *
                stan::model::rvalue(propsPred_eta, "propsPred_eta",
                  stan::model::index_uni(k), stan::model::index_uni(g))),
                "assigning variable propsPred_alpha",
                stan::model::index_uni(k), stan::model::index_uni(g));
              current_statement__ = 179;
              stan::model::assign(propsPred_beta,
                (stan::model::rvalue(propsPred_eta, "propsPred_eta",
                   stan::model::index_uni(k), stan::model::index_uni(g)) * (1
                -
                stan::model::rvalue(propsPred, "propsPred",
                  stan::model::index_uni(k), stan::model::index_uni(g)))),
                "assigning variable propsPred_beta",
                stan::model::index_uni(k), stan::model::index_uni(g));
            }
          }
        }
      }
      current_statement__ = 7;
      stan::math::check_greater_or_equal(function__, "params", params, 0);
      current_statement__ = 8;
      stan::math::check_greater_or_equal(function__, "initRefr", initRefr, 0);
      current_statement__ = 11;
      stan::math::check_greater_or_equal(function__, "sizesPred", sizesPred,
        0);
      current_statement__ = 12;
      stan::math::check_greater_or_equal(function__, "propsPred", propsPred,
        0);
      current_statement__ = 13;
      stan::math::check_greater_or_equal(function__, "sizesPred_zeta",
        sizesPred_zeta, 0);
      current_statement__ = 14;
      stan::math::check_greater_or_equal(function__, "sizesPred_alpha",
        sizesPred_alpha, 0);
      current_statement__ = 15;
      stan::math::check_greater_or_equal(function__, "sizesPred_beta",
        sizesPred_beta, 0);
      current_statement__ = 16;
      stan::math::check_greater_or_equal(function__, "propsPred_eta",
        propsPred_eta, 0);
      current_statement__ = 17;
      stan::math::check_greater_or_equal(function__, "propsPred_alpha",
        propsPred_alpha, 0);
      current_statement__ = 18;
      stan::math::check_greater_or_equal(function__, "propsPred_beta",
        propsPred_beta, 0);
      {
        current_statement__ = 242;
        for (int i = 1; i <= nParams; ++i) {
          current_statement__ = 225;
          if (stan::math::logical_eq(
                stan::model::rvalue(mappingParamPriorType,
                  "mappingParamPriorType", stan::model::index_uni(i)), 1)) {
            current_statement__ = 223;
            lp_accum__.add(stan::math::uniform_lpdf<propto__>(
                             stan::model::rvalue(rawUniformParams,
                               "rawUniformParams",
                               stan::model::index_uni(
                                 stan::model::rvalue(mappingParamPriorID,
                                   "mappingParamPriorID",
                                   stan::model::index_uni(i)))), 0, 1));
          }
          current_statement__ = 228;
          if (stan::math::logical_eq(
                stan::model::rvalue(mappingParamPriorType,
                  "mappingParamPriorType", stan::model::index_uni(i)), 2)) {
            current_statement__ = 226;
            lp_accum__.add(stan::math::cauchy_lpdf<propto__>(
                             stan::model::rvalue(rawHcauchyParams,
                               "rawHcauchyParams",
                               stan::model::index_uni(
                                 stan::model::rvalue(mappingParamPriorID,
                                   "mappingParamPriorID",
                                   stan::model::index_uni(i)))), 0, 1));
          }
          current_statement__ = 231;
          if (stan::math::logical_eq(
                stan::model::rvalue(mappingParamPriorType,
                  "mappingParamPriorType", stan::model::index_uni(i)), 3)) {
            current_statement__ = 229;
            lp_accum__.add(stan::math::beta_lpdf<propto__>(
                             stan::model::rvalue(rawBetaParams,
                               "rawBetaParams",
                               stan::model::index_uni(
                                 stan::model::rvalue(mappingParamPriorID,
                                   "mappingParamPriorID",
                                   stan::model::index_uni(i)))),
                             stan::model::rvalue(rawBetaAlpha,
                               "rawBetaAlpha", stan::model::index_uni(i)),
                             stan::model::rvalue(rawBetaBeta, "rawBetaBeta",
                               stan::model::index_uni(i))));
          }
          current_statement__ = 234;
          if (stan::math::logical_eq(
                stan::model::rvalue(mappingParamPriorType,
                  "mappingParamPriorType", stan::model::index_uni(i)), 4)) {
            current_statement__ = 232;
            lp_accum__.add(stan::math::normal_lpdf<propto__>(
                             stan::model::rvalue(rawTrNormParams,
                               "rawTrNormParams",
                               stan::model::index_uni(
                                 stan::model::rvalue(mappingParamPriorID,
                                   "mappingParamPriorID",
                                   stan::model::index_uni(i)))),
                             stan::model::rvalue(trNormMeanParams,
                               "trNormMeanParams", stan::model::index_uni(i)),
                             stan::model::rvalue(trNormSdParams,
                               "trNormSdParams", stan::model::index_uni(i))));
          }
          current_statement__ = 237;
          if (stan::math::logical_eq(
                stan::model::rvalue(mappingParamPriorType,
                  "mappingParamPriorType", stan::model::index_uni(i)), 5)) {
            current_statement__ = 235;
            lp_accum__.add(stan::math::exponential_lpdf<propto__>(
                             stan::model::rvalue(rawExponentialParams,
                               "rawExponentialParams",
                               stan::model::index_uni(
                                 stan::model::rvalue(mappingParamPriorID,
                                   "mappingParamPriorID",
                                   stan::model::index_uni(i)))),
                             stan::model::rvalue(exponentialRateParams,
                               "exponentialRateParams",
                               stan::model::index_uni(i))));
          }
          current_statement__ = 240;
          if (stan::math::logical_eq(
                stan::model::rvalue(mappingParamPriorType,
                  "mappingParamPriorType", stan::model::index_uni(i)), 6)) {
            current_statement__ = 238;
            lp_accum__.add(stan::math::gamma_lpdf<propto__>(
                             stan::model::rvalue(rawGammaParams,
                               "rawGammaParams",
                               stan::model::index_uni(
                                 stan::model::rvalue(mappingParamPriorID,
                                   "mappingParamPriorID",
                                   stan::model::index_uni(i)))),
                             stan::model::rvalue(gammaAlphaParams,
                               "gammaAlphaParams", stan::model::index_uni(i)),
                             stan::model::rvalue(gammaBetaParams,
                               "gammaBetaParams", stan::model::index_uni(i))));
          }
        }
        current_statement__ = 262;
        for (int g = 1; g <= nGroups; ++g) {
          current_statement__ = 245;
          if (stan::math::logical_eq(sizeFamily, 1)) {
            current_statement__ = 243;
            lp_accum__.add(stan::math::normal_lpdf<propto__>(
                             stan::model::rvalue(sizesObs, "sizesObs",
                               stan::model::index_min_max(1,
                                 stan::model::rvalue(nSizesObs, "nSizesObs",
                                   stan::model::index_uni(g))),
                               stan::model::index_uni(g)),
                             stan::model::rvalue(sizesPred_alpha,
                               "sizesPred_alpha",
                               stan::model::index_min_max(1,
                                 stan::model::rvalue(nSizesObs, "nSizesObs",
                                   stan::model::index_uni(g))),
                               stan::model::index_uni(g)),
                             stan::model::rvalue(sizesPred_beta,
                               "sizesPred_beta",
                               stan::model::index_min_max(1,
                                 stan::model::rvalue(nSizesObs, "nSizesObs",
                                   stan::model::index_uni(g))),
                               stan::model::index_uni(g))));
          }
          current_statement__ = 248;
          if (stan::math::logical_eq(sizeFamily, 2)) {
            current_statement__ = 246;
            lp_accum__.add(stan::math::normal_lpdf<propto__>(
                             stan::model::rvalue(sizesObs, "sizesObs",
                               stan::model::index_min_max(1,
                                 stan::model::rvalue(nSizesObs, "nSizesObs",
                                   stan::model::index_uni(g))),
                               stan::model::index_uni(g)),
                             stan::model::rvalue(sizesPred_alpha,
                               "sizesPred_alpha",
                               stan::model::index_min_max(1,
                                 stan::model::rvalue(nSizesObs, "nSizesObs",
                                   stan::model::index_uni(g))),
                               stan::model::index_uni(g)),
                             stan::model::rvalue(sizesPred_beta,
                               "sizesPred_beta",
                               stan::model::index_min_max(1,
                                 stan::model::rvalue(nSizesObs, "nSizesObs",
                                   stan::model::index_uni(g))),
                               stan::model::index_uni(g))));
          }
          current_statement__ = 251;
          if (stan::math::logical_eq(propFamily, 1)) {
            current_statement__ = 249;
            lp_accum__.add(stan::math::gamma_lpdf<propto__>(
                             stan::model::rvalue(propsObs, "propsObs",
                               stan::model::index_min_max(1,
                                 stan::model::rvalue(nPropsObs, "nPropsObs",
                                   stan::model::index_uni(g))),
                               stan::model::index_uni(g)),
                             stan::model::rvalue(propsPred_alpha,
                               "propsPred_alpha",
                               stan::model::index_min_max(1,
                                 stan::model::rvalue(nPropsObs, "nPropsObs",
                                   stan::model::index_uni(g))),
                               stan::model::index_uni(g)),
                             stan::model::rvalue(propsPred_beta,
                               "propsPred_beta",
                               stan::model::index_min_max(1,
                                 stan::model::rvalue(nPropsObs, "nPropsObs",
                                   stan::model::index_uni(g))),
                               stan::model::index_uni(g))));
          }
          current_statement__ = 254;
          if (stan::math::logical_eq(propFamily, 2)) {
            current_statement__ = 252;
            lp_accum__.add(stan::math::normal_lpdf<propto__>(
                             stan::model::rvalue(propsObs, "propsObs",
                               stan::model::index_min_max(1,
                                 stan::model::rvalue(nPropsObs, "nPropsObs",
                                   stan::model::index_uni(g))),
                               stan::model::index_uni(g)),
                             stan::model::rvalue(propsPred_alpha,
                               "propsPred_alpha",
                               stan::model::index_min_max(1,
                                 stan::model::rvalue(nPropsObs, "nPropsObs",
                                   stan::model::index_uni(g))),
                               stan::model::index_uni(g)),
                             stan::model::rvalue(propsPred_beta,
                               "propsPred_beta",
                               stan::model::index_min_max(1,
                                 stan::model::rvalue(nPropsObs, "nPropsObs",
                                   stan::model::index_uni(g))),
                               stan::model::index_uni(g))));
          }
          current_statement__ = 257;
          if (stan::math::logical_eq(propFamily, 3)) {
            current_statement__ = 255;
            lp_accum__.add(stan::math::normal_lpdf<propto__>(
                             stan::model::rvalue(propsObs, "propsObs",
                               stan::model::index_min_max(1,
                                 stan::model::rvalue(nPropsObs, "nPropsObs",
                                   stan::model::index_uni(g))),
                               stan::model::index_uni(g)),
                             stan::model::rvalue(propsPred_alpha,
                               "propsPred_alpha",
                               stan::model::index_min_max(1,
                                 stan::model::rvalue(nPropsObs, "nPropsObs",
                                   stan::model::index_uni(g))),
                               stan::model::index_uni(g)),
                             stan::model::rvalue(propsPred_beta,
                               "propsPred_beta",
                               stan::model::index_min_max(1,
                                 stan::model::rvalue(nPropsObs, "nPropsObs",
                                   stan::model::index_uni(g))),
                               stan::model::index_uni(g))));
          }
          current_statement__ = 260;
          if (stan::math::logical_eq(propFamily, 4)) {
            current_statement__ = 258;
            lp_accum__.add(stan::math::beta_lpdf<propto__>(
                             stan::model::rvalue(propsObs, "propsObs",
                               stan::model::index_min_max(1,
                                 stan::model::rvalue(nPropsObs, "nPropsObs",
                                   stan::model::index_uni(g))),
                               stan::model::index_uni(g)),
                             stan::model::rvalue(propsPred_alpha,
                               "propsPred_alpha",
                               stan::model::index_min_max(1,
                                 stan::model::rvalue(nPropsObs, "nPropsObs",
                                   stan::model::index_uni(g))),
                               stan::model::index_uni(g)),
                             stan::model::rvalue(propsPred_beta,
                               "propsPred_beta",
                               stan::model::index_min_max(1,
                                 stan::model::rvalue(nPropsObs, "nPropsObs",
                                   stan::model::index_uni(g))),
                               stan::model::index_uni(g))));
          }
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    static constexpr const char* function__ =
      "model_networkModel_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<double,-1,1> rawUniformParams =
        Eigen::Matrix<double,-1,1>::Constant(nPriorUniform_code1,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 1;
      rawUniformParams = in__.template read_constrain_lub<
                           Eigen::Matrix<local_scalar_t__,-1,1>,
                           jacobian__>(0, 1, lp__, nPriorUniform_code1);
      Eigen::Matrix<double,-1,1> rawHcauchyParams =
        Eigen::Matrix<double,-1,1>::Constant(nPriorHcauchy_code2,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 2;
      rawHcauchyParams = in__.template read_constrain_lb<
                           Eigen::Matrix<local_scalar_t__,-1,1>,
                           jacobian__>(0, lp__, nPriorHcauchy_code2);
      Eigen::Matrix<double,-1,1> rawBetaParams =
        Eigen::Matrix<double,-1,1>::Constant(nPriorBeta_code3,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 3;
      rawBetaParams = in__.template read_constrain_lub<
                        Eigen::Matrix<local_scalar_t__,-1,1>, jacobian__>(0,
                        1, lp__, nPriorBeta_code3);
      Eigen::Matrix<double,-1,1> rawTrNormParams =
        Eigen::Matrix<double,-1,1>::Constant(nPriorTrNormal_code4,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 4;
      rawTrNormParams = in__.template read_constrain_lb<
                          Eigen::Matrix<local_scalar_t__,-1,1>,
                          jacobian__>(0, lp__, nPriorTrNormal_code4);
      Eigen::Matrix<double,-1,1> rawExponentialParams =
        Eigen::Matrix<double,-1,1>::Constant(nPriorExponential_code5,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 5;
      rawExponentialParams = in__.template read_constrain_lb<
                               Eigen::Matrix<local_scalar_t__,-1,1>,
                               jacobian__>(0, lp__, nPriorExponential_code5);
      Eigen::Matrix<double,-1,1> rawGammaParams =
        Eigen::Matrix<double,-1,1>::Constant(nPriorGamma_code6,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 6;
      rawGammaParams = in__.template read_constrain_lb<
                         Eigen::Matrix<local_scalar_t__,-1,1>, jacobian__>(0,
                         lp__, nPriorGamma_code6);
      std::vector<double> params =
        std::vector<double>(nParams,
          std::numeric_limits<double>::quiet_NaN());
      std::vector<std::vector<std::vector<double>>> initRefr =
        std::vector<std::vector<std::vector<double>>>(nComps,
          std::vector<std::vector<double>>(2,
            std::vector<double>(nGroups,
              std::numeric_limits<double>::quiet_NaN())));
      std::vector<std::vector<Eigen::Matrix<double,-1,1>>> unmarked =
        std::vector<std::vector<Eigen::Matrix<double,-1,1>>>(nGroups,
          std::vector<Eigen::Matrix<double,-1,1>>(n_quantity_records,
            Eigen::Matrix<double,-1,1>::Constant(nComps,
              std::numeric_limits<double>::quiet_NaN())));
      std::vector<std::vector<Eigen::Matrix<double,-1,1>>> marked =
        std::vector<std::vector<Eigen::Matrix<double,-1,1>>>(nGroups,
          std::vector<Eigen::Matrix<double,-1,1>>(n_quantity_records,
            Eigen::Matrix<double,-1,1>::Constant(nComps,
              std::numeric_limits<double>::quiet_NaN())));
      std::vector<std::vector<double>> sizesPred =
        std::vector<std::vector<double>>(maxNsizesObs,
          std::vector<double>(nGroups,
            std::numeric_limits<double>::quiet_NaN()));
      std::vector<std::vector<double>> propsPred =
        std::vector<std::vector<double>>(maxNpropsObs,
          std::vector<double>(nGroups,
            std::numeric_limits<double>::quiet_NaN()));
      std::vector<std::vector<double>> sizesPred_zeta =
        std::vector<std::vector<double>>(maxNsizesObs,
          std::vector<double>(nGroups,
            std::numeric_limits<double>::quiet_NaN()));
      std::vector<std::vector<double>> sizesPred_alpha =
        std::vector<std::vector<double>>(maxNsizesObs,
          std::vector<double>(nGroups,
            std::numeric_limits<double>::quiet_NaN()));
      std::vector<std::vector<double>> sizesPred_beta =
        std::vector<std::vector<double>>(maxNsizesObs,
          std::vector<double>(nGroups,
            std::numeric_limits<double>::quiet_NaN()));
      std::vector<std::vector<double>> propsPred_eta =
        std::vector<std::vector<double>>(maxNpropsObs,
          std::vector<double>(nGroups,
            std::numeric_limits<double>::quiet_NaN()));
      std::vector<std::vector<double>> propsPred_alpha =
        std::vector<std::vector<double>>(maxNpropsObs,
          std::vector<double>(nGroups,
            std::numeric_limits<double>::quiet_NaN()));
      std::vector<std::vector<double>> propsPred_beta =
        std::vector<std::vector<double>>(maxNpropsObs,
          std::vector<double>(nGroups,
            std::numeric_limits<double>::quiet_NaN()));
      std::vector<Eigen::Matrix<double,-1,-1>> transitions =
        std::vector<Eigen::Matrix<double,-1,-1>>(maxNuniqueDts,
          Eigen::Matrix<double,-1,-1>::Constant(nComps, nComps,
            std::numeric_limits<double>::quiet_NaN()));
      std::vector<Eigen::Matrix<double,-1,-1>> transitionsDecay =
        std::vector<Eigen::Matrix<double,-1,-1>>(maxNuniqueDts,
          Eigen::Matrix<double,-1,-1>::Constant(nComps, nComps,
            std::numeric_limits<double>::quiet_NaN()));
      Eigen::Matrix<double,-1,-1> transfer =
        Eigen::Matrix<double,-1,-1>::Constant(nComps, nComps,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> transferDecay =
        Eigen::Matrix<double,-1,-1>::Constant(nComps, nComps,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> transition_tmp =
        Eigen::Matrix<double,-1,-1>::Constant(nComps, nComps,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> transitionDecay_tmp =
        Eigen::Matrix<double,-1,-1>::Constant(nComps, nComps,
          std::numeric_limits<double>::quiet_NaN());
      std::vector<Eigen::Matrix<double,-1,1>> intervals_init_states_marked =
        std::vector<Eigen::Matrix<double,-1,1>>(maxNtimeIntervals,
          Eigen::Matrix<double,-1,1>::Constant(nComps,
            std::numeric_limits<double>::quiet_NaN()));
      std::vector<Eigen::Matrix<double,-1,1>>
        intervals_init_states_unmarked =
        std::vector<Eigen::Matrix<double,-1,1>>(maxNtimeIntervals,
          Eigen::Matrix<double,-1,1>::Constant(nComps,
            std::numeric_limits<double>::quiet_NaN()));
      out__.write(rawUniformParams);
      out__.write(rawHcauchyParams);
      out__.write(rawBetaParams);
      out__.write(rawTrNormParams);
      out__.write(rawExponentialParams);
      out__.write(rawGammaParams);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      current_statement__ = 8;
      stan::model::assign(initRefr,
        stan::math::rep_array(0.0, nComps, 2, nGroups),
        "assigning variable initRefr");
      current_statement__ = 13;
      stan::model::assign(sizesPred_zeta,
        stan::math::rep_array(0.0, maxNsizesObs, nGroups),
        "assigning variable sizesPred_zeta");
      current_statement__ = 14;
      stan::model::assign(sizesPred_alpha,
        stan::math::rep_array(0.0, maxNsizesObs, nGroups),
        "assigning variable sizesPred_alpha");
      current_statement__ = 15;
      stan::model::assign(sizesPred_beta,
        stan::math::rep_array(0.0, maxNsizesObs, nGroups),
        "assigning variable sizesPred_beta");
      current_statement__ = 16;
      stan::model::assign(propsPred_eta,
        stan::math::rep_array(0.0, maxNpropsObs, nGroups),
        "assigning variable propsPred_eta");
      current_statement__ = 17;
      stan::model::assign(propsPred_alpha,
        stan::math::rep_array(0.0, maxNpropsObs, nGroups),
        "assigning variable propsPred_alpha");
      current_statement__ = 18;
      stan::model::assign(propsPred_beta,
        stan::math::rep_array(0.0, maxNpropsObs, nGroups),
        "assigning variable propsPred_beta");
      {
        int pulseIndex = std::numeric_limits<int>::min();
        current_statement__ = 54;
        for (int i = 1; i <= nParams; ++i) {
          current_statement__ = 34;
          if (stan::math::logical_eq(
                stan::model::rvalue(mappingParamPriorType,
                  "mappingParamPriorType", stan::model::index_uni(i)), 0)) {
            current_statement__ = 32;
            stan::model::assign(params,
              stan::model::rvalue(constantParams, "constantParams",
                stan::model::index_uni(i)), "assigning variable params",
              stan::model::index_uni(i));
          }
          current_statement__ = 37;
          if (stan::math::logical_eq(
                stan::model::rvalue(mappingParamPriorType,
                  "mappingParamPriorType", stan::model::index_uni(i)), 1)) {
            current_statement__ = 35;
            stan::model::assign(params,
              (stan::model::rvalue(lowerParams, "lowerParams",
                 stan::model::index_uni(i)) +
              ((stan::model::rvalue(upperParams, "upperParams",
                  stan::model::index_uni(i)) -
              stan::model::rvalue(lowerParams, "lowerParams",
                stan::model::index_uni(i))) *
              stan::model::rvalue(rawUniformParams, "rawUniformParams",
                stan::model::index_uni(
                  stan::model::rvalue(mappingParamPriorID,
                    "mappingParamPriorID", stan::model::index_uni(i)))))),
              "assigning variable params", stan::model::index_uni(i));
          }
          current_statement__ = 40;
          if (stan::math::logical_eq(
                stan::model::rvalue(mappingParamPriorType,
                  "mappingParamPriorType", stan::model::index_uni(i)), 2)) {
            current_statement__ = 38;
            stan::model::assign(params,
              (stan::model::rvalue(hcauchyScaleParams, "hcauchyScaleParams",
                 stan::model::index_uni(i)) *
              stan::model::rvalue(rawHcauchyParams, "rawHcauchyParams",
                stan::model::index_uni(
                  stan::model::rvalue(mappingParamPriorID,
                    "mappingParamPriorID", stan::model::index_uni(i))))),
              "assigning variable params", stan::model::index_uni(i));
          }
          current_statement__ = 43;
          if (stan::math::logical_eq(
                stan::model::rvalue(mappingParamPriorType,
                  "mappingParamPriorType", stan::model::index_uni(i)), 3)) {
            current_statement__ = 41;
            stan::model::assign(params,
              (stan::model::rvalue(betaScaleParams, "betaScaleParams",
                 stan::model::index_uni(i)) *
              stan::model::rvalue(rawBetaParams, "rawBetaParams",
                stan::model::index_uni(
                  stan::model::rvalue(mappingParamPriorID,
                    "mappingParamPriorID", stan::model::index_uni(i))))),
              "assigning variable params", stan::model::index_uni(i));
          }
          current_statement__ = 46;
          if (stan::math::logical_eq(
                stan::model::rvalue(mappingParamPriorType,
                  "mappingParamPriorType", stan::model::index_uni(i)), 4)) {
            current_statement__ = 44;
            stan::model::assign(params,
              stan::model::rvalue(rawTrNormParams, "rawTrNormParams",
                stan::model::index_uni(
                  stan::model::rvalue(mappingParamPriorID,
                    "mappingParamPriorID", stan::model::index_uni(i)))),
              "assigning variable params", stan::model::index_uni(i));
          }
          current_statement__ = 49;
          if (stan::math::logical_eq(
                stan::model::rvalue(mappingParamPriorType,
                  "mappingParamPriorType", stan::model::index_uni(i)), 5)) {
            current_statement__ = 47;
            stan::model::assign(params,
              stan::model::rvalue(rawExponentialParams,
                "rawExponentialParams",
                stan::model::index_uni(
                  stan::model::rvalue(mappingParamPriorID,
                    "mappingParamPriorID", stan::model::index_uni(i)))),
              "assigning variable params", stan::model::index_uni(i));
          }
          current_statement__ = 52;
          if (stan::math::logical_eq(
                stan::model::rvalue(mappingParamPriorType,
                  "mappingParamPriorType", stan::model::index_uni(i)), 6)) {
            current_statement__ = 50;
            stan::model::assign(params,
              stan::model::rvalue(rawGammaParams, "rawGammaParams",
                stan::model::index_uni(
                  stan::model::rvalue(mappingParamPriorID,
                    "mappingParamPriorID", stan::model::index_uni(i)))),
              "assigning variable params", stan::model::index_uni(i));
          }
        }
        current_statement__ = 185;
        for (int g = 1; g <= nGroups; ++g) {
          current_statement__ = 58;
          if (stan::math::logical_eq(ode_method, 1)) {
            current_statement__ = 55;
            stan::model::assign(transfer,
              buildTransferMatrix(nComps,
                stan::model::rvalue(nSteady, "nSteady",
                  stan::model::index_uni(g)),
                stan::model::rvalue(steadyIndices, "steadyIndices",
                  stan::model::index_omni(), stan::model::index_uni(g)),
                stan::model::rvalue(nUpsilons, "nUpsilons",
                  stan::model::index_uni(g)),
                stan::model::rvalue(upsilonMapping, "upsilonMapping",
                  stan::model::index_omni(), stan::model::index_omni(),
                  stan::model::index_uni(g)),
                stan::model::rvalue(nLambdas, "nLambdas",
                  stan::model::index_uni(g)),
                stan::model::rvalue(lambdaMapping, "lambdaMapping",
                  stan::model::index_omni(), stan::model::index_omni(),
                  stan::model::index_uni(g)), params, pstream__),
              "assigning variable transfer");
            current_statement__ = 56;
            stan::model::assign(transferDecay,
              buildTransferMatrixDecay(nComps, transfer, lambda_decay,
                pstream__), "assigning variable transferDecay");
          }
          current_statement__ = 64;
          if (stan::math::logical_eq(ode_method, 2)) {
            current_statement__ = 62;
            for (int i = 1; i <=
                 stan::model::rvalue(nUniqueDts, "nUniqueDts",
                   stan::model::index_uni(g)); ++i) {
              current_statement__ = 59;
              stan::model::assign(transitions,
                buildTransitionMatrix(nComps,
                  stan::model::rvalue(nUpsilons, "nUpsilons",
                    stan::model::index_uni(g)),
                  stan::model::rvalue(upsilonMapping, "upsilonMapping",
                    stan::model::index_omni(), stan::model::index_omni(),
                    stan::model::index_uni(g)),
                  stan::model::rvalue(nLambdas, "nLambdas",
                    stan::model::index_uni(g)),
                  stan::model::rvalue(lambdaMapping, "lambdaMapping",
                    stan::model::index_omni(), stan::model::index_omni(),
                    stan::model::index_uni(g)),
                  stan::model::rvalue(unique_dts, "unique_dts",
                    stan::model::index_uni(i), stan::model::index_uni(g)),
                  params, pstream__), "assigning variable transitions",
                stan::model::index_uni(i));
              current_statement__ = 60;
              stan::model::assign(transitionsDecay,
                buildTransitionMatrixDecay(nComps,
                  stan::model::rvalue(transitions, "transitions",
                    stan::model::index_uni(i)), lambda_decay,
                  stan::model::rvalue(unique_dts, "unique_dts",
                    stan::model::index_uni(i), stan::model::index_uni(g)),
                  pstream__), "assigning variable transitionsDecay",
                stan::model::index_uni(i));
            }
          }
          current_statement__ = 65;
          pulseIndex = 1;
          current_statement__ = 66;
          stan::model::assign(unmarked,
            stan::math::to_vector(
              stan::model::rvalue(initialQuantities, "initialQuantities",
                stan::model::index_omni(), stan::model::index_uni(1),
                stan::model::index_uni(g))), "assigning variable unmarked",
            stan::model::index_uni(g), stan::model::index_uni(1));
          current_statement__ = 67;
          stan::model::assign(marked,
            stan::math::to_vector(
              stan::model::rvalue(initialQuantities, "initialQuantities",
                stan::model::index_omni(), stan::model::index_uni(2),
                stan::model::index_uni(g))), "assigning variable marked",
            stan::model::index_uni(g), stan::model::index_uni(1));
          current_statement__ = 77;
          if (stan::math::logical_gt(splitPresent, 0)) {
            current_statement__ = 75;
            for (int j = 1; j <= nComps; ++j) {
              current_statement__ = 73;
              if (stan::math::logical_gt(
                    stan::model::rvalue(splitComps, "splitComps",
                      stan::model::index_uni(j), stan::model::index_uni(g)),
                    0)) {
                current_statement__ = 68;
                stan::model::assign(initRefr,
                  (stan::model::rvalue(
                     stan::model::rvalue(unmarked, "unmarked",
                       stan::model::index_uni(g), stan::model::index_uni(1)),
                     "unmarked[g, 1]", stan::model::index_uni(j)) * (1 -
                  stan::model::rvalue(params, "params",
                    stan::model::index_uni(
                      stan::model::rvalue(piMapping, "piMapping",
                        stan::model::index_uni(j), stan::model::index_uni(g)))))),
                  "assigning variable initRefr", stan::model::index_uni(j),
                  stan::model::index_uni(1), stan::model::index_uni(g));
                current_statement__ = 69;
                stan::model::assign(initRefr,
                  (stan::model::rvalue(
                     stan::model::rvalue(marked, "marked",
                       stan::model::index_uni(g), stan::model::index_uni(1)),
                     "marked[g, 1]", stan::model::index_uni(j)) * (1 -
                  stan::model::rvalue(params, "params",
                    stan::model::index_uni(
                      stan::model::rvalue(piMapping, "piMapping",
                        stan::model::index_uni(j), stan::model::index_uni(g)))))),
                  "assigning variable initRefr", stan::model::index_uni(j),
                  stan::model::index_uni(2), stan::model::index_uni(g));
                current_statement__ = 70;
                stan::model::assign(unmarked,
                  (stan::model::rvalue(
                     stan::model::rvalue(unmarked, "unmarked",
                       stan::model::index_uni(g), stan::model::index_uni(1)),
                     "unmarked[g, 1]", stan::model::index_uni(j)) *
                  stan::model::rvalue(params, "params",
                    stan::model::index_uni(
                      stan::model::rvalue(piMapping, "piMapping",
                        stan::model::index_uni(j), stan::model::index_uni(g))))),
                  "assigning variable unmarked", stan::model::index_uni(g),
                  stan::model::index_uni(1), stan::model::index_uni(j));
                current_statement__ = 71;
                stan::model::assign(marked,
                  (stan::model::rvalue(
                     stan::model::rvalue(marked, "marked",
                       stan::model::index_uni(g), stan::model::index_uni(1)),
                     "marked[g, 1]", stan::model::index_uni(j)) *
                  stan::model::rvalue(params, "params",
                    stan::model::index_uni(
                      stan::model::rvalue(piMapping, "piMapping",
                        stan::model::index_uni(j), stan::model::index_uni(g))))),
                  "assigning variable marked", stan::model::index_uni(g),
                  stan::model::index_uni(1), stan::model::index_uni(j));
              }
            }
          }
          current_statement__ = 89;
          if (stan::math::logical_gt(
                stan::model::rvalue(nPulseEvents, "nPulseEvents",
                  stan::model::index_uni(g)), 0)) {
            current_statement__ = 87;
            if (stan::math::logical_lte(pulseIndex,
                  stan::model::rvalue(nPulseEvents, "nPulseEvents",
                    stan::model::index_uni(g)))) {
              current_statement__ = 85;
              while (stan::math::logical_eq(
                       stan::model::rvalue(pulseEventsIndices,
                         "pulseEventsIndices",
                         stan::model::index_uni(pulseIndex),
                         stan::model::index_uni(1), stan::model::index_uni(g)),
                       1)) {
                current_statement__ = 78;
                stan::model::assign(unmarked,
                  (stan::model::rvalue(unmarked, "unmarked",
                     stan::model::index_uni(g), stan::model::index_uni(1),
                     stan::model::index_uni(
                       stan::model::rvalue(pulseEventsIndices,
                         "pulseEventsIndices",
                         stan::model::index_uni(pulseIndex),
                         stan::model::index_uni(2), stan::model::index_uni(g))))
                  +
                  stan::model::rvalue(pulseEventsQuantities,
                    "pulseEventsQuantities",
                    stan::model::index_uni(pulseIndex),
                    stan::model::index_uni(1), stan::model::index_uni(g))),
                  "assigning variable unmarked", stan::model::index_uni(g),
                  stan::model::index_uni(1),
                  stan::model::index_uni(
                    stan::model::rvalue(pulseEventsIndices,
                      "pulseEventsIndices",
                      stan::model::index_uni(pulseIndex),
                      stan::model::index_uni(2), stan::model::index_uni(g))));
                current_statement__ = 79;
                stan::model::assign(marked,
                  (stan::model::rvalue(marked, "marked",
                     stan::model::index_uni(g), stan::model::index_uni(1),
                     stan::model::index_uni(
                       stan::model::rvalue(pulseEventsIndices,
                         "pulseEventsIndices",
                         stan::model::index_uni(pulseIndex),
                         stan::model::index_uni(2), stan::model::index_uni(g))))
                  +
                  stan::model::rvalue(pulseEventsQuantities,
                    "pulseEventsQuantities",
                    stan::model::index_uni(pulseIndex),
                    stan::model::index_uni(2), stan::model::index_uni(g))),
                  "assigning variable marked", stan::model::index_uni(g),
                  stan::model::index_uni(1),
                  stan::model::index_uni(
                    stan::model::rvalue(pulseEventsIndices,
                      "pulseEventsIndices",
                      stan::model::index_uni(pulseIndex),
                      stan::model::index_uni(2), stan::model::index_uni(g))));
                current_statement__ = 80;
                pulseIndex = (pulseIndex + 1);
                current_statement__ = 83;
                if (stan::math::logical_gt(pulseIndex,
                      stan::model::rvalue(nPulseEvents, "nPulseEvents",
                        stan::model::index_uni(g)))) {
                  break;
                }
              }
            }
          }
          current_statement__ = 127;
          if (stan::math::logical_eq(ode_method, 1)) {
            current_statement__ = 90;
            stan::model::assign(intervals_init_states_unmarked,
              stan::model::rvalue(unmarked, "unmarked",
                stan::model::index_uni(g), stan::model::index_uni(1)),
              "assigning variable intervals_init_states_unmarked",
              stan::model::index_uni(1));
            current_statement__ = 91;
            stan::model::assign(intervals_init_states_marked,
              stan::model::rvalue(marked, "marked",
                stan::model::index_uni(g), stan::model::index_uni(1)),
              "assigning variable intervals_init_states_marked",
              stan::model::index_uni(1));
            current_statement__ = 115;
            if (stan::math::logical_gt(
                  stan::model::rvalue(nTimeIntervals, "nTimeIntervals",
                    stan::model::index_uni(g)), 1)) {
              current_statement__ = 113;
              for (int t = 2; t <=
                   stan::model::rvalue(nTimeIntervals, "nTimeIntervals",
                     stan::model::index_uni(g)); ++t) {
                current_statement__ = 92;
                stan::model::assign(transition_tmp,
                  stan::math::matrix_exp(
                    stan::math::multiply(
                      stan::model::rvalue(intervalsLengths,
                        "intervalsLengths", stan::model::index_uni((t - 1)),
                        stan::model::index_uni(g)), transfer)),
                  "assigning variable transition_tmp");
                current_statement__ = 97;
                if (stan::math::logical_eq(lambda_decay, 0)) {
                  current_statement__ = 95;
                  stan::model::assign(transitionDecay_tmp, transition_tmp,
                    "assigning variable transitionDecay_tmp");
                } else {
                  current_statement__ = 93;
                  stan::model::assign(transitionDecay_tmp,
                    stan::math::matrix_exp(
                      stan::math::multiply(
                        stan::model::rvalue(intervalsLengths,
                          "intervalsLengths",
                          stan::model::index_uni((t - 1)),
                          stan::model::index_uni(g)), transferDecay)),
                    "assigning variable transitionDecay_tmp");
                }
                current_statement__ = 98;
                stan::model::assign(intervals_init_states_unmarked,
                  stan::math::multiply(transition_tmp,
                    stan::model::deep_copy(
                      stan::model::rvalue(intervals_init_states_unmarked,
                        "intervals_init_states_unmarked",
                        stan::model::index_uni((t - 1))))),
                  "assigning variable intervals_init_states_unmarked",
                  stan::model::index_uni(t));
                current_statement__ = 99;
                stan::model::assign(intervals_init_states_marked,
                  stan::math::multiply(transitionDecay_tmp,
                    stan::model::deep_copy(
                      stan::model::rvalue(intervals_init_states_marked,
                        "intervals_init_states_marked",
                        stan::model::index_uni((t - 1))))),
                  "assigning variable intervals_init_states_marked",
                  stan::model::index_uni(t));
                current_statement__ = 111;
                if (stan::math::logical_gt(
                      stan::model::rvalue(nPulseEvents, "nPulseEvents",
                        stan::model::index_uni(g)), 0)) {
                  current_statement__ = 109;
                  if (stan::math::logical_lte(pulseIndex,
                        stan::model::rvalue(nPulseEvents, "nPulseEvents",
                          stan::model::index_uni(g)))) {
                    current_statement__ = 107;
                    while (stan::math::logical_eq(
                             stan::model::rvalue(pulseEventsIndices,
                               "pulseEventsIndices",
                               stan::model::index_uni(pulseIndex),
                               stan::model::index_uni(1),
                               stan::model::index_uni(g)), t)) {
                      current_statement__ = 100;
                      stan::model::assign(intervals_init_states_unmarked,
                        (stan::model::rvalue(intervals_init_states_unmarked,
                           "intervals_init_states_unmarked",
                           stan::model::index_uni(t),
                           stan::model::index_uni(
                             stan::model::rvalue(pulseEventsIndices,
                               "pulseEventsIndices",
                               stan::model::index_uni(pulseIndex),
                               stan::model::index_uni(2),
                               stan::model::index_uni(g)))) +
                        stan::model::rvalue(pulseEventsQuantities,
                          "pulseEventsQuantities",
                          stan::model::index_uni(pulseIndex),
                          stan::model::index_uni(1),
                          stan::model::index_uni(g))),
                        "assigning variable intervals_init_states_unmarked",
                        stan::model::index_uni(t),
                        stan::model::index_uni(
                          stan::model::rvalue(pulseEventsIndices,
                            "pulseEventsIndices",
                            stan::model::index_uni(pulseIndex),
                            stan::model::index_uni(2),
                            stan::model::index_uni(g))));
                      current_statement__ = 101;
                      stan::model::assign(intervals_init_states_marked,
                        (stan::model::rvalue(intervals_init_states_marked,
                           "intervals_init_states_marked",
                           stan::model::index_uni(t),
                           stan::model::index_uni(
                             stan::model::rvalue(pulseEventsIndices,
                               "pulseEventsIndices",
                               stan::model::index_uni(pulseIndex),
                               stan::model::index_uni(2),
                               stan::model::index_uni(g)))) +
                        stan::model::rvalue(pulseEventsQuantities,
                          "pulseEventsQuantities",
                          stan::model::index_uni(pulseIndex),
                          stan::model::index_uni(2),
                          stan::model::index_uni(g))),
                        "assigning variable intervals_init_states_marked",
                        stan::model::index_uni(t),
                        stan::model::index_uni(
                          stan::model::rvalue(pulseEventsIndices,
                            "pulseEventsIndices",
                            stan::model::index_uni(pulseIndex),
                            stan::model::index_uni(2),
                            stan::model::index_uni(g))));
                      current_statement__ = 102;
                      pulseIndex = (pulseIndex + 1);
                      current_statement__ = 105;
                      if (stan::math::logical_gt(pulseIndex,
                            stan::model::rvalue(nPulseEvents, "nPulseEvents",
                              stan::model::index_uni(g)))) {
                        break;
                      }
                    }
                  }
                }
              }
            }
            current_statement__ = 125;
            for (int k = 1; k <=
                 stan::model::rvalue(nObsTimes, "nObsTimes",
                   stan::model::index_uni(g)); ++k) {
              current_statement__ = 116;
              stan::model::assign(transition_tmp,
                stan::math::matrix_exp(
                  stan::math::multiply(
                    stan::model::rvalue(elapsedTimeSinceEvent,
                      "elapsedTimeSinceEvent", stan::model::index_uni(g),
                      stan::model::index_uni(k)), transfer)),
                "assigning variable transition_tmp");
              current_statement__ = 121;
              if (stan::math::logical_eq(lambda_decay, 0)) {
                current_statement__ = 119;
                stan::model::assign(transitionDecay_tmp, transition_tmp,
                  "assigning variable transitionDecay_tmp");
              } else {
                current_statement__ = 117;
                stan::model::assign(transitionDecay_tmp,
                  stan::math::matrix_exp(
                    stan::math::multiply(
                      stan::model::rvalue(elapsedTimeSinceEvent,
                        "elapsedTimeSinceEvent", stan::model::index_uni(g),
                        stan::model::index_uni(k)), transferDecay)),
                  "assigning variable transitionDecay_tmp");
              }
              current_statement__ = 122;
              stan::model::assign(unmarked,
                stan::math::multiply(transition_tmp,
                  stan::model::rvalue(intervals_init_states_unmarked,
                    "intervals_init_states_unmarked",
                    stan::model::index_uni(
                      stan::model::rvalue(obsIntervalsIndices,
                        "obsIntervalsIndices", stan::model::index_uni(g),
                        stan::model::index_uni(k))))),
                "assigning variable unmarked", stan::model::index_uni(g),
                stan::model::index_uni(k));
              current_statement__ = 123;
              stan::model::assign(marked,
                stan::math::multiply(transitionDecay_tmp,
                  stan::model::rvalue(intervals_init_states_marked,
                    "intervals_init_states_marked",
                    stan::model::index_uni(
                      stan::model::rvalue(obsIntervalsIndices,
                        "obsIntervalsIndices", stan::model::index_uni(g),
                        stan::model::index_uni(k))))),
                "assigning variable marked", stan::model::index_uni(g),
                stan::model::index_uni(k));
            }
          }
          current_statement__ = 151;
          if (stan::math::logical_eq(ode_method, 2)) {
            current_statement__ = 149;
            for (int t = 1; t <=
                 stan::model::rvalue(nTimesteps, "nTimesteps",
                   stan::model::index_uni(g)); ++t) {
              current_statement__ = 128;
              stan::model::assign(unmarked,
                stan::math::multiply(
                  stan::model::rvalue(transitions, "transitions",
                    stan::model::index_uni(
                      stan::model::rvalue(timesteps, "timesteps",
                        stan::model::index_uni(t), stan::model::index_uni(g)))),
                  stan::model::deep_copy(
                    stan::model::rvalue(unmarked, "unmarked",
                      stan::model::index_uni(g), stan::model::index_uni(t)))),
                "assigning variable unmarked", stan::model::index_uni(g),
                stan::model::index_uni((t + 1)));
              current_statement__ = 129;
              stan::model::assign(marked,
                stan::math::multiply(
                  stan::model::rvalue(transitionsDecay, "transitionsDecay",
                    stan::model::index_uni(
                      stan::model::rvalue(timesteps, "timesteps",
                        stan::model::index_uni(t), stan::model::index_uni(g)))),
                  stan::model::deep_copy(
                    stan::model::rvalue(marked, "marked",
                      stan::model::index_uni(g), stan::model::index_uni(t)))),
                "assigning variable marked", stan::model::index_uni(g),
                stan::model::index_uni((t + 1)));
              current_statement__ = 135;
              if (stan::math::logical_gt(
                    stan::model::rvalue(nSteady, "nSteady",
                      stan::model::index_uni(g)), 0)) {
                current_statement__ = 133;
                for (int k = 1; k <=
                     stan::model::rvalue(nSteady, "nSteady",
                       stan::model::index_uni(g)); ++k) {
                  current_statement__ = 130;
                  stan::model::assign(unmarked,
                    stan::model::rvalue(
                      stan::model::rvalue(unmarked, "unmarked",
                        stan::model::index_uni(g), stan::model::index_uni(t)),
                      "unmarked[g, t]",
                      stan::model::index_uni(
                        stan::model::rvalue(steadyIndices, "steadyIndices",
                          stan::model::index_uni(k),
                          stan::model::index_uni(g)))),
                    "assigning variable unmarked", stan::model::index_uni(g),
                    stan::model::index_uni((t + 1)),
                    stan::model::index_uni(
                      stan::model::rvalue(steadyIndices, "steadyIndices",
                        stan::model::index_uni(k), stan::model::index_uni(g))));
                  current_statement__ = 131;
                  stan::model::assign(marked,
                    stan::model::rvalue(
                      stan::model::rvalue(marked, "marked",
                        stan::model::index_uni(g), stan::model::index_uni(t)),
                      "marked[g, t]",
                      stan::model::index_uni(
                        stan::model::rvalue(steadyIndices, "steadyIndices",
                          stan::model::index_uni(k),
                          stan::model::index_uni(g)))),
                    "assigning variable marked", stan::model::index_uni(g),
                    stan::model::index_uni((t + 1)),
                    stan::model::index_uni(
                      stan::model::rvalue(steadyIndices, "steadyIndices",
                        stan::model::index_uni(k), stan::model::index_uni(g))));
                }
              }
              current_statement__ = 147;
              if (stan::math::logical_gt(
                    stan::model::rvalue(nPulseEvents, "nPulseEvents",
                      stan::model::index_uni(g)), 0)) {
                current_statement__ = 145;
                if (stan::math::logical_lte(pulseIndex,
                      stan::model::rvalue(nPulseEvents, "nPulseEvents",
                        stan::model::index_uni(g)))) {
                  current_statement__ = 143;
                  while (stan::math::logical_eq(
                           stan::model::rvalue(pulseEventsIndices,
                             "pulseEventsIndices",
                             stan::model::index_uni(pulseIndex),
                             stan::model::index_uni(1),
                             stan::model::index_uni(g)), (t + 1))) {
                    current_statement__ = 136;
                    stan::model::assign(unmarked,
                      (stan::model::rvalue(unmarked, "unmarked",
                         stan::model::index_uni(g),
                         stan::model::index_uni((t + 1)),
                         stan::model::index_uni(
                           stan::model::rvalue(pulseEventsIndices,
                             "pulseEventsIndices",
                             stan::model::index_uni(pulseIndex),
                             stan::model::index_uni(2),
                             stan::model::index_uni(g)))) +
                      stan::model::rvalue(pulseEventsQuantities,
                        "pulseEventsQuantities",
                        stan::model::index_uni(pulseIndex),
                        stan::model::index_uni(1), stan::model::index_uni(g))),
                      "assigning variable unmarked",
                      stan::model::index_uni(g),
                      stan::model::index_uni((t + 1)),
                      stan::model::index_uni(
                        stan::model::rvalue(pulseEventsIndices,
                          "pulseEventsIndices",
                          stan::model::index_uni(pulseIndex),
                          stan::model::index_uni(2),
                          stan::model::index_uni(g))));
                    current_statement__ = 137;
                    stan::model::assign(marked,
                      (stan::model::rvalue(marked, "marked",
                         stan::model::index_uni(g),
                         stan::model::index_uni((t + 1)),
                         stan::model::index_uni(
                           stan::model::rvalue(pulseEventsIndices,
                             "pulseEventsIndices",
                             stan::model::index_uni(pulseIndex),
                             stan::model::index_uni(2),
                             stan::model::index_uni(g)))) +
                      stan::model::rvalue(pulseEventsQuantities,
                        "pulseEventsQuantities",
                        stan::model::index_uni(pulseIndex),
                        stan::model::index_uni(2), stan::model::index_uni(g))),
                      "assigning variable marked", stan::model::index_uni(g),
                      stan::model::index_uni((t + 1)),
                      stan::model::index_uni(
                        stan::model::rvalue(pulseEventsIndices,
                          "pulseEventsIndices",
                          stan::model::index_uni(pulseIndex),
                          stan::model::index_uni(2),
                          stan::model::index_uni(g))));
                    current_statement__ = 138;
                    pulseIndex = (pulseIndex + 1);
                    current_statement__ = 141;
                    if (stan::math::logical_gt(pulseIndex,
                          stan::model::rvalue(nPulseEvents, "nPulseEvents",
                            stan::model::index_uni(g)))) {
                      break;
                    }
                  }
                }
              }
            }
          }
          current_statement__ = 152;
          stan::model::assign(sizesPred,
            buildSizePredictions(
              stan::model::rvalue(nSizesObs, "nSizesObs",
                stan::model::index_uni(g)), g, maxNsizesObs,
              stan::model::rvalue(unmarked, "unmarked",
                stan::model::index_uni(g), stan::model::index_omni()),
              stan::model::rvalue(marked, "marked",
                stan::model::index_uni(g), stan::model::index_omni()),
              stan::model::rvalue(sizesObsIndices, "sizesObsIndices",
                stan::model::index_omni(), stan::model::index_omni(),
                stan::model::index_uni(g)), splitPresent,
              stan::model::rvalue(splitComps, "splitComps",
                stan::model::index_omni(), stan::model::index_uni(g)),
              stan::model::rvalue(initRefr, "initRefr",
                stan::model::index_omni(), stan::model::index_omni(),
                stan::model::index_uni(g)), pstream__),
            "assigning variable sizesPred", stan::model::index_omni(),
            stan::model::index_uni(g));
          current_statement__ = 153;
          stan::model::assign(propsPred,
            buildPropPredictions(
              stan::model::rvalue(nPropsObs, "nPropsObs",
                stan::model::index_uni(g)), g, maxNpropsObs,
              stan::model::rvalue(unmarked, "unmarked",
                stan::model::index_uni(g), stan::model::index_omni()),
              stan::model::rvalue(marked, "marked",
                stan::model::index_uni(g), stan::model::index_omni()),
              stan::model::rvalue(propsObsIndices, "propsObsIndices",
                stan::model::index_omni(), stan::model::index_omni(),
                stan::model::index_uni(g)), splitPresent,
              stan::model::rvalue(splitComps, "splitComps",
                stan::model::index_omni(), stan::model::index_uni(g)),
              stan::model::rvalue(initRefr, "initRefr",
                stan::model::index_omni(), stan::model::index_omni(),
                stan::model::index_uni(g)), pstream__),
            "assigning variable propsPred", stan::model::index_omni(),
            stan::model::index_uni(g));
          current_statement__ = 164;
          for (int k = 1; k <=
               stan::model::rvalue(nSizesObs, "nSizesObs",
                 stan::model::index_uni(g)); ++k) {
            current_statement__ = 154;
            stan::model::assign(sizesPred_zeta,
              stan::model::rvalue(params, "params",
                stan::model::index_uni(
                  stan::model::rvalue(sizesObsIndices, "sizesObsIndices",
                    stan::model::index_uni(k), stan::model::index_uni(3),
                    stan::model::index_uni(g)))),
              "assigning variable sizesPred_zeta", stan::model::index_uni(k),
              stan::model::index_uni(g));
            current_statement__ = 158;
            if (stan::math::logical_eq(sizeFamily, 1)) {
              current_statement__ = 155;
              stan::model::assign(sizesPred_alpha,
                stan::model::rvalue(sizesPred, "sizesPred",
                  stan::model::index_uni(k), stan::model::index_uni(g)),
                "assigning variable sizesPred_alpha",
                stan::model::index_uni(k), stan::model::index_uni(g));
              current_statement__ = 156;
              stan::model::assign(sizesPred_beta,
                (stan::model::rvalue(sizesPred_zeta, "sizesPred_zeta",
                   stan::model::index_uni(k), stan::model::index_uni(g)) *
                stan::model::rvalue(sizesPred, "sizesPred",
                  stan::model::index_uni(k), stan::model::index_uni(g))),
                "assigning variable sizesPred_beta",
                stan::model::index_uni(k), stan::model::index_uni(g));
            }
            current_statement__ = 162;
            if (stan::math::logical_eq(sizeFamily, 2)) {
              current_statement__ = 159;
              stan::model::assign(sizesPred_alpha,
                stan::model::rvalue(sizesPred, "sizesPred",
                  stan::model::index_uni(k), stan::model::index_uni(g)),
                "assigning variable sizesPred_alpha",
                stan::model::index_uni(k), stan::model::index_uni(g));
              current_statement__ = 160;
              stan::model::assign(sizesPred_beta,
                stan::model::rvalue(sizesPred_zeta, "sizesPred_zeta",
                  stan::model::index_uni(k), stan::model::index_uni(g)),
                "assigning variable sizesPred_beta",
                stan::model::index_uni(k), stan::model::index_uni(g));
            }
          }
          current_statement__ = 183;
          for (int k = 1; k <=
               stan::model::rvalue(nPropsObs, "nPropsObs",
                 stan::model::index_uni(g)); ++k) {
            current_statement__ = 165;
            stan::model::assign(propsPred_eta,
              stan::model::rvalue(params, "params",
                stan::model::index_uni(
                  stan::model::rvalue(propsObsIndices, "propsObsIndices",
                    stan::model::index_uni(k), stan::model::index_uni(3),
                    stan::model::index_uni(g)))),
              "assigning variable propsPred_eta", stan::model::index_uni(k),
              stan::model::index_uni(g));
            current_statement__ = 169;
            if (stan::math::logical_eq(propFamily, 1)) {
              current_statement__ = 166;
              stan::model::assign(propsPred_alpha,
                stan::math::pow(
                  stan::model::rvalue(propsPred_eta, "propsPred_eta",
                    stan::model::index_uni(k), stan::model::index_uni(g)), -2),
                "assigning variable propsPred_alpha",
                stan::model::index_uni(k), stan::model::index_uni(g));
              current_statement__ = 167;
              stan::model::assign(propsPred_beta,
                (stan::model::rvalue(propsPred_alpha, "propsPred_alpha",
                   stan::model::index_uni(k), stan::model::index_uni(g)) /
                stan::model::rvalue(propsPred, "propsPred",
                  stan::model::index_uni(k), stan::model::index_uni(g))),
                "assigning variable propsPred_beta",
                stan::model::index_uni(k), stan::model::index_uni(g));
            }
            current_statement__ = 173;
            if (stan::math::logical_eq(propFamily, 2)) {
              current_statement__ = 170;
              stan::model::assign(propsPred_alpha,
                stan::model::rvalue(propsPred, "propsPred",
                  stan::model::index_uni(k), stan::model::index_uni(g)),
                "assigning variable propsPred_alpha",
                stan::model::index_uni(k), stan::model::index_uni(g));
              current_statement__ = 171;
              stan::model::assign(propsPred_beta,
                (stan::model::rvalue(propsPred_eta, "propsPred_eta",
                   stan::model::index_uni(k), stan::model::index_uni(g)) *
                stan::model::rvalue(propsPred_alpha, "propsPred_alpha",
                  stan::model::index_uni(k), stan::model::index_uni(g))),
                "assigning variable propsPred_beta",
                stan::model::index_uni(k), stan::model::index_uni(g));
            }
            current_statement__ = 177;
            if (stan::math::logical_eq(propFamily, 3)) {
              current_statement__ = 174;
              stan::model::assign(propsPred_alpha,
                stan::model::rvalue(propsPred, "propsPred",
                  stan::model::index_uni(k), stan::model::index_uni(g)),
                "assigning variable propsPred_alpha",
                stan::model::index_uni(k), stan::model::index_uni(g));
              current_statement__ = 175;
              stan::model::assign(propsPred_beta,
                stan::model::rvalue(propsPred_eta, "propsPred_eta",
                  stan::model::index_uni(k), stan::model::index_uni(g)),
                "assigning variable propsPred_beta",
                stan::model::index_uni(k), stan::model::index_uni(g));
            }
            current_statement__ = 181;
            if (stan::math::logical_eq(propFamily, 4)) {
              current_statement__ = 178;
              stan::model::assign(propsPred_alpha,
                (stan::model::rvalue(propsPred, "propsPred",
                   stan::model::index_uni(k), stan::model::index_uni(g)) *
                stan::model::rvalue(propsPred_eta, "propsPred_eta",
                  stan::model::index_uni(k), stan::model::index_uni(g))),
                "assigning variable propsPred_alpha",
                stan::model::index_uni(k), stan::model::index_uni(g));
              current_statement__ = 179;
              stan::model::assign(propsPred_beta,
                (stan::model::rvalue(propsPred_eta, "propsPred_eta",
                   stan::model::index_uni(k), stan::model::index_uni(g)) * (1
                -
                stan::model::rvalue(propsPred, "propsPred",
                  stan::model::index_uni(k), stan::model::index_uni(g)))),
                "assigning variable propsPred_beta",
                stan::model::index_uni(k), stan::model::index_uni(g));
            }
          }
        }
      }
      current_statement__ = 7;
      stan::math::check_greater_or_equal(function__, "params", params, 0);
      current_statement__ = 8;
      stan::math::check_greater_or_equal(function__, "initRefr", initRefr, 0);
      current_statement__ = 11;
      stan::math::check_greater_or_equal(function__, "sizesPred", sizesPred,
        0);
      current_statement__ = 12;
      stan::math::check_greater_or_equal(function__, "propsPred", propsPred,
        0);
      current_statement__ = 13;
      stan::math::check_greater_or_equal(function__, "sizesPred_zeta",
        sizesPred_zeta, 0);
      current_statement__ = 14;
      stan::math::check_greater_or_equal(function__, "sizesPred_alpha",
        sizesPred_alpha, 0);
      current_statement__ = 15;
      stan::math::check_greater_or_equal(function__, "sizesPred_beta",
        sizesPred_beta, 0);
      current_statement__ = 16;
      stan::math::check_greater_or_equal(function__, "propsPred_eta",
        propsPred_eta, 0);
      current_statement__ = 17;
      stan::math::check_greater_or_equal(function__, "propsPred_alpha",
        propsPred_alpha, 0);
      current_statement__ = 18;
      stan::math::check_greater_or_equal(function__, "propsPred_beta",
        propsPred_beta, 0);
      if (emit_transformed_parameters__) {
        out__.write(params);
        for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= nComps; ++sym3__) {
              out__.write(initRefr[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);
            }
          }
        }
        for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= n_quantity_records; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= nGroups; ++sym3__) {
              out__.write(unmarked[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);
            }
          }
        }
        for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= n_quantity_records; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= nGroups; ++sym3__) {
              out__.write(marked[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);
            }
          }
        }
        for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= maxNsizesObs; ++sym2__) {
            out__.write(sizesPred[(sym2__ - 1)][(sym1__ - 1)]);
          }
        }
        for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= maxNpropsObs; ++sym2__) {
            out__.write(propsPred[(sym2__ - 1)][(sym1__ - 1)]);
          }
        }
        for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= maxNsizesObs; ++sym2__) {
            out__.write(sizesPred_zeta[(sym2__ - 1)][(sym1__ - 1)]);
          }
        }
        for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= maxNsizesObs; ++sym2__) {
            out__.write(sizesPred_alpha[(sym2__ - 1)][(sym1__ - 1)]);
          }
        }
        for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= maxNsizesObs; ++sym2__) {
            out__.write(sizesPred_beta[(sym2__ - 1)][(sym1__ - 1)]);
          }
        }
        for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= maxNpropsObs; ++sym2__) {
            out__.write(propsPred_eta[(sym2__ - 1)][(sym1__ - 1)]);
          }
        }
        for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= maxNpropsObs; ++sym2__) {
            out__.write(propsPred_alpha[(sym2__ - 1)][(sym1__ - 1)]);
          }
        }
        for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= maxNpropsObs; ++sym2__) {
            out__.write(propsPred_beta[(sym2__ - 1)][(sym1__ - 1)]);
          }
        }
        for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= nComps; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= maxNuniqueDts; ++sym3__) {
              out__.write(stan::model::rvalue(transitions, "transitions",
                            stan::model::index_uni(sym3__),
                            stan::model::index_uni(sym2__),
                            stan::model::index_uni(sym1__)));
            }
          }
        }
        for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= nComps; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= maxNuniqueDts; ++sym3__) {
              out__.write(stan::model::rvalue(transitionsDecay,
                            "transitionsDecay",
                            stan::model::index_uni(sym3__),
                            stan::model::index_uni(sym2__),
                            stan::model::index_uni(sym1__)));
            }
          }
        }
        out__.write(transfer);
        out__.write(transferDecay);
        out__.write(transition_tmp);
        out__.write(transitionDecay_tmp);
        for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= maxNtimeIntervals; ++sym2__) {
            out__.write(intervals_init_states_marked[(sym2__ - 1)][(sym1__ -
              1)]);
          }
        }
        for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= maxNtimeIntervals; ++sym2__) {
            out__.write(intervals_init_states_unmarked[(sym2__ - 1)][(sym1__
              - 1)]);
          }
        }
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
      Eigen::Matrix<double,-1,1> nonConstantParams =
        Eigen::Matrix<double,-1,1>::Constant(nNonConstantPriors,
          std::numeric_limits<double>::quiet_NaN());
      int paramIndex = std::numeric_limits<int>::min();
      Eigen::Matrix<double,-1,1> log_lik =
        Eigen::Matrix<double,-1,1>::Constant(nTotal,
          std::numeric_limits<double>::quiet_NaN());
      int llIndexShift = std::numeric_limits<int>::min();
      current_statement__ = 187;
      llIndexShift = 0;
      current_statement__ = 188;
      paramIndex = 1;
      current_statement__ = 194;
      for (int i = 1; i <= nParams; ++i) {
        current_statement__ = 192;
        if (stan::math::logical_neq(
              stan::model::rvalue(mappingParamPriorType,
                "mappingParamPriorType", stan::model::index_uni(i)), 0)) {
          current_statement__ = 189;
          stan::model::assign(nonConstantParams,
            stan::model::rvalue(params, "params", stan::model::index_uni(i)),
            "assigning variable nonConstantParams",
            stan::model::index_uni(paramIndex));
          current_statement__ = 190;
          paramIndex = (paramIndex + 1);
        }
      }
      current_statement__ = 205;
      for (int g = 1; g <= nGroups; ++g) {
        current_statement__ = 202;
        for (int o = 1; o <=
             stan::model::rvalue(nSizesObs, "nSizesObs",
               stan::model::index_uni(g)); ++o) {
          current_statement__ = 197;
          if (stan::math::logical_eq(sizeFamily, 1)) {
            current_statement__ = 195;
            stan::model::assign(log_lik,
              stan::math::normal_lpdf<false>(
                stan::model::rvalue(sizesObs, "sizesObs",
                  stan::model::index_uni(o), stan::model::index_uni(g)),
                stan::model::rvalue(sizesPred_alpha, "sizesPred_alpha",
                  stan::model::index_uni(o), stan::model::index_uni(g)),
                stan::model::rvalue(sizesPred_beta, "sizesPred_beta",
                  stan::model::index_uni(o), stan::model::index_uni(g))),
              "assigning variable log_lik",
              stan::model::index_uni((o + llIndexShift)));
          }
          current_statement__ = 200;
          if (stan::math::logical_eq(sizeFamily, 2)) {
            current_statement__ = 198;
            stan::model::assign(log_lik,
              stan::math::normal_lpdf<false>(
                stan::model::rvalue(sizesObs, "sizesObs",
                  stan::model::index_uni(o), stan::model::index_uni(g)),
                stan::model::rvalue(sizesPred_alpha, "sizesPred_alpha",
                  stan::model::index_uni(o), stan::model::index_uni(g)),
                stan::model::rvalue(sizesPred_beta, "sizesPred_beta",
                  stan::model::index_uni(o), stan::model::index_uni(g))),
              "assigning variable log_lik",
              stan::model::index_uni((o + llIndexShift)));
          }
        }
        current_statement__ = 203;
        llIndexShift = (llIndexShift +
          stan::model::rvalue(nSizesObs, "nSizesObs",
            stan::model::index_uni(g)));
      }
      current_statement__ = 222;
      for (int g = 1; g <= nGroups; ++g) {
        current_statement__ = 219;
        for (int o = 1; o <=
             stan::model::rvalue(nPropsObs, "nPropsObs",
               stan::model::index_uni(g)); ++o) {
          current_statement__ = 208;
          if (stan::math::logical_eq(propFamily, 1)) {
            current_statement__ = 206;
            stan::model::assign(log_lik,
              stan::math::gamma_lpdf<false>(
                stan::model::rvalue(propsObs, "propsObs",
                  stan::model::index_uni(o), stan::model::index_uni(g)),
                stan::model::rvalue(propsPred_alpha, "propsPred_alpha",
                  stan::model::index_uni(o), stan::model::index_uni(g)),
                stan::model::rvalue(propsPred_beta, "propsPred_beta",
                  stan::model::index_uni(o), stan::model::index_uni(g))),
              "assigning variable log_lik",
              stan::model::index_uni((o + llIndexShift)));
          }
          current_statement__ = 211;
          if (stan::math::logical_eq(propFamily, 2)) {
            current_statement__ = 209;
            stan::model::assign(log_lik,
              stan::math::normal_lpdf<false>(
                stan::model::rvalue(propsObs, "propsObs",
                  stan::model::index_uni(o), stan::model::index_uni(g)),
                stan::model::rvalue(propsPred_alpha, "propsPred_alpha",
                  stan::model::index_uni(o), stan::model::index_uni(g)),
                stan::model::rvalue(propsPred_beta, "propsPred_beta",
                  stan::model::index_uni(o), stan::model::index_uni(g))),
              "assigning variable log_lik",
              stan::model::index_uni((o + llIndexShift)));
          }
          current_statement__ = 214;
          if (stan::math::logical_eq(propFamily, 3)) {
            current_statement__ = 212;
            stan::model::assign(log_lik,
              stan::math::normal_lpdf<false>(
                stan::model::rvalue(propsObs, "propsObs",
                  stan::model::index_uni(o), stan::model::index_uni(g)),
                stan::model::rvalue(propsPred_alpha, "propsPred_alpha",
                  stan::model::index_uni(o), stan::model::index_uni(g)),
                stan::model::rvalue(propsPred_beta, "propsPred_beta",
                  stan::model::index_uni(o), stan::model::index_uni(g))),
              "assigning variable log_lik",
              stan::model::index_uni((o + llIndexShift)));
          }
          current_statement__ = 217;
          if (stan::math::logical_eq(propFamily, 4)) {
            current_statement__ = 215;
            stan::model::assign(log_lik,
              stan::math::beta_lpdf<false>(
                stan::model::rvalue(propsObs, "propsObs",
                  stan::model::index_uni(o), stan::model::index_uni(g)),
                stan::model::rvalue(propsPred_alpha, "propsPred_alpha",
                  stan::model::index_uni(o), stan::model::index_uni(g)),
                stan::model::rvalue(propsPred_beta, "propsPred_beta",
                  stan::model::index_uni(o), stan::model::index_uni(g))),
              "assigning variable log_lik",
              stan::model::index_uni((o + llIndexShift)));
          }
        }
        current_statement__ = 220;
        llIndexShift = (llIndexShift +
          stan::model::rvalue(nPropsObs, "nPropsObs",
            stan::model::index_uni(g)));
      }
      out__.write(nonConstantParams);
      out__.write(paramIndex);
      out__.write(log_lik);
      out__.write(llIndexShift);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      Eigen::Matrix<local_scalar_t__,-1,1> rawUniformParams =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(nPriorUniform_code1,
          DUMMY_VAR__);
      current_statement__ = 1;
      stan::model::assign(rawUniformParams,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(nPriorUniform_code1),
        "assigning variable rawUniformParams");
      out__.write_free_lub(0, 1, rawUniformParams);
      Eigen::Matrix<local_scalar_t__,-1,1> rawHcauchyParams =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(nPriorHcauchy_code2,
          DUMMY_VAR__);
      current_statement__ = 2;
      stan::model::assign(rawHcauchyParams,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(nPriorHcauchy_code2),
        "assigning variable rawHcauchyParams");
      out__.write_free_lb(0, rawHcauchyParams);
      Eigen::Matrix<local_scalar_t__,-1,1> rawBetaParams =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(nPriorBeta_code3,
          DUMMY_VAR__);
      current_statement__ = 3;
      stan::model::assign(rawBetaParams,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(nPriorBeta_code3),
        "assigning variable rawBetaParams");
      out__.write_free_lub(0, 1, rawBetaParams);
      Eigen::Matrix<local_scalar_t__,-1,1> rawTrNormParams =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(nPriorTrNormal_code4,
          DUMMY_VAR__);
      current_statement__ = 4;
      stan::model::assign(rawTrNormParams,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(nPriorTrNormal_code4),
        "assigning variable rawTrNormParams");
      out__.write_free_lb(0, rawTrNormParams);
      Eigen::Matrix<local_scalar_t__,-1,1> rawExponentialParams =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(nPriorExponential_code5,
          DUMMY_VAR__);
      current_statement__ = 5;
      stan::model::assign(rawExponentialParams,
        in__.read<
          Eigen::Matrix<local_scalar_t__,-1,1>>(nPriorExponential_code5),
        "assigning variable rawExponentialParams");
      out__.write_free_lb(0, rawExponentialParams);
      Eigen::Matrix<local_scalar_t__,-1,1> rawGammaParams =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(nPriorGamma_code6,
          DUMMY_VAR__);
      current_statement__ = 6;
      stan::model::assign(rawGammaParams,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(nPriorGamma_code6),
        "assigning variable rawGammaParams");
      out__.write_free_lb(0, rawGammaParams);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "rawUniformParams",
        "double",
        std::vector<size_t>{static_cast<size_t>(nPriorUniform_code1)});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "rawHcauchyParams",
        "double",
        std::vector<size_t>{static_cast<size_t>(nPriorHcauchy_code2)});
      current_statement__ = 3;
      context__.validate_dims("parameter initialization", "rawBetaParams",
        "double", std::vector<size_t>{static_cast<size_t>(nPriorBeta_code3)});
      current_statement__ = 4;
      context__.validate_dims("parameter initialization", "rawTrNormParams",
        "double",
        std::vector<size_t>{static_cast<size_t>(nPriorTrNormal_code4)});
      current_statement__ = 5;
      context__.validate_dims("parameter initialization",
        "rawExponentialParams", "double",
        std::vector<size_t>{static_cast<size_t>(nPriorExponential_code5)});
      current_statement__ = 6;
      context__.validate_dims("parameter initialization", "rawGammaParams",
        "double",
        std::vector<size_t>{static_cast<size_t>(nPriorGamma_code6)});
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      Eigen::Matrix<local_scalar_t__,-1,1> rawUniformParams =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(nPriorUniform_code1,
          DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> rawUniformParams_flat__;
        current_statement__ = 1;
        rawUniformParams_flat__ = context__.vals_r("rawUniformParams");
        current_statement__ = 1;
        pos__ = 1;
        current_statement__ = 1;
        for (int sym1__ = 1; sym1__ <= nPriorUniform_code1; ++sym1__) {
          current_statement__ = 1;
          stan::model::assign(rawUniformParams,
            rawUniformParams_flat__[(pos__ - 1)],
            "assigning variable rawUniformParams",
            stan::model::index_uni(sym1__));
          current_statement__ = 1;
          pos__ = (pos__ + 1);
        }
      }
      out__.write_free_lub(0, 1, rawUniformParams);
      Eigen::Matrix<local_scalar_t__,-1,1> rawHcauchyParams =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(nPriorHcauchy_code2,
          DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> rawHcauchyParams_flat__;
        current_statement__ = 2;
        rawHcauchyParams_flat__ = context__.vals_r("rawHcauchyParams");
        current_statement__ = 2;
        pos__ = 1;
        current_statement__ = 2;
        for (int sym1__ = 1; sym1__ <= nPriorHcauchy_code2; ++sym1__) {
          current_statement__ = 2;
          stan::model::assign(rawHcauchyParams,
            rawHcauchyParams_flat__[(pos__ - 1)],
            "assigning variable rawHcauchyParams",
            stan::model::index_uni(sym1__));
          current_statement__ = 2;
          pos__ = (pos__ + 1);
        }
      }
      out__.write_free_lb(0, rawHcauchyParams);
      Eigen::Matrix<local_scalar_t__,-1,1> rawBetaParams =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(nPriorBeta_code3,
          DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> rawBetaParams_flat__;
        current_statement__ = 3;
        rawBetaParams_flat__ = context__.vals_r("rawBetaParams");
        current_statement__ = 3;
        pos__ = 1;
        current_statement__ = 3;
        for (int sym1__ = 1; sym1__ <= nPriorBeta_code3; ++sym1__) {
          current_statement__ = 3;
          stan::model::assign(rawBetaParams, rawBetaParams_flat__[(pos__ -
            1)], "assigning variable rawBetaParams",
            stan::model::index_uni(sym1__));
          current_statement__ = 3;
          pos__ = (pos__ + 1);
        }
      }
      out__.write_free_lub(0, 1, rawBetaParams);
      Eigen::Matrix<local_scalar_t__,-1,1> rawTrNormParams =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(nPriorTrNormal_code4,
          DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> rawTrNormParams_flat__;
        current_statement__ = 4;
        rawTrNormParams_flat__ = context__.vals_r("rawTrNormParams");
        current_statement__ = 4;
        pos__ = 1;
        current_statement__ = 4;
        for (int sym1__ = 1; sym1__ <= nPriorTrNormal_code4; ++sym1__) {
          current_statement__ = 4;
          stan::model::assign(rawTrNormParams, rawTrNormParams_flat__[(pos__
            - 1)], "assigning variable rawTrNormParams",
            stan::model::index_uni(sym1__));
          current_statement__ = 4;
          pos__ = (pos__ + 1);
        }
      }
      out__.write_free_lb(0, rawTrNormParams);
      Eigen::Matrix<local_scalar_t__,-1,1> rawExponentialParams =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(nPriorExponential_code5,
          DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> rawExponentialParams_flat__;
        current_statement__ = 5;
        rawExponentialParams_flat__ = context__.vals_r("rawExponentialParams");
        current_statement__ = 5;
        pos__ = 1;
        current_statement__ = 5;
        for (int sym1__ = 1; sym1__ <= nPriorExponential_code5; ++sym1__) {
          current_statement__ = 5;
          stan::model::assign(rawExponentialParams,
            rawExponentialParams_flat__[(pos__ - 1)],
            "assigning variable rawExponentialParams",
            stan::model::index_uni(sym1__));
          current_statement__ = 5;
          pos__ = (pos__ + 1);
        }
      }
      out__.write_free_lb(0, rawExponentialParams);
      Eigen::Matrix<local_scalar_t__,-1,1> rawGammaParams =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(nPriorGamma_code6,
          DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> rawGammaParams_flat__;
        current_statement__ = 6;
        rawGammaParams_flat__ = context__.vals_r("rawGammaParams");
        current_statement__ = 6;
        pos__ = 1;
        current_statement__ = 6;
        for (int sym1__ = 1; sym1__ <= nPriorGamma_code6; ++sym1__) {
          current_statement__ = 6;
          stan::model::assign(rawGammaParams, rawGammaParams_flat__[(pos__ -
            1)], "assigning variable rawGammaParams",
            stan::model::index_uni(sym1__));
          current_statement__ = 6;
          pos__ = (pos__ + 1);
        }
      }
      out__.write_free_lb(0, rawGammaParams);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"rawUniformParams",
                "rawHcauchyParams", "rawBetaParams", "rawTrNormParams",
                "rawExponentialParams", "rawGammaParams"};
    if (emit_transformed_parameters__) {
      std::vector<std::string>
        temp{"params", "initRefr", "unmarked", "marked", "sizesPred",
             "propsPred", "sizesPred_zeta", "sizesPred_alpha",
             "sizesPred_beta", "propsPred_eta", "propsPred_alpha",
             "propsPred_beta", "transitions", "transitionsDecay", "transfer",
             "transferDecay", "transition_tmp", "transitionDecay_tmp",
             "intervals_init_states_marked", "intervals_init_states_unmarked"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {
      std::vector<std::string>
        temp{"nonConstantParams", "paramIndex", "log_lik", "llIndexShift"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{static_cast<
                                                                    size_t>(
                                                                    nPriorUniform_code1)},
                std::vector<size_t>{static_cast<size_t>(nPriorHcauchy_code2)},
                std::vector<size_t>{static_cast<size_t>(nPriorBeta_code3)},
                std::vector<size_t>{static_cast<size_t>(nPriorTrNormal_code4)},
                std::vector<size_t>{static_cast<size_t>(
                                      nPriorExponential_code5)},
                std::vector<size_t>{static_cast<size_t>(nPriorGamma_code6)}};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{static_cast<size_t>(nParams)},
             std::vector<size_t>{static_cast<size_t>(nComps),
               static_cast<size_t>(2), static_cast<size_t>(nGroups)},
             std::vector<size_t>{static_cast<size_t>(nGroups),
               static_cast<size_t>(n_quantity_records),
               static_cast<size_t>(nComps)},
             std::vector<size_t>{static_cast<size_t>(nGroups),
               static_cast<size_t>(n_quantity_records),
               static_cast<size_t>(nComps)},
             std::vector<size_t>{static_cast<size_t>(maxNsizesObs),
               static_cast<size_t>(nGroups)},
             std::vector<size_t>{static_cast<size_t>(maxNpropsObs),
               static_cast<size_t>(nGroups)},
             std::vector<size_t>{static_cast<size_t>(maxNsizesObs),
               static_cast<size_t>(nGroups)},
             std::vector<size_t>{static_cast<size_t>(maxNsizesObs),
               static_cast<size_t>(nGroups)},
             std::vector<size_t>{static_cast<size_t>(maxNsizesObs),
               static_cast<size_t>(nGroups)},
             std::vector<size_t>{static_cast<size_t>(maxNpropsObs),
               static_cast<size_t>(nGroups)},
             std::vector<size_t>{static_cast<size_t>(maxNpropsObs),
               static_cast<size_t>(nGroups)},
             std::vector<size_t>{static_cast<size_t>(maxNpropsObs),
               static_cast<size_t>(nGroups)},
             std::vector<size_t>{static_cast<size_t>(maxNuniqueDts),
               static_cast<size_t>(nComps), static_cast<size_t>(nComps)},
             std::vector<size_t>{static_cast<size_t>(maxNuniqueDts),
               static_cast<size_t>(nComps), static_cast<size_t>(nComps)},
             std::vector<size_t>{static_cast<size_t>(nComps),
               static_cast<size_t>(nComps)},
             std::vector<size_t>{static_cast<size_t>(nComps),
               static_cast<size_t>(nComps)},
             std::vector<size_t>{static_cast<size_t>(nComps),
               static_cast<size_t>(nComps)},
             std::vector<size_t>{static_cast<size_t>(nComps),
               static_cast<size_t>(nComps)},
             std::vector<size_t>{static_cast<size_t>(maxNtimeIntervals),
               static_cast<size_t>(nComps)},
             std::vector<size_t>{static_cast<size_t>(maxNtimeIntervals),
               static_cast<size_t>(nComps)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{static_cast<size_t>(nNonConstantPriors)},
             std::vector<size_t>{},
             std::vector<size_t>{static_cast<size_t>(nTotal)},
             std::vector<size_t>{}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    for (int sym1__ = 1; sym1__ <= nPriorUniform_code1; ++sym1__) {
      param_names__.emplace_back(std::string() + "rawUniformParams" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= nPriorHcauchy_code2; ++sym1__) {
      param_names__.emplace_back(std::string() + "rawHcauchyParams" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= nPriorBeta_code3; ++sym1__) {
      param_names__.emplace_back(std::string() + "rawBetaParams" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= nPriorTrNormal_code4; ++sym1__) {
      param_names__.emplace_back(std::string() + "rawTrNormParams" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= nPriorExponential_code5; ++sym1__) {
      param_names__.emplace_back(std::string() + "rawExponentialParams" + '.'
        + std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= nPriorGamma_code6; ++sym1__) {
      param_names__.emplace_back(std::string() + "rawGammaParams" + '.' +
        std::to_string(sym1__));
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= nParams; ++sym1__) {
        param_names__.emplace_back(std::string() + "params" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= nComps; ++sym3__) {
            param_names__.emplace_back(std::string() + "initRefr" + '.' +
              std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
              std::to_string(sym1__));
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= n_quantity_records; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= nGroups; ++sym3__) {
            param_names__.emplace_back(std::string() + "unmarked" + '.' +
              std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
              std::to_string(sym1__));
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= n_quantity_records; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= nGroups; ++sym3__) {
            param_names__.emplace_back(std::string() + "marked" + '.' +
              std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
              std::to_string(sym1__));
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= maxNsizesObs; ++sym2__) {
          param_names__.emplace_back(std::string() + "sizesPred" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= maxNpropsObs; ++sym2__) {
          param_names__.emplace_back(std::string() + "propsPred" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= maxNsizesObs; ++sym2__) {
          param_names__.emplace_back(std::string() + "sizesPred_zeta" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= maxNsizesObs; ++sym2__) {
          param_names__.emplace_back(std::string() + "sizesPred_alpha" + '.'
            + std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= maxNsizesObs; ++sym2__) {
          param_names__.emplace_back(std::string() + "sizesPred_beta" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= maxNpropsObs; ++sym2__) {
          param_names__.emplace_back(std::string() + "propsPred_eta" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= maxNpropsObs; ++sym2__) {
          param_names__.emplace_back(std::string() + "propsPred_alpha" + '.'
            + std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= maxNpropsObs; ++sym2__) {
          param_names__.emplace_back(std::string() + "propsPred_beta" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= nComps; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= maxNuniqueDts; ++sym3__) {
            param_names__.emplace_back(std::string() + "transitions" + '.' +
              std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
              std::to_string(sym1__));
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= nComps; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= maxNuniqueDts; ++sym3__) {
            param_names__.emplace_back(std::string() + "transitionsDecay" +
              '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) +
              '.' + std::to_string(sym1__));
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= nComps; ++sym2__) {
          param_names__.emplace_back(std::string() + "transfer" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= nComps; ++sym2__) {
          param_names__.emplace_back(std::string() + "transferDecay" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= nComps; ++sym2__) {
          param_names__.emplace_back(std::string() + "transition_tmp" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= nComps; ++sym2__) {
          param_names__.emplace_back(std::string() + "transitionDecay_tmp" +
            '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= maxNtimeIntervals; ++sym2__) {
          param_names__.emplace_back(std::string() +
            "intervals_init_states_marked" + '.' + std::to_string(sym2__) +
            '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= maxNtimeIntervals; ++sym2__) {
          param_names__.emplace_back(std::string() +
            "intervals_init_states_unmarked" + '.' + std::to_string(sym2__) +
            '.' + std::to_string(sym1__));
        }
      }
    }
    if (emit_generated_quantities__) {
      for (int sym1__ = 1; sym1__ <= nNonConstantPriors; ++sym1__) {
        param_names__.emplace_back(std::string() + "nonConstantParams" + '.'
          + std::to_string(sym1__));
      }
      param_names__.emplace_back(std::string() + "paramIndex");
      for (int sym1__ = 1; sym1__ <= nTotal; ++sym1__) {
        param_names__.emplace_back(std::string() + "log_lik" + '.' +
          std::to_string(sym1__));
      }
      param_names__.emplace_back(std::string() + "llIndexShift");
    }
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    for (int sym1__ = 1; sym1__ <= nPriorUniform_code1; ++sym1__) {
      param_names__.emplace_back(std::string() + "rawUniformParams" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= nPriorHcauchy_code2; ++sym1__) {
      param_names__.emplace_back(std::string() + "rawHcauchyParams" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= nPriorBeta_code3; ++sym1__) {
      param_names__.emplace_back(std::string() + "rawBetaParams" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= nPriorTrNormal_code4; ++sym1__) {
      param_names__.emplace_back(std::string() + "rawTrNormParams" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= nPriorExponential_code5; ++sym1__) {
      param_names__.emplace_back(std::string() + "rawExponentialParams" + '.'
        + std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= nPriorGamma_code6; ++sym1__) {
      param_names__.emplace_back(std::string() + "rawGammaParams" + '.' +
        std::to_string(sym1__));
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= nParams; ++sym1__) {
        param_names__.emplace_back(std::string() + "params" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= nComps; ++sym3__) {
            param_names__.emplace_back(std::string() + "initRefr" + '.' +
              std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
              std::to_string(sym1__));
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= n_quantity_records; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= nGroups; ++sym3__) {
            param_names__.emplace_back(std::string() + "unmarked" + '.' +
              std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
              std::to_string(sym1__));
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= n_quantity_records; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= nGroups; ++sym3__) {
            param_names__.emplace_back(std::string() + "marked" + '.' +
              std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
              std::to_string(sym1__));
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= maxNsizesObs; ++sym2__) {
          param_names__.emplace_back(std::string() + "sizesPred" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= maxNpropsObs; ++sym2__) {
          param_names__.emplace_back(std::string() + "propsPred" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= maxNsizesObs; ++sym2__) {
          param_names__.emplace_back(std::string() + "sizesPred_zeta" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= maxNsizesObs; ++sym2__) {
          param_names__.emplace_back(std::string() + "sizesPred_alpha" + '.'
            + std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= maxNsizesObs; ++sym2__) {
          param_names__.emplace_back(std::string() + "sizesPred_beta" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= maxNpropsObs; ++sym2__) {
          param_names__.emplace_back(std::string() + "propsPred_eta" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= maxNpropsObs; ++sym2__) {
          param_names__.emplace_back(std::string() + "propsPred_alpha" + '.'
            + std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= maxNpropsObs; ++sym2__) {
          param_names__.emplace_back(std::string() + "propsPred_beta" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= nComps; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= maxNuniqueDts; ++sym3__) {
            param_names__.emplace_back(std::string() + "transitions" + '.' +
              std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
              std::to_string(sym1__));
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= nComps; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= maxNuniqueDts; ++sym3__) {
            param_names__.emplace_back(std::string() + "transitionsDecay" +
              '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) +
              '.' + std::to_string(sym1__));
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= nComps; ++sym2__) {
          param_names__.emplace_back(std::string() + "transfer" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= nComps; ++sym2__) {
          param_names__.emplace_back(std::string() + "transferDecay" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= nComps; ++sym2__) {
          param_names__.emplace_back(std::string() + "transition_tmp" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= nComps; ++sym2__) {
          param_names__.emplace_back(std::string() + "transitionDecay_tmp" +
            '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= maxNtimeIntervals; ++sym2__) {
          param_names__.emplace_back(std::string() +
            "intervals_init_states_marked" + '.' + std::to_string(sym2__) +
            '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= maxNtimeIntervals; ++sym2__) {
          param_names__.emplace_back(std::string() +
            "intervals_init_states_unmarked" + '.' + std::to_string(sym2__) +
            '.' + std::to_string(sym1__));
        }
      }
    }
    if (emit_generated_quantities__) {
      for (int sym1__ = 1; sym1__ <= nNonConstantPriors; ++sym1__) {
        param_names__.emplace_back(std::string() + "nonConstantParams" + '.'
          + std::to_string(sym1__));
      }
      param_names__.emplace_back(std::string() + "paramIndex");
      for (int sym1__ = 1; sym1__ <= nTotal; ++sym1__) {
        param_names__.emplace_back(std::string() + "log_lik" + '.' +
          std::to_string(sym1__));
      }
      param_names__.emplace_back(std::string() + "llIndexShift");
    }
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"rawUniformParams\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(nPriorUniform_code1) + "},\"block\":\"parameters\"},{\"name\":\"rawHcauchyParams\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(nPriorHcauchy_code2) + "},\"block\":\"parameters\"},{\"name\":\"rawBetaParams\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(nPriorBeta_code3) + "},\"block\":\"parameters\"},{\"name\":\"rawTrNormParams\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(nPriorTrNormal_code4) + "},\"block\":\"parameters\"},{\"name\":\"rawExponentialParams\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(nPriorExponential_code5) + "},\"block\":\"parameters\"},{\"name\":\"rawGammaParams\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(nPriorGamma_code6) + "},\"block\":\"parameters\"},{\"name\":\"params\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(nParams) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"initRefr\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(nComps) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(2) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(nGroups) + ",\"element_type\":{\"name\":\"real\"}}}},\"block\":\"transformed_parameters\"},{\"name\":\"unmarked\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(nGroups) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(n_quantity_records) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(nComps) + "}}},\"block\":\"transformed_parameters\"},{\"name\":\"marked\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(nGroups) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(n_quantity_records) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(nComps) + "}}},\"block\":\"transformed_parameters\"},{\"name\":\"sizesPred\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(maxNsizesObs) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(nGroups) + ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"},{\"name\":\"propsPred\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(maxNpropsObs) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(nGroups) + ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"},{\"name\":\"sizesPred_zeta\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(maxNsizesObs) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(nGroups) + ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"},{\"name\":\"sizesPred_alpha\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(maxNsizesObs) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(nGroups) + ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"},{\"name\":\"sizesPred_beta\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(maxNsizesObs) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(nGroups) + ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"},{\"name\":\"propsPred_eta\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(maxNpropsObs) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(nGroups) + ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"},{\"name\":\"propsPred_alpha\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(maxNpropsObs) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(nGroups) + ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"},{\"name\":\"propsPred_beta\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(maxNpropsObs) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(nGroups) + ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"},{\"name\":\"transitions\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(maxNuniqueDts) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nComps) + ",\"cols\":" + std::to_string(nComps) + "}},\"block\":\"transformed_parameters\"},{\"name\":\"transitionsDecay\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(maxNuniqueDts) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nComps) + ",\"cols\":" + std::to_string(nComps) + "}},\"block\":\"transformed_parameters\"},{\"name\":\"transfer\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nComps) + ",\"cols\":" + std::to_string(nComps) + "},\"block\":\"transformed_parameters\"},{\"name\":\"transferDecay\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nComps) + ",\"cols\":" + std::to_string(nComps) + "},\"block\":\"transformed_parameters\"},{\"name\":\"transition_tmp\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nComps) + ",\"cols\":" + std::to_string(nComps) + "},\"block\":\"transformed_parameters\"},{\"name\":\"transitionDecay_tmp\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nComps) + ",\"cols\":" + std::to_string(nComps) + "},\"block\":\"transformed_parameters\"},{\"name\":\"intervals_init_states_marked\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(maxNtimeIntervals) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(nComps) + "}},\"block\":\"transformed_parameters\"},{\"name\":\"intervals_init_states_unmarked\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(maxNtimeIntervals) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(nComps) + "}},\"block\":\"transformed_parameters\"},{\"name\":\"nonConstantParams\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(nNonConstantPriors) + "},\"block\":\"generated_quantities\"},{\"name\":\"paramIndex\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"},{\"name\":\"log_lik\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(nTotal) + "},\"block\":\"generated_quantities\"},{\"name\":\"llIndexShift\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"rawUniformParams\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(nPriorUniform_code1) + "},\"block\":\"parameters\"},{\"name\":\"rawHcauchyParams\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(nPriorHcauchy_code2) + "},\"block\":\"parameters\"},{\"name\":\"rawBetaParams\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(nPriorBeta_code3) + "},\"block\":\"parameters\"},{\"name\":\"rawTrNormParams\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(nPriorTrNormal_code4) + "},\"block\":\"parameters\"},{\"name\":\"rawExponentialParams\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(nPriorExponential_code5) + "},\"block\":\"parameters\"},{\"name\":\"rawGammaParams\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(nPriorGamma_code6) + "},\"block\":\"parameters\"},{\"name\":\"params\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(nParams) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"initRefr\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(nComps) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(2) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(nGroups) + ",\"element_type\":{\"name\":\"real\"}}}},\"block\":\"transformed_parameters\"},{\"name\":\"unmarked\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(nGroups) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(n_quantity_records) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(nComps) + "}}},\"block\":\"transformed_parameters\"},{\"name\":\"marked\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(nGroups) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(n_quantity_records) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(nComps) + "}}},\"block\":\"transformed_parameters\"},{\"name\":\"sizesPred\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(maxNsizesObs) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(nGroups) + ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"},{\"name\":\"propsPred\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(maxNpropsObs) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(nGroups) + ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"},{\"name\":\"sizesPred_zeta\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(maxNsizesObs) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(nGroups) + ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"},{\"name\":\"sizesPred_alpha\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(maxNsizesObs) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(nGroups) + ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"},{\"name\":\"sizesPred_beta\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(maxNsizesObs) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(nGroups) + ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"},{\"name\":\"propsPred_eta\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(maxNpropsObs) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(nGroups) + ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"},{\"name\":\"propsPred_alpha\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(maxNpropsObs) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(nGroups) + ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"},{\"name\":\"propsPred_beta\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(maxNpropsObs) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(nGroups) + ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"},{\"name\":\"transitions\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(maxNuniqueDts) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nComps) + ",\"cols\":" + std::to_string(nComps) + "}},\"block\":\"transformed_parameters\"},{\"name\":\"transitionsDecay\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(maxNuniqueDts) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nComps) + ",\"cols\":" + std::to_string(nComps) + "}},\"block\":\"transformed_parameters\"},{\"name\":\"transfer\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nComps) + ",\"cols\":" + std::to_string(nComps) + "},\"block\":\"transformed_parameters\"},{\"name\":\"transferDecay\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nComps) + ",\"cols\":" + std::to_string(nComps) + "},\"block\":\"transformed_parameters\"},{\"name\":\"transition_tmp\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nComps) + ",\"cols\":" + std::to_string(nComps) + "},\"block\":\"transformed_parameters\"},{\"name\":\"transitionDecay_tmp\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nComps) + ",\"cols\":" + std::to_string(nComps) + "},\"block\":\"transformed_parameters\"},{\"name\":\"intervals_init_states_marked\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(maxNtimeIntervals) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(nComps) + "}},\"block\":\"transformed_parameters\"},{\"name\":\"intervals_init_states_unmarked\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(maxNtimeIntervals) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(nComps) + "}},\"block\":\"transformed_parameters\"},{\"name\":\"nonConstantParams\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(nNonConstantPriors) + "},\"block\":\"generated_quantities\"},{\"name\":\"paramIndex\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"},{\"name\":\"log_lik\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(nTotal) + "},\"block\":\"generated_quantities\"},{\"name\":\"llIndexShift\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (((((nPriorUniform_code1 +
      nPriorHcauchy_code2) + nPriorBeta_code3) + nPriorTrNormal_code4) +
      nPriorExponential_code5) + nPriorGamma_code6);
    const size_t num_transformed = emit_transformed_parameters *
      ((((((((((((((((((((nParams + ((nComps * 2) * nGroups)) + ((nGroups *
      n_quantity_records) * nComps)) + ((nGroups * n_quantity_records) *
      nComps)) + (maxNsizesObs * nGroups)) + (maxNpropsObs * nGroups)) +
      (maxNsizesObs * nGroups)) + (maxNsizesObs * nGroups)) + (maxNsizesObs *
      nGroups)) + (maxNpropsObs * nGroups)) + (maxNpropsObs * nGroups)) +
      (maxNpropsObs * nGroups)) + ((maxNuniqueDts * nComps) * nComps)) +
      ((maxNuniqueDts * nComps) * nComps)) + (nComps * nComps)) + (nComps *
      nComps)) + (nComps * nComps)) + (nComps * nComps)) + (maxNtimeIntervals
      * nComps)) + (maxNtimeIntervals * nComps)));
    const size_t num_gen_quantities = emit_generated_quantities *
      ((((nNonConstantPriors + 1) + nTotal) + 1));
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (((((nPriorUniform_code1 +
      nPriorHcauchy_code2) + nPriorBeta_code3) + nPriorTrNormal_code4) +
      nPriorExponential_code5) + nPriorGamma_code6);
    const size_t num_transformed = emit_transformed_parameters *
      ((((((((((((((((((((nParams + ((nComps * 2) * nGroups)) + ((nGroups *
      n_quantity_records) * nComps)) + ((nGroups * n_quantity_records) *
      nComps)) + (maxNsizesObs * nGroups)) + (maxNpropsObs * nGroups)) +
      (maxNsizesObs * nGroups)) + (maxNsizesObs * nGroups)) + (maxNsizesObs *
      nGroups)) + (maxNpropsObs * nGroups)) + (maxNpropsObs * nGroups)) +
      (maxNpropsObs * nGroups)) + ((maxNuniqueDts * nComps) * nComps)) +
      ((maxNuniqueDts * nComps) * nComps)) + (nComps * nComps)) + (nComps *
      nComps)) + (nComps * nComps)) + (nComps * nComps)) + (maxNtimeIntervals
      * nComps)) + (maxNtimeIntervals * nComps)));
    const size_t num_gen_quantities = emit_generated_quantities *
      ((((nNonConstantPriors + 1) + nTotal) + 1));
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = model_networkModel_namespace::model_networkModel;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return model_networkModel_namespace::profiles__;
}
#endif
#endif
