// Generated by rstantools.  Do not edit by hand.

/*
    myPkg is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    myPkg is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with myPkg.  If not, see <http://www.gnu.org/licenses/>.
*/
#ifndef MODELS_HPP
#define MODELS_HPP
#define STAN__SERVICES__COMMAND_HPP
#ifndef USE_STANC3
#define USE_STANC3
#endif
#include <rstan/rstaninc.hpp>
// Code generated by stanc v2.26.1-4-gd72b68b7-dirty
#include <stan/model/model_header.hpp>
namespace model_networkModel_namespace {
inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}
inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}
using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math;
using stan::math::pow; 
stan::math::profile_map profiles__;
static int current_statement__= 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'networkModel', line 439, column 2 to column 64)",
                                                      " (in 'networkModel', line 440, column 2 to column 56)",
                                                      " (in 'networkModel', line 441, column 2 to column 58)",
                                                      " (in 'networkModel', line 442, column 2 to column 56)",
                                                      " (in 'networkModel', line 443, column 2 to column 64)",
                                                      " (in 'networkModel', line 444, column 2 to column 52)",
                                                      " (in 'networkModel', line 451, column 2 to column 38)",
                                                      " (in 'networkModel', line 453, column 2 to column 88)",
                                                      " (in 'networkModel', line 456, column 2 to column 61)",
                                                      " (in 'networkModel', line 458, column 2 to column 59)",
                                                      " (in 'networkModel', line 460, column 2 to column 55)",
                                                      " (in 'networkModel', line 461, column 2 to column 55)",
                                                      " (in 'networkModel', line 463, column 2 to column 100)",
                                                      " (in 'networkModel', line 464, column 2 to column 101)",
                                                      " (in 'networkModel', line 465, column 2 to column 100)",
                                                      " (in 'networkModel', line 466, column 2 to column 99)",
                                                      " (in 'networkModel', line 467, column 2 to column 101)",
                                                      " (in 'networkModel', line 468, column 2 to column 100)",
                                                      " (in 'networkModel', line 473, column 2 to column 57)",
                                                      " (in 'networkModel', line 474, column 2 to column 62)",
                                                      " (in 'networkModel', line 478, column 2 to column 33)",
                                                      " (in 'networkModel', line 479, column 2 to column 38)",
                                                      " (in 'networkModel', line 480, column 2 to column 39)",
                                                      " (in 'networkModel', line 481, column 2 to column 44)",
                                                      " (in 'networkModel', line 484, column 2 to column 71)",
                                                      " (in 'networkModel', line 485, column 2 to column 73)",
                                                      " (in 'networkModel', line 490, column 4 to column 19)",
                                                      " (in 'networkModel', line 494, column 6 to column 36)",
                                                      " (in 'networkModel', line 493, column 39 to line 495, column 5)",
                                                      " (in 'networkModel', line 493, column 4 to line 495, column 5)",
                                                      " (in 'networkModel', line 497, column 6 to column 112)",
                                                      " (in 'networkModel', line 496, column 39 to line 498, column 5)",
                                                      " (in 'networkModel', line 496, column 4 to line 498, column 5)",
                                                      " (in 'networkModel', line 500, column 6 to column 83)",
                                                      " (in 'networkModel', line 499, column 39 to line 501, column 5)",
                                                      " (in 'networkModel', line 499, column 4 to line 501, column 5)",
                                                      " (in 'networkModel', line 503, column 6 to column 77)",
                                                      " (in 'networkModel', line 502, column 39 to line 504, column 5)",
                                                      " (in 'networkModel', line 502, column 4 to line 504, column 5)",
                                                      " (in 'networkModel', line 506, column 6 to column 58)",
                                                      " (in 'networkModel', line 505, column 39 to line 507, column 5)",
                                                      " (in 'networkModel', line 505, column 4 to line 507, column 5)",
                                                      " (in 'networkModel', line 509, column 6 to column 63)",
                                                      " (in 'networkModel', line 508, column 39 to line 510, column 5)",
                                                      " (in 'networkModel', line 508, column 4 to line 510, column 5)",
                                                      " (in 'networkModel', line 512, column 6 to column 57)",
                                                      " (in 'networkModel', line 511, column 39 to line 513, column 5)",
                                                      " (in 'networkModel', line 511, column 4 to line 513, column 5)",
                                                      " (in 'networkModel', line 492, column 23 to line 514, column 3)",
                                                      " (in 'networkModel', line 492, column 2 to line 514, column 3)",
                                                      " (in 'networkModel', line 526, column 6 to line 528, column 78)",
                                                      " (in 'networkModel', line 529, column 6 to column 79)",
                                                      " (in 'networkModel', line 519, column 25 to line 530, column 5)",
                                                      " (in 'networkModel', line 519, column 4 to line 530, column 5)",
                                                      " (in 'networkModel', line 534, column 8 to line 537, column 72)",
                                                      " (in 'networkModel', line 538, column 8 to line 541, column 74)",
                                                      " (in 'networkModel', line 533, column 33 to line 542, column 7)",
                                                      " (in 'networkModel', line 533, column 6 to line 542, column 7)",
                                                      " (in 'networkModel', line 531, column 25 to line 543, column 5)",
                                                      " (in 'networkModel', line 531, column 4 to line 543, column 5)",
                                                      " (in 'networkModel', line 546, column 4 to column 19)",
                                                      " (in 'networkModel', line 550, column 4 to column 56)",
                                                      " (in 'networkModel', line 551, column 4 to column 54)",
                                                      " (in 'networkModel', line 557, column 10 to column 77)",
                                                      " (in 'networkModel', line 558, column 10 to column 75)",
                                                      " (in 'networkModel', line 560, column 10 to column 73)",
                                                      " (in 'networkModel', line 561, column 10 to column 69)",
                                                      " (in 'networkModel', line 555, column 33 to line 562, column 9)",
                                                      " (in 'networkModel', line 555, column 8 to line 562, column 9)",
                                                      " (in 'networkModel', line 554, column 26 to line 563, column 7)",
                                                      " (in 'networkModel', line 554, column 6 to line 563, column 7)",
                                                      " (in 'networkModel', line 553, column 26 to line 564, column 5)",
                                                      " (in 'networkModel', line 553, column 4 to line 564, column 5)",
                                                      " (in 'networkModel', line 569, column 10 to column 102)",
                                                      " (in 'networkModel', line 570, column 10 to column 100)",
                                                      " (in 'networkModel', line 571, column 10 to column 26)",
                                                      " (in 'networkModel', line 573, column 12 to column 18)",
                                                      " (in 'networkModel', line 572, column 44 to line 574, column 11)",
                                                      " (in 'networkModel', line 572, column 10 to line 574, column 11)",
                                                      " (in 'networkModel', line 568, column 55 to line 575, column 9)",
                                                      " (in 'networkModel', line 568, column 8 to line 575, column 9)",
                                                      " (in 'networkModel', line 567, column 41 to line 576, column 7)",
                                                      " (in 'networkModel', line 567, column 6 to line 576, column 7)",
                                                      " (in 'networkModel', line 566, column 29 to line 577, column 5)",
                                                      " (in 'networkModel', line 566, column 4 to line 577, column 5)",
                                                      " (in 'networkModel', line 582, column 6 to column 57)",
                                                      " (in 'networkModel', line 583, column 6 to column 53)",
                                                      " (in 'networkModel', line 591, column 10 to column 74)",
                                                      " (in 'networkModel', line 595, column 12 to column 86)",
                                                      " (in 'networkModel', line 594, column 17 to line 596, column 11)",
                                                      " (in 'networkModel', line 593, column 12 to column 49)",
                                                      " (in 'networkModel', line 592, column 33 to line 594, column 11)",
                                                      " (in 'networkModel', line 592, column 10 to line 596, column 11)",
                                                      " (in 'networkModel', line 597, column 10 to column 99)",
                                                      " (in 'networkModel', line 598, column 10 to column 100)",
                                                      " (in 'networkModel', line 604, column 16 to column 127)",
                                                      " (in 'networkModel', line 605, column 16 to column 125)",
                                                      " (in 'networkModel', line 606, column 16 to column 32)",
                                                      " (in 'networkModel', line 608, column 18 to column 24)",
                                                      " (in 'networkModel', line 607, column 50 to line 609, column 17)",
                                                      " (in 'networkModel', line 607, column 16 to line 609, column 17)",
                                                      " (in 'networkModel', line 603, column 61 to line 610, column 15)",
                                                      " (in 'networkModel', line 603, column 14 to line 610, column 15)",
                                                      " (in 'networkModel', line 602, column 47 to line 611, column 13)",
                                                      " (in 'networkModel', line 602, column 12 to line 611, column 13)",
                                                      " (in 'networkModel', line 601, column 35 to line 612, column 11)",
                                                      " (in 'networkModel', line 601, column 10 to line 612, column 11)",
                                                      " (in 'networkModel', line 589, column 39 to line 613, column 9)",
                                                      " (in 'networkModel', line 589, column 8 to line 613, column 9)",
                                                      " (in 'networkModel', line 588, column 33 to line 614, column 7)",
                                                      " (in 'networkModel', line 588, column 6 to line 614, column 7)",
                                                      " (in 'networkModel', line 618, column 8 to column 73)",
                                                      " (in 'networkModel', line 622, column 10 to column 85)",
                                                      " (in 'networkModel', line 621, column 15 to line 623, column 9)",
                                                      " (in 'networkModel', line 620, column 10 to column 47)",
                                                      " (in 'networkModel', line 619, column 31 to line 621, column 9)",
                                                      " (in 'networkModel', line 619, column 8 to line 623, column 9)",
                                                      " (in 'networkModel', line 624, column 8 to column 96)",
                                                      " (in 'networkModel', line 625, column 8 to column 97)",
                                                      " (in 'networkModel', line 617, column 32 to line 626, column 7)",
                                                      " (in 'networkModel', line 617, column 6 to line 626, column 7)",
                                                      " (in 'networkModel', line 579, column 25 to line 627, column 5)",
                                                      " (in 'networkModel', line 579, column 4 to line 627, column 5)",
                                                      " (in 'networkModel', line 634, column 8 to column 71)",
                                                      " (in 'networkModel', line 635, column 8 to column 72)",
                                                      " (in 'networkModel', line 640, column 12 to column 84)",
                                                      " (in 'networkModel', line 641, column 12 to column 80)",
                                                      " (in 'networkModel', line 639, column 34 to line 642, column 11)",
                                                      " (in 'networkModel', line 639, column 10 to line 642, column 11)",
                                                      " (in 'networkModel', line 638, column 28 to line 643, column 9)",
                                                      " (in 'networkModel', line 638, column 8 to line 643, column 9)",
                                                      " (in 'networkModel', line 649, column 14 to column 108)",
                                                      " (in 'networkModel', line 650, column 14 to column 106)",
                                                      " (in 'networkModel', line 651, column 14 to column 30)",
                                                      " (in 'networkModel', line 653, column 16 to column 22)",
                                                      " (in 'networkModel', line 652, column 48 to line 654, column 15)",
                                                      " (in 'networkModel', line 652, column 14 to line 654, column 15)",
                                                      " (in 'networkModel', line 648, column 61 to line 655, column 13)",
                                                      " (in 'networkModel', line 648, column 12 to line 655, column 13)",
                                                      " (in 'networkModel', line 647, column 45 to line 656, column 11)",
                                                      " (in 'networkModel', line 647, column 10 to line 656, column 11)",
                                                      " (in 'networkModel', line 646, column 33 to line 657, column 9)",
                                                      " (in 'networkModel', line 646, column 8 to line 657, column 9)",
                                                      " (in 'networkModel', line 631, column 33 to line 659, column 7)",
                                                      " (in 'networkModel', line 631, column 6 to line 659, column 7)",
                                                      " (in 'networkModel', line 629, column 25 to line 660, column 5)",
                                                      " (in 'networkModel', line 629, column 4 to line 660, column 5)",
                                                      " (in 'networkModel', line 664, column 4 to line 668, column 56)",
                                                      " (in 'networkModel', line 669, column 4 to line 673, column 56)",
                                                      " (in 'networkModel', line 676, column 6 to column 59)",
                                                      " (in 'networkModel', line 679, column 8 to column 46)",
                                                      " (in 'networkModel', line 680, column 8 to column 67)",
                                                      " (in 'networkModel', line 677, column 27 to line 681, column 7)",
                                                      " (in 'networkModel', line 677, column 6 to line 681, column 7)",
                                                      " (in 'networkModel', line 684, column 8 to column 46)",
                                                      " (in 'networkModel', line 685, column 8 to column 50)",
                                                      " (in 'networkModel', line 682, column 27 to line 686, column 7)",
                                                      " (in 'networkModel', line 682, column 6 to line 686, column 7)",
                                                      " (in 'networkModel', line 675, column 30 to line 687, column 5)",
                                                      " (in 'networkModel', line 675, column 4 to line 687, column 5)",
                                                      " (in 'networkModel', line 689, column 6 to column 58)",
                                                      " (in 'networkModel', line 692, column 8 to column 59)",
                                                      " (in 'networkModel', line 693, column 8 to column 68)",
                                                      " (in 'networkModel', line 690, column 27 to line 694, column 7)",
                                                      " (in 'networkModel', line 690, column 6 to line 694, column 7)",
                                                      " (in 'networkModel', line 697, column 8 to column 46)",
                                                      " (in 'networkModel', line 698, column 8 to column 72)",
                                                      " (in 'networkModel', line 695, column 27 to line 699, column 7)",
                                                      " (in 'networkModel', line 695, column 6 to line 699, column 7)",
                                                      " (in 'networkModel', line 702, column 8 to column 46)",
                                                      " (in 'networkModel', line 703, column 8 to column 49)",
                                                      " (in 'networkModel', line 700, column 27 to line 704, column 7)",
                                                      " (in 'networkModel', line 700, column 6 to line 704, column 7)",
                                                      " (in 'networkModel', line 707, column 8 to column 67)",
                                                      " (in 'networkModel', line 708, column 8 to column 72)",
                                                      " (in 'networkModel', line 705, column 27 to line 709, column 7)",
                                                      " (in 'networkModel', line 705, column 6 to line 709, column 7)",
                                                      " (in 'networkModel', line 688, column 30 to line 710, column 5)",
                                                      " (in 'networkModel', line 688, column 4 to line 710, column 5)",
                                                      " (in 'networkModel', line 516, column 23 to line 712, column 3)",
                                                      " (in 'networkModel', line 516, column 2 to line 712, column 3)",
                                                      " (in 'networkModel', line 489, column 2 to line 713, column 3)",
                                                      " (in 'networkModel', line 781, column 2 to column 47)",
                                                      " (in 'networkModel', line 782, column 2 to column 17)",
                                                      " (in 'networkModel', line 783, column 2 to column 25)",
                                                      " (in 'networkModel', line 784, column 2 to column 19)",
                                                      " (in 'networkModel', line 785, column 2 to column 19)",
                                                      " (in 'networkModel', line 787, column 2 to column 17)",
                                                      " (in 'networkModel', line 791, column 6 to column 48)",
                                                      " (in 'networkModel', line 792, column 6 to column 22)",
                                                      " (in 'networkModel', line 789, column 39 to line 793, column 5)",
                                                      " (in 'networkModel', line 789, column 4 to line 793, column 5)",
                                                      " (in 'networkModel', line 788, column 23 to line 794, column 3)",
                                                      " (in 'networkModel', line 788, column 2 to line 794, column 3)",
                                                      " (in 'networkModel', line 800, column 8 to column 105)",
                                                      " (in 'networkModel', line 799, column 27 to line 801, column 7)",
                                                      " (in 'networkModel', line 799, column 6 to line 801, column 7)",
                                                      " (in 'networkModel', line 803, column 8 to column 105)",
                                                      " (in 'networkModel', line 802, column 27 to line 804, column 7)",
                                                      " (in 'networkModel', line 802, column 6 to line 804, column 7)",
                                                      " (in 'networkModel', line 798, column 30 to line 805, column 5)",
                                                      " (in 'networkModel', line 798, column 4 to line 805, column 5)",
                                                      " (in 'networkModel', line 806, column 4 to column 33)",
                                                      " (in 'networkModel', line 797, column 23 to line 807, column 3)",
                                                      " (in 'networkModel', line 797, column 2 to line 807, column 3)",
                                                      " (in 'networkModel', line 812, column 8 to column 104)",
                                                      " (in 'networkModel', line 811, column 27 to line 813, column 7)",
                                                      " (in 'networkModel', line 811, column 6 to line 813, column 7)",
                                                      " (in 'networkModel', line 815, column 8 to column 105)",
                                                      " (in 'networkModel', line 814, column 27 to line 816, column 7)",
                                                      " (in 'networkModel', line 814, column 6 to line 816, column 7)",
                                                      " (in 'networkModel', line 818, column 8 to column 105)",
                                                      " (in 'networkModel', line 817, column 27 to line 819, column 7)",
                                                      " (in 'networkModel', line 817, column 6 to line 819, column 7)",
                                                      " (in 'networkModel', line 821, column 8 to column 103)",
                                                      " (in 'networkModel', line 820, column 27 to line 822, column 7)",
                                                      " (in 'networkModel', line 820, column 6 to line 822, column 7)",
                                                      " (in 'networkModel', line 810, column 30 to line 823, column 5)",
                                                      " (in 'networkModel', line 810, column 4 to line 823, column 5)",
                                                      " (in 'networkModel', line 824, column 4 to column 33)",
                                                      " (in 'networkModel', line 809, column 23 to line 825, column 3)",
                                                      " (in 'networkModel', line 809, column 2 to line 825, column 3)",
                                                      " (in 'networkModel', line 721, column 6 to column 63)",
                                                      " (in 'networkModel', line 720, column 39 to line 722, column 5)",
                                                      " (in 'networkModel', line 720, column 4 to line 722, column 5)",
                                                      " (in 'networkModel', line 724, column 6 to column 62)",
                                                      " (in 'networkModel', line 723, column 39 to line 725, column 5)",
                                                      " (in 'networkModel', line 723, column 4 to line 725, column 5)",
                                                      " (in 'networkModel', line 727, column 6 to column 84)",
                                                      " (in 'networkModel', line 726, column 39 to line 728, column 5)",
                                                      " (in 'networkModel', line 726, column 4 to line 728, column 5)",
                                                      " (in 'networkModel', line 730, column 6 to column 95)",
                                                      " (in 'networkModel', line 729, column 39 to line 731, column 5)",
                                                      " (in 'networkModel', line 729, column 4 to line 731, column 5)",
                                                      " (in 'networkModel', line 733, column 6 to column 91)",
                                                      " (in 'networkModel', line 732, column 39 to line 734, column 5)",
                                                      " (in 'networkModel', line 732, column 4 to line 734, column 5)",
                                                      " (in 'networkModel', line 736, column 6 to line 737, column 73)",
                                                      " (in 'networkModel', line 735, column 39 to line 738, column 5)",
                                                      " (in 'networkModel', line 735, column 4 to line 738, column 5)",
                                                      " (in 'networkModel', line 719, column 23 to line 739, column 3)",
                                                      " (in 'networkModel', line 719, column 2 to line 739, column 3)",
                                                      " (in 'networkModel', line 745, column 6 to line 746, column 77)",
                                                      " (in 'networkModel', line 743, column 25 to line 747, column 5)",
                                                      " (in 'networkModel', line 743, column 4 to line 747, column 5)",
                                                      " (in 'networkModel', line 750, column 6 to line 751, column 77)",
                                                      " (in 'networkModel', line 748, column 25 to line 752, column 5)",
                                                      " (in 'networkModel', line 748, column 4 to line 752, column 5)",
                                                      " (in 'networkModel', line 756, column 6 to line 757, column 76)",
                                                      " (in 'networkModel', line 754, column 25 to line 758, column 5)",
                                                      " (in 'networkModel', line 754, column 4 to line 758, column 5)",
                                                      " (in 'networkModel', line 761, column 6 to line 762, column 77)",
                                                      " (in 'networkModel', line 759, column 25 to line 763, column 5)",
                                                      " (in 'networkModel', line 759, column 4 to line 763, column 5)",
                                                      " (in 'networkModel', line 766, column 6 to line 767, column 77)",
                                                      " (in 'networkModel', line 764, column 25 to line 768, column 5)",
                                                      " (in 'networkModel', line 764, column 4 to line 768, column 5)",
                                                      " (in 'networkModel', line 771, column 6 to line 772, column 75)",
                                                      " (in 'networkModel', line 769, column 25 to line 773, column 5)",
                                                      " (in 'networkModel', line 769, column 4 to line 773, column 5)",
                                                      " (in 'networkModel', line 741, column 23 to line 775, column 3)",
                                                      " (in 'networkModel', line 741, column 2 to line 775, column 3)",
                                                      " (in 'networkModel', line 300, column 2 to column 34)",
                                                      " (in 'networkModel', line 303, column 2 to column 22)",
                                                      " (in 'networkModel', line 304, column 2 to column 23)",
                                                      " (in 'networkModel', line 305, column 2 to column 23)",
                                                      " (in 'networkModel', line 307, column 2 to column 34)",
                                                      " (in 'networkModel', line 308, column 2 to column 35)",
                                                      " (in 'networkModel', line 309, column 2 to column 35)",
                                                      " (in 'networkModel', line 310, column 2 to column 32)",
                                                      " (in 'networkModel', line 311, column 2 to column 36)",
                                                      " (in 'networkModel', line 312, column 2 to column 39)",
                                                      " (in 'networkModel', line 313, column 2 to column 33)",
                                                      " (in 'networkModel', line 317, column 8 to column 15)",
                                                      " (in 'networkModel', line 317, column 2 to column 37)",
                                                      " (in 'networkModel', line 320, column 8 to column 15)",
                                                      " (in 'networkModel', line 320, column 2 to column 34)",
                                                      " (in 'networkModel', line 321, column 8 to column 15)",
                                                      " (in 'networkModel', line 321, column 2 to column 34)",
                                                      " (in 'networkModel', line 323, column 8 to column 15)",
                                                      " (in 'networkModel', line 323, column 2 to column 41)",
                                                      " (in 'networkModel', line 325, column 8 to column 15)",
                                                      " (in 'networkModel', line 325, column 2 to column 44)",
                                                      " (in 'networkModel', line 326, column 8 to column 15)",
                                                      " (in 'networkModel', line 326, column 2 to column 43)",
                                                      " (in 'networkModel', line 327, column 8 to column 15)",
                                                      " (in 'networkModel', line 327, column 2 to column 47)",
                                                      " (in 'networkModel', line 329, column 8 to column 15)",
                                                      " (in 'networkModel', line 329, column 2 to column 39)",
                                                      " (in 'networkModel', line 330, column 8 to column 15)",
                                                      " (in 'networkModel', line 330, column 2 to column 37)",
                                                      " (in 'networkModel', line 332, column 8 to column 15)",
                                                      " (in 'networkModel', line 332, column 2 to column 44)",
                                                      " (in 'networkModel', line 334, column 8 to column 15)",
                                                      " (in 'networkModel', line 334, column 2 to column 39)",
                                                      " (in 'networkModel', line 335, column 8 to column 15)",
                                                      " (in 'networkModel', line 335, column 2 to column 38)",
                                                      " (in 'networkModel', line 338, column 8 to column 15)",
                                                      " (in 'networkModel', line 338, column 2 to column 52)",
                                                      " (in 'networkModel', line 339, column 8 to column 15)",
                                                      " (in 'networkModel', line 339, column 2 to column 50)",
                                                      " (in 'networkModel', line 341, column 2 to column 34)",
                                                      " (in 'networkModel', line 349, column 2 to column 34)",
                                                      " (in 'networkModel', line 355, column 8 to column 14)",
                                                      " (in 'networkModel', line 355, column 17 to column 24)",
                                                      " (in 'networkModel', line 355, column 2 to column 58)",
                                                      " (in 'networkModel', line 357, column 2 to column 26)",
                                                      " (in 'networkModel', line 358, column 8 to column 17)",
                                                      " (in 'networkModel', line 358, column 2 to column 40)",
                                                      " (in 'networkModel', line 359, column 8 to column 18)",
                                                      " (in 'networkModel', line 359, column 19 to column 26)",
                                                      " (in 'networkModel', line 359, column 2 to column 55)",
                                                      " (in 'networkModel', line 361, column 2 to column 36)",
                                                      " (in 'networkModel', line 362, column 8 to column 14)",
                                                      " (in 'networkModel', line 362, column 15 to column 22)",
                                                      " (in 'networkModel', line 362, column 2 to column 56)",
                                                      " (in 'networkModel', line 364, column 8 to column 14)",
                                                      " (in 'networkModel', line 364, column 16 to column 23)",
                                                      " (in 'networkModel', line 364, column 2 to column 48)",
                                                      " (in 'networkModel', line 366, column 2 to column 29)",
                                                      " (in 'networkModel', line 368, column 2 to column 28)",
                                                      " (in 'networkModel', line 369, column 8 to column 17)",
                                                      " (in 'networkModel', line 369, column 2 to column 42)",
                                                      " (in 'networkModel', line 370, column 8 to column 20)",
                                                      " (in 'networkModel', line 370, column 23 to column 30)",
                                                      " (in 'networkModel', line 370, column 2 to column 60)",
                                                      " (in 'networkModel', line 373, column 2 to column 27)",
                                                      " (in 'networkModel', line 374, column 8 to column 17)",
                                                      " (in 'networkModel', line 374, column 2 to column 41)",
                                                      " (in 'networkModel', line 375, column 8 to column 19)",
                                                      " (in 'networkModel', line 375, column 22 to column 29)",
                                                      " (in 'networkModel', line 375, column 2 to column 58)",
                                                      " (in 'networkModel', line 378, column 2 to column 31)",
                                                      " (in 'networkModel', line 379, column 8 to column 17)",
                                                      " (in 'networkModel', line 379, column 2 to column 45)",
                                                      " (in 'networkModel', line 380, column 8 to column 23)",
                                                      " (in 'networkModel', line 380, column 26 to column 33)",
                                                      " (in 'networkModel', line 380, column 2 to column 67)",
                                                      " (in 'networkModel', line 381, column 8 to column 23)",
                                                      " (in 'networkModel', line 381, column 26 to column 33)",
                                                      " (in 'networkModel', line 381, column 2 to column 62)",
                                                      " (in 'networkModel', line 384, column 2 to column 28)",
                                                      " (in 'networkModel', line 385, column 2 to column 28)",
                                                      " (in 'networkModel', line 386, column 8 to column 17)",
                                                      " (in 'networkModel', line 386, column 2 to column 42)",
                                                      " (in 'networkModel', line 387, column 8 to column 17)",
                                                      " (in 'networkModel', line 387, column 2 to column 42)",
                                                      " (in 'networkModel', line 388, column 8 to column 20)",
                                                      " (in 'networkModel', line 388, column 23 to column 30)",
                                                      " (in 'networkModel', line 388, column 2 to column 61)",
                                                      " (in 'networkModel', line 389, column 8 to column 20)",
                                                      " (in 'networkModel', line 389, column 23 to column 30)",
                                                      " (in 'networkModel', line 389, column 2 to column 61)",
                                                      " (in 'networkModel', line 390, column 8 to column 20)",
                                                      " (in 'networkModel', line 390, column 22 to column 29)",
                                                      " (in 'networkModel', line 390, column 2 to column 54)",
                                                      " (in 'networkModel', line 391, column 8 to column 20)",
                                                      " (in 'networkModel', line 391, column 22 to column 29)",
                                                      " (in 'networkModel', line 391, column 2 to column 54)",
                                                      " (in 'networkModel', line 396, column 2 to column 33)",
                                                      " (in 'networkModel', line 397, column 8 to column 17)",
                                                      " (in 'networkModel', line 397, column 2 to column 47)",
                                                      " (in 'networkModel', line 398, column 8 to column 25)",
                                                      " (in 'networkModel', line 398, column 26 to column 33)",
                                                      " (in 'networkModel', line 398, column 2 to column 66)",
                                                      " (in 'networkModel', line 402, column 2 to column 28)",
                                                      " (in 'networkModel', line 403, column 8 to column 17)",
                                                      " (in 'networkModel', line 403, column 2 to column 42)",
                                                      " (in 'networkModel', line 404, column 8 to column 15)",
                                                      " (in 'networkModel', line 404, column 16 to column 28)",
                                                      " (in 'networkModel', line 404, column 2 to column 66)",
                                                      " (in 'networkModel', line 405, column 8 to column 15)",
                                                      " (in 'networkModel', line 405, column 16 to column 28)",
                                                      " (in 'networkModel', line 405, column 2 to column 63)",
                                                      " (in 'networkModel', line 409, column 2 to column 29)",
                                                      " (in 'networkModel', line 410, column 8 to column 17)",
                                                      " (in 'networkModel', line 410, column 2 to column 43)",
                                                      " (in 'networkModel', line 411, column 2 to column 29)",
                                                      " (in 'networkModel', line 412, column 8 to column 17)",
                                                      " (in 'networkModel', line 412, column 2 to column 43)",
                                                      " (in 'networkModel', line 413, column 8 to column 21)",
                                                      " (in 'networkModel', line 413, column 22 to column 29)",
                                                      " (in 'networkModel', line 413, column 2 to column 56)",
                                                      " (in 'networkModel', line 414, column 8 to column 21)",
                                                      " (in 'networkModel', line 414, column 22 to column 29)",
                                                      " (in 'networkModel', line 414, column 2 to column 54)",
                                                      " (in 'networkModel', line 419, column 2 to column 22)",
                                                      " (in 'networkModel', line 420, column 2 to column 34)",
                                                      " (in 'networkModel', line 421, column 2 to column 13)",
                                                      " (in 'networkModel', line 425, column 4 to column 42)",
                                                      " (in 'networkModel', line 424, column 23 to line 426, column 3)",
                                                      " (in 'networkModel', line 424, column 2 to line 426, column 3)",
                                                      " (in 'networkModel', line 430, column 4 to column 40)",
                                                      " (in 'networkModel', line 428, column 23 to line 431, column 3)",
                                                      " (in 'networkModel', line 428, column 2 to line 431, column 3)",
                                                      " (in 'networkModel', line 434, column 4 to column 41)",
                                                      " (in 'networkModel', line 432, column 23 to line 435, column 3)",
                                                      " (in 'networkModel', line 432, column 2 to line 435, column 3)",
                                                      " (in 'networkModel', line 439, column 26 to column 45)",
                                                      " (in 'networkModel', line 440, column 18 to column 37)",
                                                      " (in 'networkModel', line 441, column 26 to column 42)",
                                                      " (in 'networkModel', line 442, column 18 to column 38)",
                                                      " (in 'networkModel', line 443, column 18 to column 41)",
                                                      " (in 'networkModel', line 444, column 18 to column 35)",
                                                      " (in 'networkModel', line 451, column 8 to column 15)",
                                                      " (in 'networkModel', line 453, column 8 to column 14)",
                                                      " (in 'networkModel', line 453, column 19 to column 26)",
                                                      " (in 'networkModel', line 456, column 8 to column 15)",
                                                      " (in 'networkModel', line 456, column 17 to column 35)",
                                                      " (in 'networkModel', line 456, column 44 to column 50)",
                                                      " (in 'networkModel', line 458, column 8 to column 15)",
                                                      " (in 'networkModel', line 458, column 17 to column 35)",
                                                      " (in 'networkModel', line 458, column 44 to column 50)",
                                                      " (in 'networkModel', line 460, column 8 to column 20)",
                                                      " (in 'networkModel', line 460, column 22 to column 29)",
                                                      " (in 'networkModel', line 461, column 8 to column 20)",
                                                      " (in 'networkModel', line 461, column 22 to column 29)",
                                                      " (in 'networkModel', line 463, column 8 to column 20)",
                                                      " (in 'networkModel', line 463, column 22 to column 29)",
                                                      " (in 'networkModel', line 464, column 8 to column 20)",
                                                      " (in 'networkModel', line 464, column 22 to column 29)",
                                                      " (in 'networkModel', line 465, column 8 to column 20)",
                                                      " (in 'networkModel', line 465, column 22 to column 29)",
                                                      " (in 'networkModel', line 466, column 8 to column 20)",
                                                      " (in 'networkModel', line 466, column 22 to column 29)",
                                                      " (in 'networkModel', line 467, column 8 to column 20)",
                                                      " (in 'networkModel', line 467, column 22 to column 29)",
                                                      " (in 'networkModel', line 468, column 8 to column 20)",
                                                      " (in 'networkModel', line 468, column 22 to column 29)",
                                                      " (in 'networkModel', line 473, column 8 to column 21)",
                                                      " (in 'networkModel', line 473, column 30 to column 36)",
                                                      " (in 'networkModel', line 473, column 37 to column 43)",
                                                      " (in 'networkModel', line 474, column 8 to column 21)",
                                                      " (in 'networkModel', line 474, column 30 to column 36)",
                                                      " (in 'networkModel', line 474, column 37 to column 43)",
                                                      " (in 'networkModel', line 478, column 9 to column 15)",
                                                      " (in 'networkModel', line 478, column 16 to column 22)",
                                                      " (in 'networkModel', line 479, column 9 to column 15)",
                                                      " (in 'networkModel', line 479, column 16 to column 22)",
                                                      " (in 'networkModel', line 480, column 9 to column 15)",
                                                      " (in 'networkModel', line 480, column 16 to column 22)",
                                                      " (in 'networkModel', line 481, column 9 to column 15)",
                                                      " (in 'networkModel', line 481, column 16 to column 22)",
                                                      " (in 'networkModel', line 484, column 8 to column 25)",
                                                      " (in 'networkModel', line 484, column 34 to column 40)",
                                                      " (in 'networkModel', line 485, column 8 to column 25)",
                                                      " (in 'networkModel', line 485, column 34 to column 40)",
                                                      " (in 'networkModel', line 781, column 9 to column 27)",
                                                      " (in 'networkModel', line 783, column 9 to column 15)",
                                                      " (in 'networkModel', line 54, column 11 to column 17)",
                                                      " (in 'networkModel', line 54, column 19 to column 25)",
                                                      " (in 'networkModel', line 54, column 4 to column 68)",
                                                      " (in 'networkModel', line 55, column 11 to column 17)",
                                                      " (in 'networkModel', line 55, column 4 to column 53)",
                                                      " (in 'networkModel', line 57, column 6 to column 72)",
                                                      " (in 'networkModel', line 58, column 6 to column 58)",
                                                      " (in 'networkModel', line 56, column 27 to line 59, column 5)",
                                                      " (in 'networkModel', line 56, column 4 to line 59, column 5)",
                                                      " (in 'networkModel', line 61, column 6 to column 58)",
                                                      " (in 'networkModel', line 60, column 26 to line 62, column 5)",
                                                      " (in 'networkModel', line 60, column 4 to line 62, column 5)",
                                                      " (in 'networkModel', line 64, column 6 to column 36)",
                                                      " (in 'networkModel', line 63, column 24 to line 65, column 5)",
                                                      " (in 'networkModel', line 63, column 4 to line 65, column 5)",
                                                      " (in 'networkModel', line 69, column 8 to column 56)",
                                                      " (in 'networkModel', line 68, column 27 to line 70, column 7)",
                                                      " (in 'networkModel', line 68, column 6 to line 70, column 7)",
                                                      " (in 'networkModel', line 67, column 21 to line 71, column 5)",
                                                      " (in 'networkModel', line 67, column 4 to line 71, column 5)",
                                                      " (in 'networkModel', line 72, column 4 to column 21)",
                                                      " (in 'networkModel', line 53, column 87 to line 73, column 3)",
                                                      " (in 'networkModel', line 89, column 11 to column 17)",
                                                      " (in 'networkModel', line 89, column 19 to column 25)",
                                                      " (in 'networkModel', line 89, column 4 to column 50)",
                                                      " (in 'networkModel', line 91, column 6 to column 36)",
                                                      " (in 'networkModel', line 90, column 24 to line 92, column 5)",
                                                      " (in 'networkModel', line 90, column 4 to line 92, column 5)",
                                                      " (in 'networkModel', line 93, column 4 to column 21)",
                                                      " (in 'networkModel', line 88, column 53 to line 94, column 3)",
                                                      " (in 'networkModel', line 136, column 11 to column 17)",
                                                      " (in 'networkModel', line 136, column 19 to column 25)",
                                                      " (in 'networkModel', line 136, column 4 to column 70)",
                                                      " (in 'networkModel', line 137, column 11 to column 17)",
                                                      " (in 'networkModel', line 137, column 4 to column 53)",
                                                      " (in 'networkModel', line 139, column 6 to column 74)",
                                                      " (in 'networkModel', line 140, column 6 to column 58)",
                                                      " (in 'networkModel', line 138, column 27 to line 141, column 5)",
                                                      " (in 'networkModel', line 138, column 4 to line 141, column 5)",
                                                      " (in 'networkModel', line 143, column 6 to column 58)",
                                                      " (in 'networkModel', line 142, column 26 to line 144, column 5)",
                                                      " (in 'networkModel', line 142, column 4 to line 144, column 5)",
                                                      " (in 'networkModel', line 145, column 4 to column 21)",
                                                      " (in 'networkModel', line 146, column 4 to column 20)",
                                                      " (in 'networkModel', line 148, column 6 to column 42)",
                                                      " (in 'networkModel', line 147, column 24 to line 149, column 5)",
                                                      " (in 'networkModel', line 147, column 4 to line 149, column 5)",
                                                      " (in 'networkModel', line 150, column 4 to column 23)",
                                                      " (in 'networkModel', line 135, column 61 to line 151, column 3)",
                                                      " (in 'networkModel', line 171, column 11 to column 17)",
                                                      " (in 'networkModel', line 171, column 19 to column 25)",
                                                      " (in 'networkModel', line 171, column 4 to column 54)",
                                                      " (in 'networkModel', line 173, column 6 to column 43)",
                                                      " (in 'networkModel', line 172, column 24 to line 174, column 5)",
                                                      " (in 'networkModel', line 172, column 4 to line 174, column 5)",
                                                      " (in 'networkModel', line 175, column 4 to column 23)",
                                                      " (in 'networkModel', line 170, column 45 to line 176, column 3)",
                                                      " (in 'networkModel', line 211, column 10 to column 17)",
                                                      " (in 'networkModel', line 211, column 4 to column 55)",
                                                      " (in 'networkModel', line 212, column 4 to column 19)",
                                                      " (in 'networkModel', line 213, column 4 to column 17)",
                                                      " (in 'networkModel', line 229, column 8 to column 57)",
                                                      " (in 'networkModel', line 230, column 8 to column 53)",
                                                      " (in 'networkModel', line 231, column 8 to column 38)",
                                                      " (in 'networkModel', line 228, column 24 to line 232, column 7)",
                                                      " (in 'networkModel', line 228, column 6 to line 232, column 7)",
                                                      " (in 'networkModel', line 233, column 6 to column 19)",
                                                      " (in 'networkModel', line 226, column 11 to line 234, column 5)",
                                                      " (in 'networkModel', line 217, column 8 to column 57)",
                                                      " (in 'networkModel', line 218, column 8 to column 53)",
                                                      " (in 'networkModel', line 220, column 10 to column 60)",
                                                      " (in 'networkModel', line 221, column 10 to column 56)",
                                                      " (in 'networkModel', line 219, column 42 to line 222, column 9)",
                                                      " (in 'networkModel', line 219, column 8 to line 222, column 9)",
                                                      " (in 'networkModel', line 223, column 8 to column 38)",
                                                      " (in 'networkModel', line 216, column 24 to line 224, column 7)",
                                                      " (in 'networkModel', line 216, column 6 to line 224, column 7)",
                                                      " (in 'networkModel', line 225, column 6 to column 19)",
                                                      " (in 'networkModel', line 214, column 26 to line 226, column 5)",
                                                      " (in 'networkModel', line 214, column 4 to line 234, column 5)",
                                                      " (in 'networkModel', line 210, column 78 to line 235, column 3)",
                                                      " (in 'networkModel', line 269, column 10 to column 17)",
                                                      " (in 'networkModel', line 269, column 4 to column 55)",
                                                      " (in 'networkModel', line 270, column 4 to column 19)",
                                                      " (in 'networkModel', line 271, column 4 to column 17)",
                                                      " (in 'networkModel', line 287, column 8 to column 57)",
                                                      " (in 'networkModel', line 288, column 8 to column 53)",
                                                      " (in 'networkModel', line 289, column 8 to column 50)",
                                                      " (in 'networkModel', line 286, column 24 to line 290, column 7)",
                                                      " (in 'networkModel', line 286, column 6 to line 290, column 7)",
                                                      " (in 'networkModel', line 291, column 6 to column 19)",
                                                      " (in 'networkModel', line 284, column 11 to line 292, column 5)",
                                                      " (in 'networkModel', line 275, column 8 to column 57)",
                                                      " (in 'networkModel', line 276, column 8 to column 53)",
                                                      " (in 'networkModel', line 278, column 10 to column 60)",
                                                      " (in 'networkModel', line 279, column 10 to column 56)",
                                                      " (in 'networkModel', line 277, column 42 to line 280, column 9)",
                                                      " (in 'networkModel', line 277, column 8 to line 280, column 9)",
                                                      " (in 'networkModel', line 281, column 8 to column 50)",
                                                      " (in 'networkModel', line 274, column 24 to line 282, column 7)",
                                                      " (in 'networkModel', line 274, column 6 to line 282, column 7)",
                                                      " (in 'networkModel', line 283, column 4 to column 17)",
                                                      " (in 'networkModel', line 272, column 26 to line 284, column 5)",
                                                      " (in 'networkModel', line 272, column 4 to line 292, column 5)",
                                                      " (in 'networkModel', line 268, column 78 to line 293, column 3)"};
template <typename T7__>
Eigen::Matrix<stan::promote_args_t<T7__>, -1, -1>
buildTransferMatrix(const int& nComps, const int& nSteady,
                    const std::vector<int>& steadyIndices,
                    const int& nUpsilons,
                    const std::vector<std::vector<int>>& mappingU,
                    const int& nLambdas,
                    const std::vector<std::vector<int>>& mappingL,
                    const std::vector<T7__>& params, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T7__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 450;
    validate_non_negative_index("transfer", "nComps", nComps);
    current_statement__ = 451;
    validate_non_negative_index("transfer", "nComps", nComps);
    Eigen::Matrix<local_scalar_t__, -1, -1> transfer;
    transfer = Eigen::Matrix<local_scalar_t__, -1, -1>(nComps, nComps);
    stan::math::fill(transfer, DUMMY_VAR__);
    
    current_statement__ = 452;
    assign(transfer, nil_index_list(), rep_matrix(0, nComps, nComps),
      "assigning variable transfer");
    current_statement__ = 453;
    validate_non_negative_index("lossRates", "nComps", nComps);
    Eigen::Matrix<local_scalar_t__, -1, 1> lossRates;
    lossRates = Eigen::Matrix<local_scalar_t__, -1, 1>(nComps);
    stan::math::fill(lossRates, DUMMY_VAR__);
    
    current_statement__ = 454;
    assign(lossRates, nil_index_list(), rep_vector(0, nComps),
      "assigning variable lossRates");
    current_statement__ = 458;
    for (int k = 1; k <= nUpsilons; ++k) {
      current_statement__ = 455;
      assign(transfer,
        cons_list(index_uni(mappingU[(k - 1)][(2 - 1)]),
          cons_list(index_uni(mappingU[(k - 1)][(1 - 1)]), nil_index_list())),
        params[(mappingU[(k - 1)][(3 - 1)] - 1)],
        "assigning variable transfer");
      current_statement__ = 456;
      assign(lossRates,
        cons_list(index_uni(mappingU[(k - 1)][(1 - 1)]), nil_index_list()),
        (lossRates[(mappingU[(k - 1)][(1 - 1)] - 1)] +
          params[(mappingU[(k - 1)][(3 - 1)] - 1)]),
        "assigning variable lossRates");}
    current_statement__ = 461;
    for (int k = 1; k <= nLambdas; ++k) {
      current_statement__ = 459;
      assign(lossRates,
        cons_list(index_uni(mappingL[(k - 1)][(1 - 1)]), nil_index_list()),
        (lossRates[(mappingL[(k - 1)][(1 - 1)] - 1)] +
          params[(mappingL[(k - 1)][(2 - 1)] - 1)]),
        "assigning variable lossRates");}
    current_statement__ = 464;
    for (int k = 1; k <= nComps; ++k) {
      current_statement__ = 462;
      assign(transfer,
        cons_list(index_uni(k), cons_list(index_uni(k), nil_index_list())),
        (rvalue(transfer,
           cons_list(index_uni(k), cons_list(index_uni(k), nil_index_list())),
           "transfer") - lossRates[(k - 1)]), "assigning variable transfer");
    }
    current_statement__ = 469;
    if (logical_gt(nSteady, 0)) {
      current_statement__ = 467;
      for (int k = 1; k <= nSteady; ++k) {
        current_statement__ = 465;
        assign(transfer,
          cons_list(index_uni(steadyIndices[(k - 1)]),
            cons_list(index_uni(steadyIndices[(k - 1)]), nil_index_list())),
          0, "assigning variable transfer");}
    } 
    current_statement__ = 470;
    return transfer;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct buildTransferMatrix_functor__ {
template <typename T7__>
Eigen::Matrix<stan::promote_args_t<T7__>, -1, -1>
operator()(const int& nComps, const int& nSteady,
           const std::vector<int>& steadyIndices, const int& nUpsilons,
           const std::vector<std::vector<int>>& mappingU,
           const int& nLambdas,
           const std::vector<std::vector<int>>& mappingL,
           const std::vector<T7__>& params, std::ostream* pstream__)  const 
{
return buildTransferMatrix(nComps, nSteady, steadyIndices, nUpsilons,
         mappingU, nLambdas, mappingL, params, pstream__);
}
};
template <typename T1__, typename T2__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T1__>,
T2__>, -1, -1>
buildTransferMatrixDecay(const int& nComps, const T1__& transferRef_arg__,
                         const T2__& lambda_decay, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T1__>,
          T2__>;
  const auto& transferRef = to_ref(transferRef_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 472;
    validate_non_negative_index("transfer", "nComps", nComps);
    current_statement__ = 473;
    validate_non_negative_index("transfer", "nComps", nComps);
    Eigen::Matrix<local_scalar_t__, -1, -1> transfer;
    transfer = Eigen::Matrix<local_scalar_t__, -1, -1>(nComps, nComps);
    stan::math::fill(transfer, DUMMY_VAR__);
    
    current_statement__ = 474;
    assign(transfer, nil_index_list(), transferRef,
      "assigning variable transfer");
    current_statement__ = 477;
    for (int k = 1; k <= nComps; ++k) {
      current_statement__ = 475;
      assign(transfer,
        cons_list(index_uni(k), cons_list(index_uni(k), nil_index_list())),
        (rvalue(transfer,
           cons_list(index_uni(k), cons_list(index_uni(k), nil_index_list())),
           "transfer") - lambda_decay), "assigning variable transfer");}
    current_statement__ = 478;
    return transfer;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct buildTransferMatrixDecay_functor__ {
template <typename T1__, typename T2__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T1__>,
T2__>, -1, -1>
operator()(const int& nComps, const T1__& transferRef,
           const T2__& lambda_decay, std::ostream* pstream__)  const 
{
return buildTransferMatrixDecay(nComps, transferRef, lambda_decay, pstream__);
}
};
template <typename T5__, typename T6__>
Eigen::Matrix<stan::promote_args_t<T5__,
T6__>, -1, -1>
buildTransitionMatrix(const int& nComps, const int& nUpsilons,
                      const std::vector<std::vector<int>>& mappingU,
                      const int& nLambdas,
                      const std::vector<std::vector<int>>& mappingL,
                      const T5__& dt, const std::vector<T6__>& params,
                      std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T5__, T6__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 480;
    validate_non_negative_index("transition", "nComps", nComps);
    current_statement__ = 481;
    validate_non_negative_index("transition", "nComps", nComps);
    Eigen::Matrix<local_scalar_t__, -1, -1> transition;
    transition = Eigen::Matrix<local_scalar_t__, -1, -1>(nComps, nComps);
    stan::math::fill(transition, DUMMY_VAR__);
    
    current_statement__ = 482;
    assign(transition, nil_index_list(), rep_matrix(0, nComps, nComps),
      "assigning variable transition");
    current_statement__ = 483;
    validate_non_negative_index("lossRates", "nComps", nComps);
    Eigen::Matrix<local_scalar_t__, -1, 1> lossRates;
    lossRates = Eigen::Matrix<local_scalar_t__, -1, 1>(nComps);
    stan::math::fill(lossRates, DUMMY_VAR__);
    
    current_statement__ = 484;
    assign(lossRates, nil_index_list(), rep_vector(0, nComps),
      "assigning variable lossRates");
    current_statement__ = 488;
    for (int k = 1; k <= nUpsilons; ++k) {
      current_statement__ = 485;
      assign(transition,
        cons_list(index_uni(mappingU[(k - 1)][(2 - 1)]),
          cons_list(index_uni(mappingU[(k - 1)][(1 - 1)]), nil_index_list())),
        params[(mappingU[(k - 1)][(3 - 1)] - 1)],
        "assigning variable transition");
      current_statement__ = 486;
      assign(lossRates,
        cons_list(index_uni(mappingU[(k - 1)][(1 - 1)]), nil_index_list()),
        (lossRates[(mappingU[(k - 1)][(1 - 1)] - 1)] +
          params[(mappingU[(k - 1)][(3 - 1)] - 1)]),
        "assigning variable lossRates");}
    current_statement__ = 491;
    for (int k = 1; k <= nLambdas; ++k) {
      current_statement__ = 489;
      assign(lossRates,
        cons_list(index_uni(mappingL[(k - 1)][(1 - 1)]), nil_index_list()),
        (lossRates[(mappingL[(k - 1)][(1 - 1)] - 1)] +
          params[(mappingL[(k - 1)][(2 - 1)] - 1)]),
        "assigning variable lossRates");}
    current_statement__ = 492;
    assign(transition, nil_index_list(),
      multiply(stan::model::deep_copy(transition), dt),
      "assigning variable transition");
    current_statement__ = 493;
    assign(lossRates, nil_index_list(),
      multiply(stan::model::deep_copy(lossRates), dt),
      "assigning variable lossRates");
    current_statement__ = 496;
    for (int k = 1; k <= nComps; ++k) {
      current_statement__ = 494;
      assign(transition,
        cons_list(index_uni(k), cons_list(index_uni(k), nil_index_list())),
        (rvalue(transition,
           cons_list(index_uni(k), cons_list(index_uni(k), nil_index_list())),
           "transition") + (1 - lossRates[(k - 1)])),
        "assigning variable transition");}
    current_statement__ = 497;
    return transition;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct buildTransitionMatrix_functor__ {
template <typename T5__, typename T6__>
Eigen::Matrix<stan::promote_args_t<T5__,
T6__>, -1, -1>
operator()(const int& nComps, const int& nUpsilons,
           const std::vector<std::vector<int>>& mappingU,
           const int& nLambdas,
           const std::vector<std::vector<int>>& mappingL, const T5__& dt,
           const std::vector<T6__>& params, std::ostream* pstream__)  const 
{
return buildTransitionMatrix(nComps, nUpsilons, mappingU, nLambdas, mappingL,
         dt, params, pstream__);
}
};
template <typename T1__, typename T2__, typename T3__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T1__>, T2__,
T3__>, -1, -1>
buildTransitionMatrixDecay(const int& nComps,
                           const T1__& transitionRef_arg__,
                           const T2__& lambda_decay, const T3__& dt,
                           std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T1__>,
          T2__,
          T3__>;
  const auto& transitionRef = to_ref(transitionRef_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 499;
    validate_non_negative_index("transition", "nComps", nComps);
    current_statement__ = 500;
    validate_non_negative_index("transition", "nComps", nComps);
    Eigen::Matrix<local_scalar_t__, -1, -1> transition;
    transition = Eigen::Matrix<local_scalar_t__, -1, -1>(nComps, nComps);
    stan::math::fill(transition, DUMMY_VAR__);
    
    current_statement__ = 501;
    assign(transition, nil_index_list(), transitionRef,
      "assigning variable transition");
    current_statement__ = 504;
    for (int k = 1; k <= nComps; ++k) {
      current_statement__ = 502;
      assign(transition,
        cons_list(index_uni(k), cons_list(index_uni(k), nil_index_list())),
        (rvalue(transition,
           cons_list(index_uni(k), cons_list(index_uni(k), nil_index_list())),
           "transition") - (lambda_decay * dt)),
        "assigning variable transition");}
    current_statement__ = 505;
    return transition;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct buildTransitionMatrixDecay_functor__ {
template <typename T1__, typename T2__, typename T3__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T1__>, T2__,
T3__>, -1, -1>
operator()(const int& nComps, const T1__& transitionRef,
           const T2__& lambda_decay, const T3__& dt, std::ostream* pstream__)  const 
{
return buildTransitionMatrixDecay(nComps, transitionRef, lambda_decay, dt,
         pstream__);
}
};
template <typename T3__, typename T4__, typename T8__>
std::vector<stan::promote_args_t<T3__, T4__,
T8__>>
buildSizePredictions(const int& nObs, const int& currentGroup,
                     const int& maxNobs,
                     const std::vector<Eigen::Matrix<T3__, -1, 1>>& unmarked,
                     const std::vector<Eigen::Matrix<T4__, -1, 1>>& marked,
                     const std::vector<std::vector<int>>& indices,
                     const int& splitPresent,
                     const std::vector<int>& splitComps,
                     const std::vector<std::vector<T8__>>& initRefr,
                     std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T3__, T4__, T8__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 507;
    validate_non_negative_index("pred", "maxNobs", maxNobs);
    std::vector<local_scalar_t__> pred;
    pred = std::vector<local_scalar_t__>(maxNobs, DUMMY_VAR__);
    
    current_statement__ = 508;
    assign(pred, nil_index_list(), rep_array(0.0, maxNobs),
      "assigning variable pred");
    local_scalar_t__ unmarkedQ;
    unmarkedQ = DUMMY_VAR__;
    
    local_scalar_t__ markedQ;
    markedQ = DUMMY_VAR__;
    
    current_statement__ = 529;
    if (logical_gt(splitPresent, 0)) {
      current_statement__ = 526;
      for (int k = 1; k <= nObs; ++k) {
        current_statement__ = 518;
        unmarkedQ = unmarked[(indices[(k - 1)][(2 - 1)] - 1)][(indices[
                                                                (k - 1)][
                                                                (1 - 1)] - 1)];
        current_statement__ = 519;
        markedQ = marked[(indices[(k - 1)][(2 - 1)] - 1)][(indices[(k - 1)][
                                                            (1 - 1)] - 1)];
        current_statement__ = 523;
        if (logical_gt(splitComps[(indices[(k - 1)][(1 - 1)] - 1)], 0)) {
          current_statement__ = 520;
          unmarkedQ = (unmarkedQ +
                        initRefr[(indices[(k - 1)][(1 - 1)] - 1)][(1 - 1)]);
          current_statement__ = 521;
          markedQ = (markedQ +
                      initRefr[(indices[(k - 1)][(1 - 1)] - 1)][(2 - 1)]);
        } 
        current_statement__ = 524;
        assign(pred, cons_list(index_uni(k), nil_index_list()),
          (unmarkedQ + markedQ), "assigning variable pred");}
      current_statement__ = 527;
      return pred;
    } else {
      current_statement__ = 515;
      for (int k = 1; k <= nObs; ++k) {
        current_statement__ = 511;
        unmarkedQ = unmarked[(indices[(k - 1)][(2 - 1)] - 1)][(indices[
                                                                (k - 1)][
                                                                (1 - 1)] - 1)];
        current_statement__ = 512;
        markedQ = marked[(indices[(k - 1)][(2 - 1)] - 1)][(indices[(k - 1)][
                                                            (1 - 1)] - 1)];
        current_statement__ = 513;
        assign(pred, cons_list(index_uni(k), nil_index_list()),
          (unmarkedQ + markedQ), "assigning variable pred");}
      current_statement__ = 516;
      return pred;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct buildSizePredictions_functor__ {
template <typename T3__, typename T4__, typename T8__>
std::vector<stan::promote_args_t<T3__, T4__,
T8__>>
operator()(const int& nObs, const int& currentGroup, const int& maxNobs,
           const std::vector<Eigen::Matrix<T3__, -1, 1>>& unmarked,
           const std::vector<Eigen::Matrix<T4__, -1, 1>>& marked,
           const std::vector<std::vector<int>>& indices,
           const int& splitPresent, const std::vector<int>& splitComps,
           const std::vector<std::vector<T8__>>& initRefr,
           std::ostream* pstream__)  const 
{
return buildSizePredictions(nObs, currentGroup, maxNobs, unmarked, marked,
         indices, splitPresent, splitComps, initRefr, pstream__);
}
};
template <typename T3__, typename T4__, typename T8__>
std::vector<stan::promote_args_t<T3__, T4__,
T8__>>
buildPropPredictions(const int& nObs, const int& currentGroup,
                     const int& maxNobs,
                     const std::vector<Eigen::Matrix<T3__, -1, 1>>& unmarked,
                     const std::vector<Eigen::Matrix<T4__, -1, 1>>& marked,
                     const std::vector<std::vector<int>>& indices,
                     const int& splitPresent,
                     const std::vector<int>& splitComps,
                     const std::vector<std::vector<T8__>>& initRefr,
                     std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T3__, T4__, T8__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 531;
    validate_non_negative_index("pred", "maxNobs", maxNobs);
    std::vector<local_scalar_t__> pred;
    pred = std::vector<local_scalar_t__>(maxNobs, DUMMY_VAR__);
    
    current_statement__ = 532;
    assign(pred, nil_index_list(), rep_array(0.0, maxNobs),
      "assigning variable pred");
    local_scalar_t__ unmarkedQ;
    unmarkedQ = DUMMY_VAR__;
    
    local_scalar_t__ markedQ;
    markedQ = DUMMY_VAR__;
    
    current_statement__ = 553;
    if (logical_gt(splitPresent, 0)) {
      current_statement__ = 550;
      for (int k = 1; k <= nObs; ++k) {
        current_statement__ = 542;
        unmarkedQ = unmarked[(indices[(k - 1)][(2 - 1)] - 1)][(indices[
                                                                (k - 1)][
                                                                (1 - 1)] - 1)];
        current_statement__ = 543;
        markedQ = marked[(indices[(k - 1)][(2 - 1)] - 1)][(indices[(k - 1)][
                                                            (1 - 1)] - 1)];
        current_statement__ = 547;
        if (logical_gt(splitComps[(indices[(k - 1)][(1 - 1)] - 1)], 0)) {
          current_statement__ = 544;
          unmarkedQ = (unmarkedQ +
                        initRefr[(indices[(k - 1)][(1 - 1)] - 1)][(1 - 1)]);
          current_statement__ = 545;
          markedQ = (markedQ +
                      initRefr[(indices[(k - 1)][(1 - 1)] - 1)][(2 - 1)]);
        } 
        current_statement__ = 548;
        assign(pred, cons_list(index_uni(k), nil_index_list()),
          (markedQ / (unmarkedQ + markedQ)), "assigning variable pred");}
      current_statement__ = 551;
      return pred;
    } else {
      current_statement__ = 539;
      for (int k = 1; k <= nObs; ++k) {
        current_statement__ = 535;
        unmarkedQ = unmarked[(indices[(k - 1)][(2 - 1)] - 1)][(indices[
                                                                (k - 1)][
                                                                (1 - 1)] - 1)];
        current_statement__ = 536;
        markedQ = marked[(indices[(k - 1)][(2 - 1)] - 1)][(indices[(k - 1)][
                                                            (1 - 1)] - 1)];
        current_statement__ = 537;
        assign(pred, cons_list(index_uni(k), nil_index_list()),
          (markedQ / (unmarkedQ + markedQ)), "assigning variable pred");}
      current_statement__ = 540;
      return pred;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct buildPropPredictions_functor__ {
template <typename T3__, typename T4__, typename T8__>
std::vector<stan::promote_args_t<T3__, T4__,
T8__>>
operator()(const int& nObs, const int& currentGroup, const int& maxNobs,
           const std::vector<Eigen::Matrix<T3__, -1, 1>>& unmarked,
           const std::vector<Eigen::Matrix<T4__, -1, 1>>& marked,
           const std::vector<std::vector<int>>& indices,
           const int& splitPresent, const std::vector<int>& splitComps,
           const std::vector<std::vector<T8__>>& initRefr,
           std::ostream* pstream__)  const 
{
return buildPropPredictions(nObs, currentGroup, maxNobs, unmarked, marked,
         indices, splitPresent, splitComps, initRefr, pstream__);
}
};
#include <stan_meta_header.hpp>
class model_networkModel final : public model_base_crtp<model_networkModel> {
private:
  int ode_method;
  int nComps;
  int nGroups;
  int nParams;
  int nNonConstantPriors;
  int nPriorUniform_code1;
  int nPriorHcauchy_code2;
  int nPriorBeta_code3;
  int nPriorTrNormal_code4;
  int nPriorExponential_code5;
  int nPriorGamma_code6;
  std::vector<double> constantParams;
  std::vector<double> lowerParams;
  std::vector<double> upperParams;
  std::vector<double> hcauchyScaleParams;
  std::vector<double> rawBetaAlpha;
  std::vector<double> rawBetaBeta;
  std::vector<double> betaScaleParams;
  std::vector<double> trNormMeanParams;
  std::vector<double> trNormSdParams;
  std::vector<double> exponentialRateParams;
  std::vector<double> gammaAlphaParams;
  std::vector<double> gammaBetaParams;
  std::vector<int> mappingParamPriorType;
  std::vector<int> mappingParamPriorID;
  int propFamily;
  int sizeFamily;
  std::vector<std::vector<std::vector<double>>> initialQuantities;
  int maxNsteady;
  std::vector<int> nSteady;
  std::vector<std::vector<int>> steadyIndices;
  int splitPresent;
  std::vector<std::vector<int>> splitComps;
  std::vector<std::vector<int>> piMapping;
  double lambda_decay;
  int maxNupsilons;
  std::vector<int> nUpsilons;
  std::vector<std::vector<std::vector<int>>> upsilonMapping;
  int maxNlambdas;
  std::vector<int> nLambdas;
  std::vector<std::vector<std::vector<int>>> lambdaMapping;
  int maxNpulseEvents;
  std::vector<int> nPulseEvents;
  std::vector<std::vector<std::vector<int>>> pulseEventsIndices;
  std::vector<std::vector<std::vector<double>>> pulseEventsQuantities;
  int maxNsizesObs;
  int maxNpropsObs;
  std::vector<int> nSizesObs;
  std::vector<int> nPropsObs;
  std::vector<std::vector<std::vector<int>>> sizesObsIndices;
  std::vector<std::vector<std::vector<int>>> propsObsIndices;
  std::vector<std::vector<double>> sizesObs;
  std::vector<std::vector<double>> propsObs;
  int maxNtimeIntervals;
  std::vector<int> nTimeIntervals;
  std::vector<std::vector<double>> intervalsLengths;
  int maxNobsTimes;
  std::vector<int> nObsTimes;
  std::vector<std::vector<double>> elapsedTimeSinceEvent;
  std::vector<std::vector<int>> obsIntervalsIndices;
  int maxNtimesteps;
  std::vector<int> nTimesteps;
  int maxNuniqueDts;
  std::vector<int> nUniqueDts;
  std::vector<std::vector<double>> unique_dts;
  std::vector<std::vector<int>> timesteps;
  int nTotal;
  int n_quantity_records;
 
public:
  ~model_networkModel() { }
  
  inline std::string model_name() const final { return "model_networkModel"; }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = stanc3 v2.26.1-4-gd72b68b7-dirty", "stancflags = "};
  }
  
  
  model_networkModel(stan::io::var_context& context__,
                     unsigned int random_seed__ = 0,
                     std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "model_networkModel_namespace::model_networkModel";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      current_statement__ = 263;
      context__.validate_dims("data initialization","ode_method","int",
          context__.to_vec());
      ode_method = std::numeric_limits<int>::min();
      
      current_statement__ = 263;
      ode_method = context__.vals_i("ode_method")[(1 - 1)];
      current_statement__ = 263;
      current_statement__ = 263;
      check_greater_or_equal(function__, "ode_method", ode_method, 1);
      current_statement__ = 263;
      current_statement__ = 263;
      check_less_or_equal(function__, "ode_method", ode_method, 2);
      current_statement__ = 264;
      context__.validate_dims("data initialization","nComps","int",
          context__.to_vec());
      nComps = std::numeric_limits<int>::min();
      
      current_statement__ = 264;
      nComps = context__.vals_i("nComps")[(1 - 1)];
      current_statement__ = 264;
      current_statement__ = 264;
      check_greater_or_equal(function__, "nComps", nComps, 1);
      current_statement__ = 265;
      context__.validate_dims("data initialization","nGroups","int",
          context__.to_vec());
      nGroups = std::numeric_limits<int>::min();
      
      current_statement__ = 265;
      nGroups = context__.vals_i("nGroups")[(1 - 1)];
      current_statement__ = 265;
      current_statement__ = 265;
      check_greater_or_equal(function__, "nGroups", nGroups, 0);
      current_statement__ = 266;
      context__.validate_dims("data initialization","nParams","int",
          context__.to_vec());
      nParams = std::numeric_limits<int>::min();
      
      current_statement__ = 266;
      nParams = context__.vals_i("nParams")[(1 - 1)];
      current_statement__ = 266;
      current_statement__ = 266;
      check_greater_or_equal(function__, "nParams", nParams, 0);
      current_statement__ = 267;
      context__.validate_dims("data initialization","nNonConstantPriors",
          "int",context__.to_vec());
      nNonConstantPriors = std::numeric_limits<int>::min();
      
      current_statement__ = 267;
      nNonConstantPriors = context__.vals_i("nNonConstantPriors")[(1 - 1)];
      current_statement__ = 267;
      current_statement__ = 267;
      check_greater_or_equal(function__, "nNonConstantPriors",
                             nNonConstantPriors, 1);
      current_statement__ = 268;
      context__.validate_dims("data initialization","nPriorUniform_code1",
          "int",context__.to_vec());
      nPriorUniform_code1 = std::numeric_limits<int>::min();
      
      current_statement__ = 268;
      nPriorUniform_code1 = context__.vals_i("nPriorUniform_code1")[(1 - 1)];
      current_statement__ = 268;
      current_statement__ = 268;
      check_greater_or_equal(function__, "nPriorUniform_code1",
                             nPriorUniform_code1, 0);
      current_statement__ = 269;
      context__.validate_dims("data initialization","nPriorHcauchy_code2",
          "int",context__.to_vec());
      nPriorHcauchy_code2 = std::numeric_limits<int>::min();
      
      current_statement__ = 269;
      nPriorHcauchy_code2 = context__.vals_i("nPriorHcauchy_code2")[(1 - 1)];
      current_statement__ = 269;
      current_statement__ = 269;
      check_greater_or_equal(function__, "nPriorHcauchy_code2",
                             nPriorHcauchy_code2, 0);
      current_statement__ = 270;
      context__.validate_dims("data initialization","nPriorBeta_code3","int",
          context__.to_vec());
      nPriorBeta_code3 = std::numeric_limits<int>::min();
      
      current_statement__ = 270;
      nPriorBeta_code3 = context__.vals_i("nPriorBeta_code3")[(1 - 1)];
      current_statement__ = 270;
      current_statement__ = 270;
      check_greater_or_equal(function__, "nPriorBeta_code3",
                             nPriorBeta_code3, 0);
      current_statement__ = 271;
      context__.validate_dims("data initialization","nPriorTrNormal_code4",
          "int",context__.to_vec());
      nPriorTrNormal_code4 = std::numeric_limits<int>::min();
      
      current_statement__ = 271;
      nPriorTrNormal_code4 = context__.vals_i("nPriorTrNormal_code4")[
          (1 - 1)];
      current_statement__ = 271;
      current_statement__ = 271;
      check_greater_or_equal(function__, "nPriorTrNormal_code4",
                             nPriorTrNormal_code4, 0);
      current_statement__ = 272;
      context__.validate_dims("data initialization",
          "nPriorExponential_code5","int",context__.to_vec());
      nPriorExponential_code5 = std::numeric_limits<int>::min();
      
      current_statement__ = 272;
      nPriorExponential_code5 = context__.vals_i("nPriorExponential_code5")[
          (1 - 1)];
      current_statement__ = 272;
      current_statement__ = 272;
      check_greater_or_equal(function__, "nPriorExponential_code5",
                             nPriorExponential_code5, 0);
      current_statement__ = 273;
      context__.validate_dims("data initialization","nPriorGamma_code6",
          "int",context__.to_vec());
      nPriorGamma_code6 = std::numeric_limits<int>::min();
      
      current_statement__ = 273;
      nPriorGamma_code6 = context__.vals_i("nPriorGamma_code6")[(1 - 1)];
      current_statement__ = 273;
      current_statement__ = 273;
      check_greater_or_equal(function__, "nPriorGamma_code6",
                             nPriorGamma_code6, 0);
      current_statement__ = 274;
      validate_non_negative_index("constantParams", "nParams", nParams);
      current_statement__ = 275;
      context__.validate_dims("data initialization","constantParams",
          "double",context__.to_vec(nParams));
      constantParams = std::vector<double>(nParams, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 275;
      assign(constantParams, nil_index_list(),
        context__.vals_r("constantParams"),
        "assigning variable constantParams");
      current_statement__ = 276;
      validate_non_negative_index("lowerParams", "nParams", nParams);
      current_statement__ = 277;
      context__.validate_dims("data initialization","lowerParams","double",
          context__.to_vec(nParams));
      lowerParams = std::vector<double>(nParams, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 277;
      assign(lowerParams, nil_index_list(), context__.vals_r("lowerParams"),
        "assigning variable lowerParams");
      current_statement__ = 278;
      validate_non_negative_index("upperParams", "nParams", nParams);
      current_statement__ = 279;
      context__.validate_dims("data initialization","upperParams","double",
          context__.to_vec(nParams));
      upperParams = std::vector<double>(nParams, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 279;
      assign(upperParams, nil_index_list(), context__.vals_r("upperParams"),
        "assigning variable upperParams");
      current_statement__ = 280;
      validate_non_negative_index("hcauchyScaleParams", "nParams", nParams);
      current_statement__ = 281;
      context__.validate_dims("data initialization","hcauchyScaleParams",
          "double",context__.to_vec(nParams));
      hcauchyScaleParams = std::vector<double>(nParams, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 281;
      assign(hcauchyScaleParams, nil_index_list(),
        context__.vals_r("hcauchyScaleParams"),
        "assigning variable hcauchyScaleParams");
      current_statement__ = 282;
      validate_non_negative_index("rawBetaAlpha", "nParams", nParams);
      current_statement__ = 283;
      context__.validate_dims("data initialization","rawBetaAlpha","double",
          context__.to_vec(nParams));
      rawBetaAlpha = std::vector<double>(nParams, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 283;
      assign(rawBetaAlpha, nil_index_list(),
        context__.vals_r("rawBetaAlpha"), "assigning variable rawBetaAlpha");
      current_statement__ = 283;
      for (int sym1__ = 1; sym1__ <= nParams; ++sym1__) {
        current_statement__ = 283;
        current_statement__ = 283;
        check_greater_or_equal(function__, "rawBetaAlpha[sym1__]",
                               rawBetaAlpha[(sym1__ - 1)], 0);}
      current_statement__ = 284;
      validate_non_negative_index("rawBetaBeta", "nParams", nParams);
      current_statement__ = 285;
      context__.validate_dims("data initialization","rawBetaBeta","double",
          context__.to_vec(nParams));
      rawBetaBeta = std::vector<double>(nParams, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 285;
      assign(rawBetaBeta, nil_index_list(), context__.vals_r("rawBetaBeta"),
        "assigning variable rawBetaBeta");
      current_statement__ = 285;
      for (int sym1__ = 1; sym1__ <= nParams; ++sym1__) {
        current_statement__ = 285;
        current_statement__ = 285;
        check_greater_or_equal(function__, "rawBetaBeta[sym1__]",
                               rawBetaBeta[(sym1__ - 1)], 0);}
      current_statement__ = 286;
      validate_non_negative_index("betaScaleParams", "nParams", nParams);
      current_statement__ = 287;
      context__.validate_dims("data initialization","betaScaleParams",
          "double",context__.to_vec(nParams));
      betaScaleParams = std::vector<double>(nParams, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 287;
      assign(betaScaleParams, nil_index_list(),
        context__.vals_r("betaScaleParams"),
        "assigning variable betaScaleParams");
      current_statement__ = 287;
      for (int sym1__ = 1; sym1__ <= nParams; ++sym1__) {
        current_statement__ = 287;
        current_statement__ = 287;
        check_greater_or_equal(function__, "betaScaleParams[sym1__]",
                               betaScaleParams[(sym1__ - 1)], 0);}
      current_statement__ = 288;
      validate_non_negative_index("trNormMeanParams", "nParams", nParams);
      current_statement__ = 289;
      context__.validate_dims("data initialization","trNormMeanParams",
          "double",context__.to_vec(nParams));
      trNormMeanParams = std::vector<double>(nParams, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 289;
      assign(trNormMeanParams, nil_index_list(),
        context__.vals_r("trNormMeanParams"),
        "assigning variable trNormMeanParams");
      current_statement__ = 290;
      validate_non_negative_index("trNormSdParams", "nParams", nParams);
      current_statement__ = 291;
      context__.validate_dims("data initialization","trNormSdParams",
          "double",context__.to_vec(nParams));
      trNormSdParams = std::vector<double>(nParams, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 291;
      assign(trNormSdParams, nil_index_list(),
        context__.vals_r("trNormSdParams"),
        "assigning variable trNormSdParams");
      current_statement__ = 292;
      validate_non_negative_index("exponentialRateParams", "nParams", nParams);
      current_statement__ = 293;
      context__.validate_dims("data initialization","exponentialRateParams",
          "double",context__.to_vec(nParams));
      exponentialRateParams = std::vector<double>(nParams, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 293;
      assign(exponentialRateParams, nil_index_list(),
        context__.vals_r("exponentialRateParams"),
        "assigning variable exponentialRateParams");
      current_statement__ = 294;
      validate_non_negative_index("gammaAlphaParams", "nParams", nParams);
      current_statement__ = 295;
      context__.validate_dims("data initialization","gammaAlphaParams",
          "double",context__.to_vec(nParams));
      gammaAlphaParams = std::vector<double>(nParams, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 295;
      assign(gammaAlphaParams, nil_index_list(),
        context__.vals_r("gammaAlphaParams"),
        "assigning variable gammaAlphaParams");
      current_statement__ = 296;
      validate_non_negative_index("gammaBetaParams", "nParams", nParams);
      current_statement__ = 297;
      context__.validate_dims("data initialization","gammaBetaParams",
          "double",context__.to_vec(nParams));
      gammaBetaParams = std::vector<double>(nParams, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 297;
      assign(gammaBetaParams, nil_index_list(),
        context__.vals_r("gammaBetaParams"),
        "assigning variable gammaBetaParams");
      current_statement__ = 298;
      validate_non_negative_index("mappingParamPriorType", "nParams", nParams);
      current_statement__ = 299;
      context__.validate_dims("data initialization","mappingParamPriorType",
          "int",context__.to_vec(nParams));
      mappingParamPriorType = std::vector<int>(nParams, std::numeric_limits<int>::min());
      
      current_statement__ = 299;
      assign(mappingParamPriorType, nil_index_list(),
        context__.vals_i("mappingParamPriorType"),
        "assigning variable mappingParamPriorType");
      current_statement__ = 299;
      for (int sym1__ = 1; sym1__ <= nParams; ++sym1__) {
        current_statement__ = 299;
        current_statement__ = 299;
        check_greater_or_equal(function__, "mappingParamPriorType[sym1__]",
                               mappingParamPriorType[(sym1__ - 1)], 0);}
      current_statement__ = 300;
      validate_non_negative_index("mappingParamPriorID", "nParams", nParams);
      current_statement__ = 301;
      context__.validate_dims("data initialization","mappingParamPriorID",
          "int",context__.to_vec(nParams));
      mappingParamPriorID = std::vector<int>(nParams, std::numeric_limits<int>::min());
      
      current_statement__ = 301;
      assign(mappingParamPriorID, nil_index_list(),
        context__.vals_i("mappingParamPriorID"),
        "assigning variable mappingParamPriorID");
      current_statement__ = 301;
      for (int sym1__ = 1; sym1__ <= nParams; ++sym1__) {
        current_statement__ = 301;
        current_statement__ = 301;
        check_greater_or_equal(function__, "mappingParamPriorID[sym1__]",
                               mappingParamPriorID[(sym1__ - 1)], 0);}
      current_statement__ = 302;
      context__.validate_dims("data initialization","propFamily","int",
          context__.to_vec());
      propFamily = std::numeric_limits<int>::min();
      
      current_statement__ = 302;
      propFamily = context__.vals_i("propFamily")[(1 - 1)];
      current_statement__ = 302;
      current_statement__ = 302;
      check_greater_or_equal(function__, "propFamily", propFamily, 1);
      current_statement__ = 302;
      current_statement__ = 302;
      check_less_or_equal(function__, "propFamily", propFamily, 4);
      current_statement__ = 303;
      context__.validate_dims("data initialization","sizeFamily","int",
          context__.to_vec());
      sizeFamily = std::numeric_limits<int>::min();
      
      current_statement__ = 303;
      sizeFamily = context__.vals_i("sizeFamily")[(1 - 1)];
      current_statement__ = 303;
      current_statement__ = 303;
      check_greater_or_equal(function__, "sizeFamily", sizeFamily, 1);
      current_statement__ = 303;
      current_statement__ = 303;
      check_less_or_equal(function__, "sizeFamily", sizeFamily, 2);
      current_statement__ = 304;
      validate_non_negative_index("initialQuantities", "nComps", nComps);
      current_statement__ = 305;
      validate_non_negative_index("initialQuantities", "nGroups", nGroups);
      current_statement__ = 306;
      context__.validate_dims("data initialization","initialQuantities",
          "double",context__.to_vec(nComps, 2, nGroups));
      initialQuantities = std::vector<std::vector<std::vector<double>>>(nComps, std::vector<std::vector<double>>(2, std::vector<double>(nGroups, std::numeric_limits<double>::quiet_NaN())));
      
      {
        std::vector<local_scalar_t__> initialQuantities_flat__;
        current_statement__ = 306;
        assign(initialQuantities_flat__, nil_index_list(),
          context__.vals_r("initialQuantities"),
          "assigning variable initialQuantities_flat__");
        current_statement__ = 306;
        pos__ = 1;
        current_statement__ = 306;
        for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
          current_statement__ = 306;
          for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
            current_statement__ = 306;
            for (int sym3__ = 1; sym3__ <= nComps; ++sym3__) {
              current_statement__ = 306;
              assign(initialQuantities,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                initialQuantities_flat__[(pos__ - 1)],
                "assigning variable initialQuantities");
              current_statement__ = 306;
              pos__ = (pos__ + 1);}}}
      }
      current_statement__ = 306;
      for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
        current_statement__ = 306;
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          current_statement__ = 306;
          for (int sym3__ = 1; sym3__ <= nGroups; ++sym3__) {
            current_statement__ = 306;
            current_statement__ = 306;
            check_greater_or_equal(function__,
                                   "initialQuantities[sym1__, sym2__, sym3__]",
                                   initialQuantities[(sym1__ - 1)][(sym2__ -
                                                                    1)][
                                   (sym3__ - 1)], 0);}}}
      current_statement__ = 307;
      context__.validate_dims("data initialization","maxNsteady","int",
          context__.to_vec());
      maxNsteady = std::numeric_limits<int>::min();
      
      current_statement__ = 307;
      maxNsteady = context__.vals_i("maxNsteady")[(1 - 1)];
      current_statement__ = 307;
      current_statement__ = 307;
      check_greater_or_equal(function__, "maxNsteady", maxNsteady, 0);
      current_statement__ = 308;
      validate_non_negative_index("nSteady", "nGroups + 1", (nGroups + 1));
      current_statement__ = 309;
      context__.validate_dims("data initialization","nSteady","int",
          context__.to_vec((nGroups + 1)));
      nSteady = std::vector<int>((nGroups + 1), std::numeric_limits<int>::min());
      
      current_statement__ = 309;
      assign(nSteady, nil_index_list(), context__.vals_i("nSteady"),
        "assigning variable nSteady");
      current_statement__ = 309;
      for (int sym1__ = 1; sym1__ <= (nGroups + 1); ++sym1__) {
        current_statement__ = 309;
        current_statement__ = 309;
        check_greater_or_equal(function__, "nSteady[sym1__]",
                               nSteady[(sym1__ - 1)], 0);}
      current_statement__ = 310;
      validate_non_negative_index("steadyIndices", "maxNsteady", maxNsteady);
      current_statement__ = 311;
      validate_non_negative_index("steadyIndices", "nGroups", nGroups);
      current_statement__ = 312;
      context__.validate_dims("data initialization","steadyIndices","int",
          context__.to_vec(maxNsteady, nGroups));
      steadyIndices = std::vector<std::vector<int>>(maxNsteady, std::vector<int>(nGroups, std::numeric_limits<int>::min()));
      
      {
        std::vector<int> steadyIndices_flat__;
        current_statement__ = 312;
        assign(steadyIndices_flat__, nil_index_list(),
          context__.vals_i("steadyIndices"),
          "assigning variable steadyIndices_flat__");
        current_statement__ = 312;
        pos__ = 1;
        current_statement__ = 312;
        for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
          current_statement__ = 312;
          for (int sym2__ = 1; sym2__ <= maxNsteady; ++sym2__) {
            current_statement__ = 312;
            assign(steadyIndices,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              steadyIndices_flat__[(pos__ - 1)],
              "assigning variable steadyIndices");
            current_statement__ = 312;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 312;
      for (int sym1__ = 1; sym1__ <= maxNsteady; ++sym1__) {
        current_statement__ = 312;
        for (int sym2__ = 1; sym2__ <= nGroups; ++sym2__) {
          current_statement__ = 312;
          current_statement__ = 312;
          check_greater_or_equal(function__, "steadyIndices[sym1__, sym2__]",
                                 steadyIndices[(sym1__ - 1)][(sym2__ - 1)], 0);
        }}
      current_statement__ = 313;
      context__.validate_dims("data initialization","splitPresent","int",
          context__.to_vec());
      splitPresent = std::numeric_limits<int>::min();
      
      current_statement__ = 313;
      splitPresent = context__.vals_i("splitPresent")[(1 - 1)];
      current_statement__ = 313;
      current_statement__ = 313;
      check_greater_or_equal(function__, "splitPresent", splitPresent, 0);
      current_statement__ = 313;
      current_statement__ = 313;
      check_less_or_equal(function__, "splitPresent", splitPresent, 1);
      current_statement__ = 314;
      validate_non_negative_index("splitComps", "nComps", nComps);
      current_statement__ = 315;
      validate_non_negative_index("splitComps", "nGroups", nGroups);
      current_statement__ = 316;
      context__.validate_dims("data initialization","splitComps","int",
          context__.to_vec(nComps, nGroups));
      splitComps = std::vector<std::vector<int>>(nComps, std::vector<int>(nGroups, std::numeric_limits<int>::min()));
      
      {
        std::vector<int> splitComps_flat__;
        current_statement__ = 316;
        assign(splitComps_flat__, nil_index_list(),
          context__.vals_i("splitComps"),
          "assigning variable splitComps_flat__");
        current_statement__ = 316;
        pos__ = 1;
        current_statement__ = 316;
        for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
          current_statement__ = 316;
          for (int sym2__ = 1; sym2__ <= nComps; ++sym2__) {
            current_statement__ = 316;
            assign(splitComps,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              splitComps_flat__[(pos__ - 1)], "assigning variable splitComps");
            current_statement__ = 316;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 316;
      for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
        current_statement__ = 316;
        for (int sym2__ = 1; sym2__ <= nGroups; ++sym2__) {
          current_statement__ = 316;
          current_statement__ = 316;
          check_greater_or_equal(function__, "splitComps[sym1__, sym2__]",
                                 splitComps[(sym1__ - 1)][(sym2__ - 1)], 0);}
      }
      current_statement__ = 316;
      for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
        current_statement__ = 316;
        for (int sym2__ = 1; sym2__ <= nGroups; ++sym2__) {
          current_statement__ = 316;
          current_statement__ = 316;
          check_less_or_equal(function__, "splitComps[sym1__, sym2__]",
                              splitComps[(sym1__ - 1)][(sym2__ - 1)], 1);}}
      current_statement__ = 317;
      validate_non_negative_index("piMapping", "nComps", nComps);
      current_statement__ = 318;
      validate_non_negative_index("piMapping", "nGroups", nGroups);
      current_statement__ = 319;
      context__.validate_dims("data initialization","piMapping","int",
          context__.to_vec(nComps, nGroups));
      piMapping = std::vector<std::vector<int>>(nComps, std::vector<int>(nGroups, std::numeric_limits<int>::min()));
      
      {
        std::vector<int> piMapping_flat__;
        current_statement__ = 319;
        assign(piMapping_flat__, nil_index_list(),
          context__.vals_i("piMapping"),
          "assigning variable piMapping_flat__");
        current_statement__ = 319;
        pos__ = 1;
        current_statement__ = 319;
        for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
          current_statement__ = 319;
          for (int sym2__ = 1; sym2__ <= nComps; ++sym2__) {
            current_statement__ = 319;
            assign(piMapping,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              piMapping_flat__[(pos__ - 1)], "assigning variable piMapping");
            current_statement__ = 319;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 319;
      for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
        current_statement__ = 319;
        for (int sym2__ = 1; sym2__ <= nGroups; ++sym2__) {
          current_statement__ = 319;
          current_statement__ = 319;
          check_greater_or_equal(function__, "piMapping[sym1__, sym2__]",
                                 piMapping[(sym1__ - 1)][(sym2__ - 1)], 0);}}
      current_statement__ = 320;
      context__.validate_dims("data initialization","lambda_decay","double",
          context__.to_vec());
      lambda_decay = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 320;
      lambda_decay = context__.vals_r("lambda_decay")[(1 - 1)];
      current_statement__ = 320;
      current_statement__ = 320;
      check_greater_or_equal(function__, "lambda_decay", lambda_decay, 0);
      current_statement__ = 321;
      context__.validate_dims("data initialization","maxNupsilons","int",
          context__.to_vec());
      maxNupsilons = std::numeric_limits<int>::min();
      
      current_statement__ = 321;
      maxNupsilons = context__.vals_i("maxNupsilons")[(1 - 1)];
      current_statement__ = 321;
      current_statement__ = 321;
      check_greater_or_equal(function__, "maxNupsilons", maxNupsilons, 0);
      current_statement__ = 322;
      validate_non_negative_index("nUpsilons", "nGroups + 1", (nGroups + 1));
      current_statement__ = 323;
      context__.validate_dims("data initialization","nUpsilons","int",
          context__.to_vec((nGroups + 1)));
      nUpsilons = std::vector<int>((nGroups + 1), std::numeric_limits<int>::min());
      
      current_statement__ = 323;
      assign(nUpsilons, nil_index_list(), context__.vals_i("nUpsilons"),
        "assigning variable nUpsilons");
      current_statement__ = 323;
      for (int sym1__ = 1; sym1__ <= (nGroups + 1); ++sym1__) {
        current_statement__ = 323;
        current_statement__ = 323;
        check_greater_or_equal(function__, "nUpsilons[sym1__]",
                               nUpsilons[(sym1__ - 1)], 0);}
      current_statement__ = 324;
      validate_non_negative_index("upsilonMapping", "maxNupsilons",
                                  maxNupsilons);
      current_statement__ = 325;
      validate_non_negative_index("upsilonMapping", "nGroups", nGroups);
      current_statement__ = 326;
      context__.validate_dims("data initialization","upsilonMapping","int",
          context__.to_vec(maxNupsilons, 3, nGroups));
      upsilonMapping = std::vector<std::vector<std::vector<int>>>(maxNupsilons, std::vector<std::vector<int>>(3, std::vector<int>(nGroups, std::numeric_limits<int>::min())));
      
      {
        std::vector<int> upsilonMapping_flat__;
        current_statement__ = 326;
        assign(upsilonMapping_flat__, nil_index_list(),
          context__.vals_i("upsilonMapping"),
          "assigning variable upsilonMapping_flat__");
        current_statement__ = 326;
        pos__ = 1;
        current_statement__ = 326;
        for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
          current_statement__ = 326;
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            current_statement__ = 326;
            for (int sym3__ = 1; sym3__ <= maxNupsilons; ++sym3__) {
              current_statement__ = 326;
              assign(upsilonMapping,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                upsilonMapping_flat__[(pos__ - 1)],
                "assigning variable upsilonMapping");
              current_statement__ = 326;
              pos__ = (pos__ + 1);}}}
      }
      current_statement__ = 326;
      for (int sym1__ = 1; sym1__ <= maxNupsilons; ++sym1__) {
        current_statement__ = 326;
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          current_statement__ = 326;
          for (int sym3__ = 1; sym3__ <= nGroups; ++sym3__) {
            current_statement__ = 326;
            current_statement__ = 326;
            check_greater_or_equal(function__,
                                   "upsilonMapping[sym1__, sym2__, sym3__]",
                                   upsilonMapping[(sym1__ - 1)][(sym2__ - 1)][
                                   (sym3__ - 1)], 0);}}}
      current_statement__ = 327;
      context__.validate_dims("data initialization","maxNlambdas","int",
          context__.to_vec());
      maxNlambdas = std::numeric_limits<int>::min();
      
      current_statement__ = 327;
      maxNlambdas = context__.vals_i("maxNlambdas")[(1 - 1)];
      current_statement__ = 327;
      current_statement__ = 327;
      check_greater_or_equal(function__, "maxNlambdas", maxNlambdas, 0);
      current_statement__ = 328;
      validate_non_negative_index("nLambdas", "nGroups + 1", (nGroups + 1));
      current_statement__ = 329;
      context__.validate_dims("data initialization","nLambdas","int",
          context__.to_vec((nGroups + 1)));
      nLambdas = std::vector<int>((nGroups + 1), std::numeric_limits<int>::min());
      
      current_statement__ = 329;
      assign(nLambdas, nil_index_list(), context__.vals_i("nLambdas"),
        "assigning variable nLambdas");
      current_statement__ = 329;
      for (int sym1__ = 1; sym1__ <= (nGroups + 1); ++sym1__) {
        current_statement__ = 329;
        current_statement__ = 329;
        check_greater_or_equal(function__, "nLambdas[sym1__]",
                               nLambdas[(sym1__ - 1)], 0);}
      current_statement__ = 330;
      validate_non_negative_index("lambdaMapping", "maxNlambdas", maxNlambdas);
      current_statement__ = 331;
      validate_non_negative_index("lambdaMapping", "nGroups", nGroups);
      current_statement__ = 332;
      context__.validate_dims("data initialization","lambdaMapping","int",
          context__.to_vec(maxNlambdas, 2, nGroups));
      lambdaMapping = std::vector<std::vector<std::vector<int>>>(maxNlambdas, std::vector<std::vector<int>>(2, std::vector<int>(nGroups, std::numeric_limits<int>::min())));
      
      {
        std::vector<int> lambdaMapping_flat__;
        current_statement__ = 332;
        assign(lambdaMapping_flat__, nil_index_list(),
          context__.vals_i("lambdaMapping"),
          "assigning variable lambdaMapping_flat__");
        current_statement__ = 332;
        pos__ = 1;
        current_statement__ = 332;
        for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
          current_statement__ = 332;
          for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
            current_statement__ = 332;
            for (int sym3__ = 1; sym3__ <= maxNlambdas; ++sym3__) {
              current_statement__ = 332;
              assign(lambdaMapping,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                lambdaMapping_flat__[(pos__ - 1)],
                "assigning variable lambdaMapping");
              current_statement__ = 332;
              pos__ = (pos__ + 1);}}}
      }
      current_statement__ = 332;
      for (int sym1__ = 1; sym1__ <= maxNlambdas; ++sym1__) {
        current_statement__ = 332;
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          current_statement__ = 332;
          for (int sym3__ = 1; sym3__ <= nGroups; ++sym3__) {
            current_statement__ = 332;
            current_statement__ = 332;
            check_greater_or_equal(function__,
                                   "lambdaMapping[sym1__, sym2__, sym3__]",
                                   lambdaMapping[(sym1__ - 1)][(sym2__ - 1)][
                                   (sym3__ - 1)], 0);}}}
      current_statement__ = 333;
      context__.validate_dims("data initialization","maxNpulseEvents","int",
          context__.to_vec());
      maxNpulseEvents = std::numeric_limits<int>::min();
      
      current_statement__ = 333;
      maxNpulseEvents = context__.vals_i("maxNpulseEvents")[(1 - 1)];
      current_statement__ = 333;
      current_statement__ = 333;
      check_greater_or_equal(function__, "maxNpulseEvents", maxNpulseEvents,
                             0);
      current_statement__ = 334;
      validate_non_negative_index("nPulseEvents", "nGroups + 1",
                                  (nGroups + 1));
      current_statement__ = 335;
      context__.validate_dims("data initialization","nPulseEvents","int",
          context__.to_vec((nGroups + 1)));
      nPulseEvents = std::vector<int>((nGroups + 1), std::numeric_limits<int>::min());
      
      current_statement__ = 335;
      assign(nPulseEvents, nil_index_list(),
        context__.vals_i("nPulseEvents"), "assigning variable nPulseEvents");
      current_statement__ = 335;
      for (int sym1__ = 1; sym1__ <= (nGroups + 1); ++sym1__) {
        current_statement__ = 335;
        current_statement__ = 335;
        check_greater_or_equal(function__, "nPulseEvents[sym1__]",
                               nPulseEvents[(sym1__ - 1)], 0);}
      current_statement__ = 336;
      validate_non_negative_index("pulseEventsIndices", "maxNpulseEvents",
                                  maxNpulseEvents);
      current_statement__ = 337;
      validate_non_negative_index("pulseEventsIndices", "nGroups", nGroups);
      current_statement__ = 338;
      context__.validate_dims("data initialization","pulseEventsIndices",
          "int",context__.to_vec(maxNpulseEvents, 2, nGroups));
      pulseEventsIndices = std::vector<std::vector<std::vector<int>>>(maxNpulseEvents, std::vector<std::vector<int>>(2, std::vector<int>(nGroups, std::numeric_limits<int>::min())));
      
      {
        std::vector<int> pulseEventsIndices_flat__;
        current_statement__ = 338;
        assign(pulseEventsIndices_flat__, nil_index_list(),
          context__.vals_i("pulseEventsIndices"),
          "assigning variable pulseEventsIndices_flat__");
        current_statement__ = 338;
        pos__ = 1;
        current_statement__ = 338;
        for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
          current_statement__ = 338;
          for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
            current_statement__ = 338;
            for (int sym3__ = 1; sym3__ <= maxNpulseEvents; ++sym3__) {
              current_statement__ = 338;
              assign(pulseEventsIndices,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                pulseEventsIndices_flat__[(pos__ - 1)],
                "assigning variable pulseEventsIndices");
              current_statement__ = 338;
              pos__ = (pos__ + 1);}}}
      }
      current_statement__ = 338;
      for (int sym1__ = 1; sym1__ <= maxNpulseEvents; ++sym1__) {
        current_statement__ = 338;
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          current_statement__ = 338;
          for (int sym3__ = 1; sym3__ <= nGroups; ++sym3__) {
            current_statement__ = 338;
            current_statement__ = 338;
            check_greater_or_equal(function__,
                                   "pulseEventsIndices[sym1__, sym2__, sym3__]",
                                   pulseEventsIndices[(sym1__ - 1)][(sym2__ -
                                                                    1)][
                                   (sym3__ - 1)], 0);}}}
      current_statement__ = 339;
      validate_non_negative_index("pulseEventsQuantities", "maxNpulseEvents",
                                  maxNpulseEvents);
      current_statement__ = 340;
      validate_non_negative_index("pulseEventsQuantities", "nGroups", nGroups);
      current_statement__ = 341;
      context__.validate_dims("data initialization","pulseEventsQuantities",
          "double",context__.to_vec(maxNpulseEvents, 2, nGroups));
      pulseEventsQuantities = std::vector<std::vector<std::vector<double>>>(maxNpulseEvents, std::vector<std::vector<double>>(2, std::vector<double>(nGroups, std::numeric_limits<double>::quiet_NaN())));
      
      {
        std::vector<local_scalar_t__> pulseEventsQuantities_flat__;
        current_statement__ = 341;
        assign(pulseEventsQuantities_flat__, nil_index_list(),
          context__.vals_r("pulseEventsQuantities"),
          "assigning variable pulseEventsQuantities_flat__");
        current_statement__ = 341;
        pos__ = 1;
        current_statement__ = 341;
        for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
          current_statement__ = 341;
          for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
            current_statement__ = 341;
            for (int sym3__ = 1; sym3__ <= maxNpulseEvents; ++sym3__) {
              current_statement__ = 341;
              assign(pulseEventsQuantities,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                pulseEventsQuantities_flat__[(pos__ - 1)],
                "assigning variable pulseEventsQuantities");
              current_statement__ = 341;
              pos__ = (pos__ + 1);}}}
      }
      current_statement__ = 342;
      context__.validate_dims("data initialization","maxNsizesObs","int",
          context__.to_vec());
      maxNsizesObs = std::numeric_limits<int>::min();
      
      current_statement__ = 342;
      maxNsizesObs = context__.vals_i("maxNsizesObs")[(1 - 1)];
      current_statement__ = 342;
      current_statement__ = 342;
      check_greater_or_equal(function__, "maxNsizesObs", maxNsizesObs, 0);
      current_statement__ = 343;
      context__.validate_dims("data initialization","maxNpropsObs","int",
          context__.to_vec());
      maxNpropsObs = std::numeric_limits<int>::min();
      
      current_statement__ = 343;
      maxNpropsObs = context__.vals_i("maxNpropsObs")[(1 - 1)];
      current_statement__ = 343;
      current_statement__ = 343;
      check_greater_or_equal(function__, "maxNpropsObs", maxNpropsObs, 0);
      current_statement__ = 344;
      validate_non_negative_index("nSizesObs", "nGroups + 1", (nGroups + 1));
      current_statement__ = 345;
      context__.validate_dims("data initialization","nSizesObs","int",
          context__.to_vec((nGroups + 1)));
      nSizesObs = std::vector<int>((nGroups + 1), std::numeric_limits<int>::min());
      
      current_statement__ = 345;
      assign(nSizesObs, nil_index_list(), context__.vals_i("nSizesObs"),
        "assigning variable nSizesObs");
      current_statement__ = 345;
      for (int sym1__ = 1; sym1__ <= (nGroups + 1); ++sym1__) {
        current_statement__ = 345;
        current_statement__ = 345;
        check_greater_or_equal(function__, "nSizesObs[sym1__]",
                               nSizesObs[(sym1__ - 1)], 0);}
      current_statement__ = 346;
      validate_non_negative_index("nPropsObs", "nGroups + 1", (nGroups + 1));
      current_statement__ = 347;
      context__.validate_dims("data initialization","nPropsObs","int",
          context__.to_vec((nGroups + 1)));
      nPropsObs = std::vector<int>((nGroups + 1), std::numeric_limits<int>::min());
      
      current_statement__ = 347;
      assign(nPropsObs, nil_index_list(), context__.vals_i("nPropsObs"),
        "assigning variable nPropsObs");
      current_statement__ = 347;
      for (int sym1__ = 1; sym1__ <= (nGroups + 1); ++sym1__) {
        current_statement__ = 347;
        current_statement__ = 347;
        check_greater_or_equal(function__, "nPropsObs[sym1__]",
                               nPropsObs[(sym1__ - 1)], 0);}
      current_statement__ = 348;
      validate_non_negative_index("sizesObsIndices", "maxNsizesObs",
                                  maxNsizesObs);
      current_statement__ = 349;
      validate_non_negative_index("sizesObsIndices", "nGroups", nGroups);
      current_statement__ = 350;
      context__.validate_dims("data initialization","sizesObsIndices","int",
          context__.to_vec(maxNsizesObs, 3, nGroups));
      sizesObsIndices = std::vector<std::vector<std::vector<int>>>(maxNsizesObs, std::vector<std::vector<int>>(3, std::vector<int>(nGroups, std::numeric_limits<int>::min())));
      
      {
        std::vector<int> sizesObsIndices_flat__;
        current_statement__ = 350;
        assign(sizesObsIndices_flat__, nil_index_list(),
          context__.vals_i("sizesObsIndices"),
          "assigning variable sizesObsIndices_flat__");
        current_statement__ = 350;
        pos__ = 1;
        current_statement__ = 350;
        for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
          current_statement__ = 350;
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            current_statement__ = 350;
            for (int sym3__ = 1; sym3__ <= maxNsizesObs; ++sym3__) {
              current_statement__ = 350;
              assign(sizesObsIndices,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                sizesObsIndices_flat__[(pos__ - 1)],
                "assigning variable sizesObsIndices");
              current_statement__ = 350;
              pos__ = (pos__ + 1);}}}
      }
      current_statement__ = 350;
      for (int sym1__ = 1; sym1__ <= maxNsizesObs; ++sym1__) {
        current_statement__ = 350;
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          current_statement__ = 350;
          for (int sym3__ = 1; sym3__ <= nGroups; ++sym3__) {
            current_statement__ = 350;
            current_statement__ = 350;
            check_greater_or_equal(function__,
                                   "sizesObsIndices[sym1__, sym2__, sym3__]",
                                   sizesObsIndices[(sym1__ - 1)][(sym2__ - 1)][
                                   (sym3__ - 1)], 0);}}}
      current_statement__ = 351;
      validate_non_negative_index("propsObsIndices", "maxNpropsObs",
                                  maxNpropsObs);
      current_statement__ = 352;
      validate_non_negative_index("propsObsIndices", "nGroups", nGroups);
      current_statement__ = 353;
      context__.validate_dims("data initialization","propsObsIndices","int",
          context__.to_vec(maxNpropsObs, 3, nGroups));
      propsObsIndices = std::vector<std::vector<std::vector<int>>>(maxNpropsObs, std::vector<std::vector<int>>(3, std::vector<int>(nGroups, std::numeric_limits<int>::min())));
      
      {
        std::vector<int> propsObsIndices_flat__;
        current_statement__ = 353;
        assign(propsObsIndices_flat__, nil_index_list(),
          context__.vals_i("propsObsIndices"),
          "assigning variable propsObsIndices_flat__");
        current_statement__ = 353;
        pos__ = 1;
        current_statement__ = 353;
        for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
          current_statement__ = 353;
          for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
            current_statement__ = 353;
            for (int sym3__ = 1; sym3__ <= maxNpropsObs; ++sym3__) {
              current_statement__ = 353;
              assign(propsObsIndices,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                propsObsIndices_flat__[(pos__ - 1)],
                "assigning variable propsObsIndices");
              current_statement__ = 353;
              pos__ = (pos__ + 1);}}}
      }
      current_statement__ = 353;
      for (int sym1__ = 1; sym1__ <= maxNpropsObs; ++sym1__) {
        current_statement__ = 353;
        for (int sym2__ = 1; sym2__ <= 3; ++sym2__) {
          current_statement__ = 353;
          for (int sym3__ = 1; sym3__ <= nGroups; ++sym3__) {
            current_statement__ = 353;
            current_statement__ = 353;
            check_greater_or_equal(function__,
                                   "propsObsIndices[sym1__, sym2__, sym3__]",
                                   propsObsIndices[(sym1__ - 1)][(sym2__ - 1)][
                                   (sym3__ - 1)], 0);}}}
      current_statement__ = 354;
      validate_non_negative_index("sizesObs", "maxNsizesObs", maxNsizesObs);
      current_statement__ = 355;
      validate_non_negative_index("sizesObs", "nGroups", nGroups);
      current_statement__ = 356;
      context__.validate_dims("data initialization","sizesObs","double",
          context__.to_vec(maxNsizesObs, nGroups));
      sizesObs = std::vector<std::vector<double>>(maxNsizesObs, std::vector<double>(nGroups, std::numeric_limits<double>::quiet_NaN()));
      
      {
        std::vector<local_scalar_t__> sizesObs_flat__;
        current_statement__ = 356;
        assign(sizesObs_flat__, nil_index_list(),
          context__.vals_r("sizesObs"), "assigning variable sizesObs_flat__");
        current_statement__ = 356;
        pos__ = 1;
        current_statement__ = 356;
        for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
          current_statement__ = 356;
          for (int sym2__ = 1; sym2__ <= maxNsizesObs; ++sym2__) {
            current_statement__ = 356;
            assign(sizesObs,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              sizesObs_flat__[(pos__ - 1)], "assigning variable sizesObs");
            current_statement__ = 356;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 356;
      for (int sym1__ = 1; sym1__ <= maxNsizesObs; ++sym1__) {
        current_statement__ = 356;
        for (int sym2__ = 1; sym2__ <= nGroups; ++sym2__) {
          current_statement__ = 356;
          current_statement__ = 356;
          check_greater_or_equal(function__, "sizesObs[sym1__, sym2__]",
                                 sizesObs[(sym1__ - 1)][(sym2__ - 1)], 0);}}
      current_statement__ = 357;
      validate_non_negative_index("propsObs", "maxNpropsObs", maxNpropsObs);
      current_statement__ = 358;
      validate_non_negative_index("propsObs", "nGroups", nGroups);
      current_statement__ = 359;
      context__.validate_dims("data initialization","propsObs","double",
          context__.to_vec(maxNpropsObs, nGroups));
      propsObs = std::vector<std::vector<double>>(maxNpropsObs, std::vector<double>(nGroups, std::numeric_limits<double>::quiet_NaN()));
      
      {
        std::vector<local_scalar_t__> propsObs_flat__;
        current_statement__ = 359;
        assign(propsObs_flat__, nil_index_list(),
          context__.vals_r("propsObs"), "assigning variable propsObs_flat__");
        current_statement__ = 359;
        pos__ = 1;
        current_statement__ = 359;
        for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
          current_statement__ = 359;
          for (int sym2__ = 1; sym2__ <= maxNpropsObs; ++sym2__) {
            current_statement__ = 359;
            assign(propsObs,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              propsObs_flat__[(pos__ - 1)], "assigning variable propsObs");
            current_statement__ = 359;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 359;
      for (int sym1__ = 1; sym1__ <= maxNpropsObs; ++sym1__) {
        current_statement__ = 359;
        for (int sym2__ = 1; sym2__ <= nGroups; ++sym2__) {
          current_statement__ = 359;
          current_statement__ = 359;
          check_greater_or_equal(function__, "propsObs[sym1__, sym2__]",
                                 propsObs[(sym1__ - 1)][(sym2__ - 1)], 0);}}
      current_statement__ = 360;
      context__.validate_dims("data initialization","maxNtimeIntervals",
          "int",context__.to_vec());
      maxNtimeIntervals = std::numeric_limits<int>::min();
      
      current_statement__ = 360;
      maxNtimeIntervals = context__.vals_i("maxNtimeIntervals")[(1 - 1)];
      current_statement__ = 360;
      current_statement__ = 360;
      check_greater_or_equal(function__, "maxNtimeIntervals",
                             maxNtimeIntervals, 0);
      current_statement__ = 361;
      validate_non_negative_index("nTimeIntervals", "nGroups + 1",
                                  (nGroups + 1));
      current_statement__ = 362;
      context__.validate_dims("data initialization","nTimeIntervals","int",
          context__.to_vec((nGroups + 1)));
      nTimeIntervals = std::vector<int>((nGroups + 1), std::numeric_limits<int>::min());
      
      current_statement__ = 362;
      assign(nTimeIntervals, nil_index_list(),
        context__.vals_i("nTimeIntervals"),
        "assigning variable nTimeIntervals");
      current_statement__ = 362;
      for (int sym1__ = 1; sym1__ <= (nGroups + 1); ++sym1__) {
        current_statement__ = 362;
        current_statement__ = 362;
        check_greater_or_equal(function__, "nTimeIntervals[sym1__]",
                               nTimeIntervals[(sym1__ - 1)], 0);}
      current_statement__ = 363;
      validate_non_negative_index("intervalsLengths", "maxNtimeIntervals",
                                  maxNtimeIntervals);
      current_statement__ = 364;
      validate_non_negative_index("intervalsLengths", "nGroups", nGroups);
      current_statement__ = 365;
      context__.validate_dims("data initialization","intervalsLengths",
          "double",context__.to_vec(maxNtimeIntervals, nGroups));
      intervalsLengths = std::vector<std::vector<double>>(maxNtimeIntervals, std::vector<double>(nGroups, std::numeric_limits<double>::quiet_NaN()));
      
      {
        std::vector<local_scalar_t__> intervalsLengths_flat__;
        current_statement__ = 365;
        assign(intervalsLengths_flat__, nil_index_list(),
          context__.vals_r("intervalsLengths"),
          "assigning variable intervalsLengths_flat__");
        current_statement__ = 365;
        pos__ = 1;
        current_statement__ = 365;
        for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
          current_statement__ = 365;
          for (int sym2__ = 1; sym2__ <= maxNtimeIntervals; ++sym2__) {
            current_statement__ = 365;
            assign(intervalsLengths,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              intervalsLengths_flat__[(pos__ - 1)],
              "assigning variable intervalsLengths");
            current_statement__ = 365;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 365;
      for (int sym1__ = 1; sym1__ <= maxNtimeIntervals; ++sym1__) {
        current_statement__ = 365;
        for (int sym2__ = 1; sym2__ <= nGroups; ++sym2__) {
          current_statement__ = 365;
          current_statement__ = 365;
          check_greater_or_equal(function__,
                                 "intervalsLengths[sym1__, sym2__]",
                                 intervalsLengths[(sym1__ - 1)][(sym2__ - 1)],
                                 0);}}
      current_statement__ = 366;
      context__.validate_dims("data initialization","maxNobsTimes","int",
          context__.to_vec());
      maxNobsTimes = std::numeric_limits<int>::min();
      
      current_statement__ = 366;
      maxNobsTimes = context__.vals_i("maxNobsTimes")[(1 - 1)];
      current_statement__ = 366;
      current_statement__ = 366;
      check_greater_or_equal(function__, "maxNobsTimes", maxNobsTimes, 0);
      current_statement__ = 367;
      validate_non_negative_index("nObsTimes", "nGroups + 1", (nGroups + 1));
      current_statement__ = 368;
      context__.validate_dims("data initialization","nObsTimes","int",
          context__.to_vec((nGroups + 1)));
      nObsTimes = std::vector<int>((nGroups + 1), std::numeric_limits<int>::min());
      
      current_statement__ = 368;
      assign(nObsTimes, nil_index_list(), context__.vals_i("nObsTimes"),
        "assigning variable nObsTimes");
      current_statement__ = 368;
      for (int sym1__ = 1; sym1__ <= (nGroups + 1); ++sym1__) {
        current_statement__ = 368;
        current_statement__ = 368;
        check_greater_or_equal(function__, "nObsTimes[sym1__]",
                               nObsTimes[(sym1__ - 1)], 0);}
      current_statement__ = 369;
      validate_non_negative_index("elapsedTimeSinceEvent", "nGroups", nGroups);
      current_statement__ = 370;
      validate_non_negative_index("elapsedTimeSinceEvent", "maxNobsTimes",
                                  maxNobsTimes);
      current_statement__ = 371;
      context__.validate_dims("data initialization","elapsedTimeSinceEvent",
          "double",context__.to_vec(nGroups, maxNobsTimes));
      elapsedTimeSinceEvent = std::vector<std::vector<double>>(nGroups, std::vector<double>(maxNobsTimes, std::numeric_limits<double>::quiet_NaN()));
      
      {
        std::vector<local_scalar_t__> elapsedTimeSinceEvent_flat__;
        current_statement__ = 371;
        assign(elapsedTimeSinceEvent_flat__, nil_index_list(),
          context__.vals_r("elapsedTimeSinceEvent"),
          "assigning variable elapsedTimeSinceEvent_flat__");
        current_statement__ = 371;
        pos__ = 1;
        current_statement__ = 371;
        for (int sym1__ = 1; sym1__ <= maxNobsTimes; ++sym1__) {
          current_statement__ = 371;
          for (int sym2__ = 1; sym2__ <= nGroups; ++sym2__) {
            current_statement__ = 371;
            assign(elapsedTimeSinceEvent,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              elapsedTimeSinceEvent_flat__[(pos__ - 1)],
              "assigning variable elapsedTimeSinceEvent");
            current_statement__ = 371;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 371;
      for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
        current_statement__ = 371;
        for (int sym2__ = 1; sym2__ <= maxNobsTimes; ++sym2__) {
          current_statement__ = 371;
          current_statement__ = 371;
          check_greater_or_equal(function__,
                                 "elapsedTimeSinceEvent[sym1__, sym2__]",
                                 elapsedTimeSinceEvent[(sym1__ - 1)][
                                 (sym2__ - 1)], 0);}}
      current_statement__ = 372;
      validate_non_negative_index("obsIntervalsIndices", "nGroups", nGroups);
      current_statement__ = 373;
      validate_non_negative_index("obsIntervalsIndices", "maxNobsTimes",
                                  maxNobsTimes);
      current_statement__ = 374;
      context__.validate_dims("data initialization","obsIntervalsIndices",
          "int",context__.to_vec(nGroups, maxNobsTimes));
      obsIntervalsIndices = std::vector<std::vector<int>>(nGroups, std::vector<int>(maxNobsTimes, std::numeric_limits<int>::min()));
      
      {
        std::vector<int> obsIntervalsIndices_flat__;
        current_statement__ = 374;
        assign(obsIntervalsIndices_flat__, nil_index_list(),
          context__.vals_i("obsIntervalsIndices"),
          "assigning variable obsIntervalsIndices_flat__");
        current_statement__ = 374;
        pos__ = 1;
        current_statement__ = 374;
        for (int sym1__ = 1; sym1__ <= maxNobsTimes; ++sym1__) {
          current_statement__ = 374;
          for (int sym2__ = 1; sym2__ <= nGroups; ++sym2__) {
            current_statement__ = 374;
            assign(obsIntervalsIndices,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              obsIntervalsIndices_flat__[(pos__ - 1)],
              "assigning variable obsIntervalsIndices");
            current_statement__ = 374;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 374;
      for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
        current_statement__ = 374;
        for (int sym2__ = 1; sym2__ <= maxNobsTimes; ++sym2__) {
          current_statement__ = 374;
          current_statement__ = 374;
          check_greater_or_equal(function__,
                                 "obsIntervalsIndices[sym1__, sym2__]",
                                 obsIntervalsIndices[(sym1__ - 1)][(sym2__ -
                                                                    1)], 0);}
      }
      current_statement__ = 375;
      context__.validate_dims("data initialization","maxNtimesteps","int",
          context__.to_vec());
      maxNtimesteps = std::numeric_limits<int>::min();
      
      current_statement__ = 375;
      maxNtimesteps = context__.vals_i("maxNtimesteps")[(1 - 1)];
      current_statement__ = 375;
      current_statement__ = 375;
      check_greater_or_equal(function__, "maxNtimesteps", maxNtimesteps, 2);
      current_statement__ = 376;
      validate_non_negative_index("nTimesteps", "nGroups + 1", (nGroups + 1));
      current_statement__ = 377;
      context__.validate_dims("data initialization","nTimesteps","int",
          context__.to_vec((nGroups + 1)));
      nTimesteps = std::vector<int>((nGroups + 1), std::numeric_limits<int>::min());
      
      current_statement__ = 377;
      assign(nTimesteps, nil_index_list(), context__.vals_i("nTimesteps"),
        "assigning variable nTimesteps");
      current_statement__ = 377;
      for (int sym1__ = 1; sym1__ <= (nGroups + 1); ++sym1__) {
        current_statement__ = 377;
        current_statement__ = 377;
        check_greater_or_equal(function__, "nTimesteps[sym1__]",
                               nTimesteps[(sym1__ - 1)], 0);}
      current_statement__ = 378;
      context__.validate_dims("data initialization","maxNuniqueDts","int",
          context__.to_vec());
      maxNuniqueDts = std::numeric_limits<int>::min();
      
      current_statement__ = 378;
      maxNuniqueDts = context__.vals_i("maxNuniqueDts")[(1 - 1)];
      current_statement__ = 378;
      current_statement__ = 378;
      check_greater_or_equal(function__, "maxNuniqueDts", maxNuniqueDts, 1);
      current_statement__ = 379;
      validate_non_negative_index("nUniqueDts", "nGroups + 1", (nGroups + 1));
      current_statement__ = 380;
      context__.validate_dims("data initialization","nUniqueDts","int",
          context__.to_vec((nGroups + 1)));
      nUniqueDts = std::vector<int>((nGroups + 1), std::numeric_limits<int>::min());
      
      current_statement__ = 380;
      assign(nUniqueDts, nil_index_list(), context__.vals_i("nUniqueDts"),
        "assigning variable nUniqueDts");
      current_statement__ = 380;
      for (int sym1__ = 1; sym1__ <= (nGroups + 1); ++sym1__) {
        current_statement__ = 380;
        current_statement__ = 380;
        check_greater_or_equal(function__, "nUniqueDts[sym1__]",
                               nUniqueDts[(sym1__ - 1)], 0);}
      current_statement__ = 381;
      validate_non_negative_index("unique_dts", "maxNuniqueDts",
                                  maxNuniqueDts);
      current_statement__ = 382;
      validate_non_negative_index("unique_dts", "nGroups", nGroups);
      current_statement__ = 383;
      context__.validate_dims("data initialization","unique_dts","double",
          context__.to_vec(maxNuniqueDts, nGroups));
      unique_dts = std::vector<std::vector<double>>(maxNuniqueDts, std::vector<double>(nGroups, std::numeric_limits<double>::quiet_NaN()));
      
      {
        std::vector<local_scalar_t__> unique_dts_flat__;
        current_statement__ = 383;
        assign(unique_dts_flat__, nil_index_list(),
          context__.vals_r("unique_dts"),
          "assigning variable unique_dts_flat__");
        current_statement__ = 383;
        pos__ = 1;
        current_statement__ = 383;
        for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
          current_statement__ = 383;
          for (int sym2__ = 1; sym2__ <= maxNuniqueDts; ++sym2__) {
            current_statement__ = 383;
            assign(unique_dts,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              unique_dts_flat__[(pos__ - 1)], "assigning variable unique_dts");
            current_statement__ = 383;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 383;
      for (int sym1__ = 1; sym1__ <= maxNuniqueDts; ++sym1__) {
        current_statement__ = 383;
        for (int sym2__ = 1; sym2__ <= nGroups; ++sym2__) {
          current_statement__ = 383;
          current_statement__ = 383;
          check_greater_or_equal(function__, "unique_dts[sym1__, sym2__]",
                                 unique_dts[(sym1__ - 1)][(sym2__ - 1)], 0);}
      }
      current_statement__ = 384;
      validate_non_negative_index("timesteps", "maxNtimesteps", maxNtimesteps);
      current_statement__ = 385;
      validate_non_negative_index("timesteps", "nGroups", nGroups);
      current_statement__ = 386;
      context__.validate_dims("data initialization","timesteps","int",
          context__.to_vec(maxNtimesteps, nGroups));
      timesteps = std::vector<std::vector<int>>(maxNtimesteps, std::vector<int>(nGroups, std::numeric_limits<int>::min()));
      
      {
        std::vector<int> timesteps_flat__;
        current_statement__ = 386;
        assign(timesteps_flat__, nil_index_list(),
          context__.vals_i("timesteps"),
          "assigning variable timesteps_flat__");
        current_statement__ = 386;
        pos__ = 1;
        current_statement__ = 386;
        for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
          current_statement__ = 386;
          for (int sym2__ = 1; sym2__ <= maxNtimesteps; ++sym2__) {
            current_statement__ = 386;
            assign(timesteps,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              timesteps_flat__[(pos__ - 1)], "assigning variable timesteps");
            current_statement__ = 386;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 386;
      for (int sym1__ = 1; sym1__ <= maxNtimesteps; ++sym1__) {
        current_statement__ = 386;
        for (int sym2__ = 1; sym2__ <= nGroups; ++sym2__) {
          current_statement__ = 386;
          current_statement__ = 386;
          check_greater_or_equal(function__, "timesteps[sym1__, sym2__]",
                                 timesteps[(sym1__ - 1)][(sym2__ - 1)], 0);}}
      current_statement__ = 387;
      nTotal = std::numeric_limits<int>::min();
      
      current_statement__ = 388;
      n_quantity_records = std::numeric_limits<int>::min();
      
      current_statement__ = 389;
      nTotal = 0;
      current_statement__ = 392;
      for (int g = 1; g <= nGroups; ++g) {
        current_statement__ = 390;
        nTotal = (nTotal + (nSizesObs[(g - 1)] + nPropsObs[(g - 1)]));}
      current_statement__ = 395;
      if (logical_eq(ode_method, 1)) {
        current_statement__ = 393;
        n_quantity_records = (maxNobsTimes + 1);
      } 
      current_statement__ = 398;
      if (logical_eq(ode_method, 2)) {
        current_statement__ = 396;
        n_quantity_records = (maxNtimesteps + 1);
      } 
      current_statement__ = 387;
      current_statement__ = 387;
      check_greater_or_equal(function__, "nTotal", nTotal, 0);
      current_statement__ = 388;
      current_statement__ = 388;
      check_greater_or_equal(function__, "n_quantity_records",
                             n_quantity_records, 0);
      current_statement__ = 399;
      validate_non_negative_index("rawUniformParams", "nPriorUniform_code1",
                                  nPriorUniform_code1);
      current_statement__ = 400;
      validate_non_negative_index("rawHcauchyParams", "nPriorHcauchy_code2",
                                  nPriorHcauchy_code2);
      current_statement__ = 401;
      validate_non_negative_index("rawBetaParams", "nPriorBeta_code3",
                                  nPriorBeta_code3);
      current_statement__ = 402;
      validate_non_negative_index("rawTrNormParams", "nPriorTrNormal_code4",
                                  nPriorTrNormal_code4);
      current_statement__ = 403;
      validate_non_negative_index("rawExponentialParams",
                                  "nPriorExponential_code5",
                                  nPriorExponential_code5);
      current_statement__ = 404;
      validate_non_negative_index("rawGammaParams", "nPriorGamma_code6",
                                  nPriorGamma_code6);
      current_statement__ = 405;
      validate_non_negative_index("params", "nParams", nParams);
      current_statement__ = 406;
      validate_non_negative_index("initRefr", "nComps", nComps);
      current_statement__ = 407;
      validate_non_negative_index("initRefr", "nGroups", nGroups);
      current_statement__ = 408;
      validate_non_negative_index("unmarked", "nGroups", nGroups);
      current_statement__ = 409;
      validate_non_negative_index("unmarked", "n_quantity_records",
                                  n_quantity_records);
      current_statement__ = 410;
      validate_non_negative_index("unmarked", "nComps", nComps);
      current_statement__ = 411;
      validate_non_negative_index("marked", "nGroups", nGroups);
      current_statement__ = 412;
      validate_non_negative_index("marked", "n_quantity_records",
                                  n_quantity_records);
      current_statement__ = 413;
      validate_non_negative_index("marked", "nComps", nComps);
      current_statement__ = 414;
      validate_non_negative_index("sizesPred", "maxNsizesObs", maxNsizesObs);
      current_statement__ = 415;
      validate_non_negative_index("sizesPred", "nGroups", nGroups);
      current_statement__ = 416;
      validate_non_negative_index("propsPred", "maxNpropsObs", maxNpropsObs);
      current_statement__ = 417;
      validate_non_negative_index("propsPred", "nGroups", nGroups);
      current_statement__ = 418;
      validate_non_negative_index("sizesPred_zeta", "maxNsizesObs",
                                  maxNsizesObs);
      current_statement__ = 419;
      validate_non_negative_index("sizesPred_zeta", "nGroups", nGroups);
      current_statement__ = 420;
      validate_non_negative_index("sizesPred_alpha", "maxNsizesObs",
                                  maxNsizesObs);
      current_statement__ = 421;
      validate_non_negative_index("sizesPred_alpha", "nGroups", nGroups);
      current_statement__ = 422;
      validate_non_negative_index("sizesPred_beta", "maxNsizesObs",
                                  maxNsizesObs);
      current_statement__ = 423;
      validate_non_negative_index("sizesPred_beta", "nGroups", nGroups);
      current_statement__ = 424;
      validate_non_negative_index("propsPred_eta", "maxNpropsObs",
                                  maxNpropsObs);
      current_statement__ = 425;
      validate_non_negative_index("propsPred_eta", "nGroups", nGroups);
      current_statement__ = 426;
      validate_non_negative_index("propsPred_alpha", "maxNpropsObs",
                                  maxNpropsObs);
      current_statement__ = 427;
      validate_non_negative_index("propsPred_alpha", "nGroups", nGroups);
      current_statement__ = 428;
      validate_non_negative_index("propsPred_beta", "maxNpropsObs",
                                  maxNpropsObs);
      current_statement__ = 429;
      validate_non_negative_index("propsPred_beta", "nGroups", nGroups);
      current_statement__ = 430;
      validate_non_negative_index("transitions", "maxNuniqueDts",
                                  maxNuniqueDts);
      current_statement__ = 431;
      validate_non_negative_index("transitions", "nComps", nComps);
      current_statement__ = 432;
      validate_non_negative_index("transitions", "nComps", nComps);
      current_statement__ = 433;
      validate_non_negative_index("transitionsDecay", "maxNuniqueDts",
                                  maxNuniqueDts);
      current_statement__ = 434;
      validate_non_negative_index("transitionsDecay", "nComps", nComps);
      current_statement__ = 435;
      validate_non_negative_index("transitionsDecay", "nComps", nComps);
      current_statement__ = 436;
      validate_non_negative_index("transfer", "nComps", nComps);
      current_statement__ = 437;
      validate_non_negative_index("transfer", "nComps", nComps);
      current_statement__ = 438;
      validate_non_negative_index("transferDecay", "nComps", nComps);
      current_statement__ = 439;
      validate_non_negative_index("transferDecay", "nComps", nComps);
      current_statement__ = 440;
      validate_non_negative_index("transition_tmp", "nComps", nComps);
      current_statement__ = 441;
      validate_non_negative_index("transition_tmp", "nComps", nComps);
      current_statement__ = 442;
      validate_non_negative_index("transitionDecay_tmp", "nComps", nComps);
      current_statement__ = 443;
      validate_non_negative_index("transitionDecay_tmp", "nComps", nComps);
      current_statement__ = 444;
      validate_non_negative_index("intervals_init_states_marked",
                                  "maxNtimeIntervals", maxNtimeIntervals);
      current_statement__ = 445;
      validate_non_negative_index("intervals_init_states_marked", "nComps",
                                  nComps);
      current_statement__ = 446;
      validate_non_negative_index("intervals_init_states_unmarked",
                                  "maxNtimeIntervals", maxNtimeIntervals);
      current_statement__ = 447;
      validate_non_negative_index("intervals_init_states_unmarked", "nComps",
                                  nComps);
      current_statement__ = 448;
      validate_non_negative_index("nonConstantParams", "nNonConstantPriors",
                                  nNonConstantPriors);
      current_statement__ = 449;
      validate_non_negative_index("log_lik", "nTotal", nTotal);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += nPriorUniform_code1;
      num_params_r__ += nPriorHcauchy_code2;
      num_params_r__ += nPriorBeta_code3;
      num_params_r__ += nPriorTrNormal_code4;
      num_params_r__ += nPriorExponential_code5;
      num_params_r__ += nPriorGamma_code6;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename VecR, typename VecI, stan::require_vector_like_t<VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "model_networkModel_namespace::log_prob";
(void) function__;  // suppress unused var warning
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      Eigen::Matrix<local_scalar_t__, -1, 1> rawUniformParams;
      rawUniformParams = Eigen::Matrix<local_scalar_t__, -1, 1>(nPriorUniform_code1);
      stan::math::fill(rawUniformParams, DUMMY_VAR__);
      
      current_statement__ = 1;
      rawUniformParams = in__.vector(nPriorUniform_code1);
      current_statement__ = 1;
      for (int sym1__ = 1; sym1__ <= nPriorUniform_code1; ++sym1__) {
        current_statement__ = 1;
        if (jacobian__) {
          current_statement__ = 1;
          assign(rawUniformParams,
            cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lub_constrain(rawUniformParams[(sym1__ - 1)], 0, 1,
              lp__), "assigning variable rawUniformParams");
        } else {
          current_statement__ = 1;
          assign(rawUniformParams,
            cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lub_constrain(rawUniformParams[(sym1__ - 1)], 0, 1),
            "assigning variable rawUniformParams");
        }}
      Eigen::Matrix<local_scalar_t__, -1, 1> rawHcauchyParams;
      rawHcauchyParams = Eigen::Matrix<local_scalar_t__, -1, 1>(nPriorHcauchy_code2);
      stan::math::fill(rawHcauchyParams, DUMMY_VAR__);
      
      current_statement__ = 2;
      rawHcauchyParams = in__.vector(nPriorHcauchy_code2);
      current_statement__ = 2;
      for (int sym1__ = 1; sym1__ <= nPriorHcauchy_code2; ++sym1__) {
        current_statement__ = 2;
        if (jacobian__) {
          current_statement__ = 2;
          assign(rawHcauchyParams,
            cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(rawHcauchyParams[(sym1__ - 1)], 0, lp__),
            "assigning variable rawHcauchyParams");
        } else {
          current_statement__ = 2;
          assign(rawHcauchyParams,
            cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(rawHcauchyParams[(sym1__ - 1)], 0),
            "assigning variable rawHcauchyParams");
        }}
      Eigen::Matrix<local_scalar_t__, -1, 1> rawBetaParams;
      rawBetaParams = Eigen::Matrix<local_scalar_t__, -1, 1>(nPriorBeta_code3);
      stan::math::fill(rawBetaParams, DUMMY_VAR__);
      
      current_statement__ = 3;
      rawBetaParams = in__.vector(nPriorBeta_code3);
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= nPriorBeta_code3; ++sym1__) {
        current_statement__ = 3;
        if (jacobian__) {
          current_statement__ = 3;
          assign(rawBetaParams,
            cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lub_constrain(rawBetaParams[(sym1__ - 1)], 0, 1, lp__),
            "assigning variable rawBetaParams");
        } else {
          current_statement__ = 3;
          assign(rawBetaParams,
            cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lub_constrain(rawBetaParams[(sym1__ - 1)], 0, 1),
            "assigning variable rawBetaParams");
        }}
      Eigen::Matrix<local_scalar_t__, -1, 1> rawTrNormParams;
      rawTrNormParams = Eigen::Matrix<local_scalar_t__, -1, 1>(nPriorTrNormal_code4);
      stan::math::fill(rawTrNormParams, DUMMY_VAR__);
      
      current_statement__ = 4;
      rawTrNormParams = in__.vector(nPriorTrNormal_code4);
      current_statement__ = 4;
      for (int sym1__ = 1; sym1__ <= nPriorTrNormal_code4; ++sym1__) {
        current_statement__ = 4;
        if (jacobian__) {
          current_statement__ = 4;
          assign(rawTrNormParams,
            cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(rawTrNormParams[(sym1__ - 1)], 0, lp__),
            "assigning variable rawTrNormParams");
        } else {
          current_statement__ = 4;
          assign(rawTrNormParams,
            cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(rawTrNormParams[(sym1__ - 1)], 0),
            "assigning variable rawTrNormParams");
        }}
      Eigen::Matrix<local_scalar_t__, -1, 1> rawExponentialParams;
      rawExponentialParams = Eigen::Matrix<local_scalar_t__, -1, 1>(nPriorExponential_code5);
      stan::math::fill(rawExponentialParams, DUMMY_VAR__);
      
      current_statement__ = 5;
      rawExponentialParams = in__.vector(nPriorExponential_code5);
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= nPriorExponential_code5; ++sym1__) {
        current_statement__ = 5;
        if (jacobian__) {
          current_statement__ = 5;
          assign(rawExponentialParams,
            cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(rawExponentialParams[(sym1__ - 1)], 0,
              lp__), "assigning variable rawExponentialParams");
        } else {
          current_statement__ = 5;
          assign(rawExponentialParams,
            cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(rawExponentialParams[(sym1__ - 1)], 0),
            "assigning variable rawExponentialParams");
        }}
      Eigen::Matrix<local_scalar_t__, -1, 1> rawGammaParams;
      rawGammaParams = Eigen::Matrix<local_scalar_t__, -1, 1>(nPriorGamma_code6);
      stan::math::fill(rawGammaParams, DUMMY_VAR__);
      
      current_statement__ = 6;
      rawGammaParams = in__.vector(nPriorGamma_code6);
      current_statement__ = 6;
      for (int sym1__ = 1; sym1__ <= nPriorGamma_code6; ++sym1__) {
        current_statement__ = 6;
        if (jacobian__) {
          current_statement__ = 6;
          assign(rawGammaParams,
            cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(rawGammaParams[(sym1__ - 1)], 0, lp__),
            "assigning variable rawGammaParams");
        } else {
          current_statement__ = 6;
          assign(rawGammaParams,
            cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(rawGammaParams[(sym1__ - 1)], 0),
            "assigning variable rawGammaParams");
        }}
      std::vector<local_scalar_t__> params;
      params = std::vector<local_scalar_t__>(nParams, DUMMY_VAR__);
      
      std::vector<std::vector<std::vector<local_scalar_t__>>> initRefr;
      initRefr = std::vector<std::vector<std::vector<local_scalar_t__>>>(nComps, std::vector<std::vector<local_scalar_t__>>(2, std::vector<local_scalar_t__>(nGroups, DUMMY_VAR__)));
      
      current_statement__ = 8;
      assign(initRefr, nil_index_list(), rep_array(0.0, nComps, 2, nGroups),
        "assigning variable initRefr");
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>> unmarked;
      unmarked = std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>(nGroups, std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(n_quantity_records, Eigen::Matrix<local_scalar_t__, -1, 1>(nComps)));
      stan::math::fill(unmarked, DUMMY_VAR__);
      
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>> marked;
      marked = std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>(nGroups, std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(n_quantity_records, Eigen::Matrix<local_scalar_t__, -1, 1>(nComps)));
      stan::math::fill(marked, DUMMY_VAR__);
      
      std::vector<std::vector<local_scalar_t__>> sizesPred;
      sizesPred = std::vector<std::vector<local_scalar_t__>>(maxNsizesObs, std::vector<local_scalar_t__>(nGroups, DUMMY_VAR__));
      
      std::vector<std::vector<local_scalar_t__>> propsPred;
      propsPred = std::vector<std::vector<local_scalar_t__>>(maxNpropsObs, std::vector<local_scalar_t__>(nGroups, DUMMY_VAR__));
      
      std::vector<std::vector<local_scalar_t__>> sizesPred_zeta;
      sizesPred_zeta = std::vector<std::vector<local_scalar_t__>>(maxNsizesObs, std::vector<local_scalar_t__>(nGroups, DUMMY_VAR__));
      
      current_statement__ = 13;
      assign(sizesPred_zeta, nil_index_list(),
        rep_array(0.0, maxNsizesObs, nGroups),
        "assigning variable sizesPred_zeta");
      std::vector<std::vector<local_scalar_t__>> sizesPred_alpha;
      sizesPred_alpha = std::vector<std::vector<local_scalar_t__>>(maxNsizesObs, std::vector<local_scalar_t__>(nGroups, DUMMY_VAR__));
      
      current_statement__ = 14;
      assign(sizesPred_alpha, nil_index_list(),
        rep_array(0.0, maxNsizesObs, nGroups),
        "assigning variable sizesPred_alpha");
      std::vector<std::vector<local_scalar_t__>> sizesPred_beta;
      sizesPred_beta = std::vector<std::vector<local_scalar_t__>>(maxNsizesObs, std::vector<local_scalar_t__>(nGroups, DUMMY_VAR__));
      
      current_statement__ = 15;
      assign(sizesPred_beta, nil_index_list(),
        rep_array(0.0, maxNsizesObs, nGroups),
        "assigning variable sizesPred_beta");
      std::vector<std::vector<local_scalar_t__>> propsPred_eta;
      propsPred_eta = std::vector<std::vector<local_scalar_t__>>(maxNpropsObs, std::vector<local_scalar_t__>(nGroups, DUMMY_VAR__));
      
      current_statement__ = 16;
      assign(propsPred_eta, nil_index_list(),
        rep_array(0.0, maxNpropsObs, nGroups),
        "assigning variable propsPred_eta");
      std::vector<std::vector<local_scalar_t__>> propsPred_alpha;
      propsPred_alpha = std::vector<std::vector<local_scalar_t__>>(maxNpropsObs, std::vector<local_scalar_t__>(nGroups, DUMMY_VAR__));
      
      current_statement__ = 17;
      assign(propsPred_alpha, nil_index_list(),
        rep_array(0.0, maxNpropsObs, nGroups),
        "assigning variable propsPred_alpha");
      std::vector<std::vector<local_scalar_t__>> propsPred_beta;
      propsPred_beta = std::vector<std::vector<local_scalar_t__>>(maxNpropsObs, std::vector<local_scalar_t__>(nGroups, DUMMY_VAR__));
      
      current_statement__ = 18;
      assign(propsPred_beta, nil_index_list(),
        rep_array(0.0, maxNpropsObs, nGroups),
        "assigning variable propsPred_beta");
      std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>> transitions;
      transitions = std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>>(maxNuniqueDts, Eigen::Matrix<local_scalar_t__, -1, -1>(nComps, nComps));
      stan::math::fill(transitions, DUMMY_VAR__);
      
      std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>> transitionsDecay;
      transitionsDecay = std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>>(maxNuniqueDts, Eigen::Matrix<local_scalar_t__, -1, -1>(nComps, nComps));
      stan::math::fill(transitionsDecay, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> transfer;
      transfer = Eigen::Matrix<local_scalar_t__, -1, -1>(nComps, nComps);
      stan::math::fill(transfer, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> transferDecay;
      transferDecay = Eigen::Matrix<local_scalar_t__, -1, -1>(nComps, nComps);
      stan::math::fill(transferDecay, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> transition_tmp;
      transition_tmp = Eigen::Matrix<local_scalar_t__, -1, -1>(nComps, nComps);
      stan::math::fill(transition_tmp, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> transitionDecay_tmp;
      transitionDecay_tmp = Eigen::Matrix<local_scalar_t__, -1, -1>(nComps, nComps);
      stan::math::fill(transitionDecay_tmp, DUMMY_VAR__);
      
      std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>> intervals_init_states_marked;
      intervals_init_states_marked = std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(maxNtimeIntervals, Eigen::Matrix<local_scalar_t__, -1, 1>(nComps));
      stan::math::fill(intervals_init_states_marked, DUMMY_VAR__);
      
      std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>> intervals_init_states_unmarked;
      intervals_init_states_unmarked = std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(maxNtimeIntervals, Eigen::Matrix<local_scalar_t__, -1, 1>(nComps));
      stan::math::fill(intervals_init_states_unmarked, DUMMY_VAR__);
      
      {
        int pulseIndex;
        pulseIndex = std::numeric_limits<int>::min();
        
        current_statement__ = 50;
        for (int i = 1; i <= nParams; ++i) {
          current_statement__ = 30;
          if (logical_eq(mappingParamPriorType[(i - 1)], 0)) {
            current_statement__ = 28;
            assign(params, cons_list(index_uni(i), nil_index_list()),
              constantParams[(i - 1)], "assigning variable params");
          } 
          current_statement__ = 33;
          if (logical_eq(mappingParamPriorType[(i - 1)], 1)) {
            current_statement__ = 31;
            assign(params, cons_list(index_uni(i), nil_index_list()),
              (lowerParams[(i - 1)] +
                ((upperParams[(i - 1)] - lowerParams[(i - 1)]) *
                  rawUniformParams[(mappingParamPriorID[(i - 1)] - 1)])),
              "assigning variable params");
          } 
          current_statement__ = 36;
          if (logical_eq(mappingParamPriorType[(i - 1)], 2)) {
            current_statement__ = 34;
            assign(params, cons_list(index_uni(i), nil_index_list()),
              (hcauchyScaleParams[(i - 1)] *
                rawHcauchyParams[(mappingParamPriorID[(i - 1)] - 1)]),
              "assigning variable params");
          } 
          current_statement__ = 39;
          if (logical_eq(mappingParamPriorType[(i - 1)], 3)) {
            current_statement__ = 37;
            assign(params, cons_list(index_uni(i), nil_index_list()),
              (betaScaleParams[(i - 1)] *
                rawBetaParams[(mappingParamPriorID[(i - 1)] - 1)]),
              "assigning variable params");
          } 
          current_statement__ = 42;
          if (logical_eq(mappingParamPriorType[(i - 1)], 4)) {
            current_statement__ = 40;
            assign(params, cons_list(index_uni(i), nil_index_list()),
              rawTrNormParams[(mappingParamPriorID[(i - 1)] - 1)],
              "assigning variable params");
          } 
          current_statement__ = 45;
          if (logical_eq(mappingParamPriorType[(i - 1)], 5)) {
            current_statement__ = 43;
            assign(params, cons_list(index_uni(i), nil_index_list()),
              rawExponentialParams[(mappingParamPriorID[(i - 1)] - 1)],
              "assigning variable params");
          } 
          current_statement__ = 48;
          if (logical_eq(mappingParamPriorType[(i - 1)], 6)) {
            current_statement__ = 46;
            assign(params, cons_list(index_uni(i), nil_index_list()),
              rawGammaParams[(mappingParamPriorID[(i - 1)] - 1)],
              "assigning variable params");
          } }
        current_statement__ = 181;
        for (int g = 1; g <= nGroups; ++g) {
          current_statement__ = 54;
          if (logical_eq(ode_method, 1)) {
            current_statement__ = 51;
            assign(transfer, nil_index_list(),
              buildTransferMatrix(nComps, nSteady[(g - 1)],
                rvalue(steadyIndices,
                  cons_list(index_omni(),
                    cons_list(index_uni(g), nil_index_list())),
                  "steadyIndices"), nUpsilons[(g - 1)],
                rvalue(upsilonMapping,
                  cons_list(index_omni(),
                    cons_list(index_omni(),
                      cons_list(index_uni(g), nil_index_list()))),
                  "upsilonMapping"), nLambdas[(g - 1)],
                rvalue(lambdaMapping,
                  cons_list(index_omni(),
                    cons_list(index_omni(),
                      cons_list(index_uni(g), nil_index_list()))),
                  "lambdaMapping"), params, pstream__),
              "assigning variable transfer");
            current_statement__ = 52;
            assign(transferDecay, nil_index_list(),
              buildTransferMatrixDecay(nComps, transfer,
                lambda_decay, pstream__), "assigning variable transferDecay");
          } 
          current_statement__ = 60;
          if (logical_eq(ode_method, 2)) {
            current_statement__ = 58;
            for (int i = 1; i <= nUniqueDts[(g - 1)]; ++i) {
              current_statement__ = 55;
              assign(transitions, cons_list(index_uni(i), nil_index_list()),
                buildTransitionMatrix(nComps, nUpsilons[(g - 1)],
                  rvalue(upsilonMapping,
                    cons_list(index_omni(),
                      cons_list(index_omni(),
                        cons_list(index_uni(g), nil_index_list()))),
                    "upsilonMapping"), nLambdas[(g - 1)],
                  rvalue(lambdaMapping,
                    cons_list(index_omni(),
                      cons_list(index_omni(),
                        cons_list(index_uni(g), nil_index_list()))),
                    "lambdaMapping"), unique_dts[(i - 1)][(g - 1)],
                  params, pstream__), "assigning variable transitions");
              current_statement__ = 56;
              assign(transitionsDecay,
                cons_list(index_uni(i), nil_index_list()),
                buildTransitionMatrixDecay(nComps, transitions[(i - 1)],
                  lambda_decay, unique_dts[(i - 1)][(g - 1)], pstream__),
                "assigning variable transitionsDecay");}
          } 
          current_statement__ = 61;
          pulseIndex = 1;
          current_statement__ = 62;
          assign(unmarked,
            cons_list(index_uni(g),
              cons_list(index_uni(1), nil_index_list())),
            to_vector(
              rvalue(initialQuantities,
                cons_list(index_omni(),
                  cons_list(index_uni(1),
                    cons_list(index_uni(g), nil_index_list()))),
                "initialQuantities")), "assigning variable unmarked");
          current_statement__ = 63;
          assign(marked,
            cons_list(index_uni(g),
              cons_list(index_uni(1), nil_index_list())),
            to_vector(
              rvalue(initialQuantities,
                cons_list(index_omni(),
                  cons_list(index_uni(2),
                    cons_list(index_uni(g), nil_index_list()))),
                "initialQuantities")), "assigning variable marked");
          current_statement__ = 73;
          if (logical_gt(splitPresent, 0)) {
            current_statement__ = 71;
            for (int j = 1; j <= nComps; ++j) {
              current_statement__ = 69;
              if (logical_gt(splitComps[(j - 1)][(g - 1)], 0)) {
                current_statement__ = 64;
                assign(initRefr,
                  cons_list(index_uni(j),
                    cons_list(index_uni(1),
                      cons_list(index_uni(g), nil_index_list()))),
                  (unmarked[(g - 1)][(1 - 1)][(j - 1)] *
                    (1 - params[(piMapping[(j - 1)][(g - 1)] - 1)])),
                  "assigning variable initRefr");
                current_statement__ = 65;
                assign(initRefr,
                  cons_list(index_uni(j),
                    cons_list(index_uni(2),
                      cons_list(index_uni(g), nil_index_list()))),
                  (marked[(g - 1)][(1 - 1)][(j - 1)] *
                    (1 - params[(piMapping[(j - 1)][(g - 1)] - 1)])),
                  "assigning variable initRefr");
                current_statement__ = 66;
                assign(unmarked,
                  cons_list(index_uni(g),
                    cons_list(index_uni(1),
                      cons_list(index_uni(j), nil_index_list()))),
                  (unmarked[(g - 1)][(1 - 1)][(j - 1)] *
                    params[(piMapping[(j - 1)][(g - 1)] - 1)]),
                  "assigning variable unmarked");
                current_statement__ = 67;
                assign(marked,
                  cons_list(index_uni(g),
                    cons_list(index_uni(1),
                      cons_list(index_uni(j), nil_index_list()))),
                  (marked[(g - 1)][(1 - 1)][(j - 1)] *
                    params[(piMapping[(j - 1)][(g - 1)] - 1)]),
                  "assigning variable marked");
              } }
          } 
          current_statement__ = 85;
          if (logical_gt(nPulseEvents[(g - 1)], 0)) {
            current_statement__ = 83;
            if (logical_lte(pulseIndex, nPulseEvents[(g - 1)])) {
              current_statement__ = 81;
              while (logical_eq(
                       pulseEventsIndices[(pulseIndex - 1)][(1 - 1)][
                       (g - 1)], 1)) {
                current_statement__ = 74;
                assign(unmarked,
                  cons_list(index_uni(g),
                    cons_list(index_uni(1),
                      cons_list(
                        index_uni(pulseEventsIndices[(pulseIndex - 1)][
                        (2 - 1)][(g - 1)]), nil_index_list()))),
                  (unmarked[(g - 1)][(1 - 1)][(pulseEventsIndices[(pulseIndex
                                                                    - 1)][
                                                (2 - 1)][(g - 1)] - 1)] +
                    pulseEventsQuantities[(pulseIndex - 1)][(1 - 1)][
                    (g - 1)]), "assigning variable unmarked");
                current_statement__ = 75;
                assign(marked,
                  cons_list(index_uni(g),
                    cons_list(index_uni(1),
                      cons_list(
                        index_uni(pulseEventsIndices[(pulseIndex - 1)][
                        (2 - 1)][(g - 1)]), nil_index_list()))),
                  (marked[(g - 1)][(1 - 1)][(pulseEventsIndices[(pulseIndex -
                                                                  1)][
                                              (2 - 1)][(g - 1)] - 1)] +
                    pulseEventsQuantities[(pulseIndex - 1)][(2 - 1)][
                    (g - 1)]), "assigning variable marked");
                current_statement__ = 76;
                pulseIndex = (pulseIndex + 1);
                current_statement__ = 79;
                if (logical_gt(pulseIndex, nPulseEvents[(g - 1)])) {
                  break;
                } 
              }
            } 
          } 
          current_statement__ = 123;
          if (logical_eq(ode_method, 1)) {
            current_statement__ = 86;
            assign(intervals_init_states_unmarked,
              cons_list(index_uni(1), nil_index_list()),
              unmarked[(g - 1)][(1 - 1)],
              "assigning variable intervals_init_states_unmarked");
            current_statement__ = 87;
            assign(intervals_init_states_marked,
              cons_list(index_uni(1), nil_index_list()),
              marked[(g - 1)][(1 - 1)],
              "assigning variable intervals_init_states_marked");
            current_statement__ = 111;
            if (logical_gt(nTimeIntervals[(g - 1)], 1)) {
              current_statement__ = 109;
              for (int t = 2; t <= nTimeIntervals[(g - 1)]; ++t) {
                current_statement__ = 88;
                assign(transition_tmp, nil_index_list(),
                  matrix_exp(
                    multiply(intervalsLengths[((t - 1) - 1)][(g - 1)],
                      transfer)), "assigning variable transition_tmp");
                current_statement__ = 93;
                if (logical_eq(lambda_decay, 0)) {
                  current_statement__ = 91;
                  assign(transitionDecay_tmp, nil_index_list(),
                    transition_tmp, "assigning variable transitionDecay_tmp");
                } else {
                  current_statement__ = 89;
                  assign(transitionDecay_tmp, nil_index_list(),
                    matrix_exp(
                      multiply(intervalsLengths[((t - 1) - 1)][(g - 1)],
                        transferDecay)),
                    "assigning variable transitionDecay_tmp");
                }
                current_statement__ = 94;
                assign(intervals_init_states_unmarked,
                  cons_list(index_uni(t), nil_index_list()),
                  multiply(transition_tmp,
                    stan::model::deep_copy(
                      intervals_init_states_unmarked[((t - 1) - 1)])),
                  "assigning variable intervals_init_states_unmarked");
                current_statement__ = 95;
                assign(intervals_init_states_marked,
                  cons_list(index_uni(t), nil_index_list()),
                  multiply(transitionDecay_tmp,
                    stan::model::deep_copy(
                      intervals_init_states_marked[((t - 1) - 1)])),
                  "assigning variable intervals_init_states_marked");
                current_statement__ = 107;
                if (logical_gt(nPulseEvents[(g - 1)], 0)) {
                  current_statement__ = 105;
                  if (logical_lte(pulseIndex, nPulseEvents[(g - 1)])) {
                    current_statement__ = 103;
                    while (logical_eq(
                             pulseEventsIndices[(pulseIndex - 1)][(1 - 1)][
                             (g - 1)], t)) {
                      current_statement__ = 96;
                      assign(intervals_init_states_unmarked,
                        cons_list(index_uni(t),
                          cons_list(
                            index_uni(pulseEventsIndices[(pulseIndex - 1)][
                            (2 - 1)][(g - 1)]), nil_index_list())),
                        (intervals_init_states_unmarked[(t - 1)][(pulseEventsIndices[
                                                                   (pulseIndex
                                                                    - 1)][
                                                                   (2 - 1)][
                                                                   (g - 1)] -
                                                                   1)] +
                          pulseEventsQuantities[(pulseIndex - 1)][(1 - 1)][
                          (g - 1)]),
                        "assigning variable intervals_init_states_unmarked");
                      current_statement__ = 97;
                      assign(intervals_init_states_marked,
                        cons_list(index_uni(t),
                          cons_list(
                            index_uni(pulseEventsIndices[(pulseIndex - 1)][
                            (2 - 1)][(g - 1)]), nil_index_list())),
                        (intervals_init_states_marked[(t - 1)][(pulseEventsIndices[
                                                                 (pulseIndex
                                                                   - 1)][
                                                                 (2 - 1)][
                                                                 (g - 1)] -
                                                                 1)] +
                          pulseEventsQuantities[(pulseIndex - 1)][(2 - 1)][
                          (g - 1)]),
                        "assigning variable intervals_init_states_marked");
                      current_statement__ = 98;
                      pulseIndex = (pulseIndex + 1);
                      current_statement__ = 101;
                      if (logical_gt(pulseIndex, nPulseEvents[(g - 1)])) {
                        break;
                      } 
                    }
                  } 
                } }
            } 
            current_statement__ = 121;
            for (int k = 1; k <= nObsTimes[(g - 1)]; ++k) {
              current_statement__ = 112;
              assign(transition_tmp, nil_index_list(),
                matrix_exp(
                  multiply(elapsedTimeSinceEvent[(g - 1)][(k - 1)], transfer)),
                "assigning variable transition_tmp");
              current_statement__ = 117;
              if (logical_eq(lambda_decay, 0)) {
                current_statement__ = 115;
                assign(transitionDecay_tmp, nil_index_list(), transition_tmp,
                  "assigning variable transitionDecay_tmp");
              } else {
                current_statement__ = 113;
                assign(transitionDecay_tmp, nil_index_list(),
                  matrix_exp(
                    multiply(elapsedTimeSinceEvent[(g - 1)][(k - 1)],
                      transferDecay)),
                  "assigning variable transitionDecay_tmp");
              }
              current_statement__ = 118;
              assign(unmarked,
                cons_list(index_uni(g),
                  cons_list(index_uni(k), nil_index_list())),
                multiply(transition_tmp,
                  intervals_init_states_unmarked[(obsIntervalsIndices[
                                                   (g - 1)][(k - 1)] - 1)]),
                "assigning variable unmarked");
              current_statement__ = 119;
              assign(marked,
                cons_list(index_uni(g),
                  cons_list(index_uni(k), nil_index_list())),
                multiply(transitionDecay_tmp,
                  intervals_init_states_marked[(obsIntervalsIndices[(g - 1)][
                                                 (k - 1)] - 1)]),
                "assigning variable marked");}
          } 
          current_statement__ = 147;
          if (logical_eq(ode_method, 2)) {
            current_statement__ = 145;
            for (int t = 1; t <= nTimesteps[(g - 1)]; ++t) {
              current_statement__ = 124;
              assign(unmarked,
                cons_list(index_uni(g),
                  cons_list(index_uni((t + 1)), nil_index_list())),
                multiply(transitions[(timesteps[(t - 1)][(g - 1)] - 1)],
                  stan::model::deep_copy(unmarked[(g - 1)][(t - 1)])),
                "assigning variable unmarked");
              current_statement__ = 125;
              assign(marked,
                cons_list(index_uni(g),
                  cons_list(index_uni((t + 1)), nil_index_list())),
                multiply(transitionsDecay[(timesteps[(t - 1)][(g - 1)] - 1)],
                  stan::model::deep_copy(marked[(g - 1)][(t - 1)])),
                "assigning variable marked");
              current_statement__ = 131;
              if (logical_gt(nSteady[(g - 1)], 0)) {
                current_statement__ = 129;
                for (int k = 1; k <= nSteady[(g - 1)]; ++k) {
                  current_statement__ = 126;
                  assign(unmarked,
                    cons_list(index_uni(g),
                      cons_list(index_uni((t + 1)),
                        cons_list(index_uni(steadyIndices[(k - 1)][(g - 1)]),
                          nil_index_list()))),
                    unmarked[(g - 1)][(t - 1)][(steadyIndices[(k - 1)][
                                                 (g - 1)] - 1)],
                    "assigning variable unmarked");
                  current_statement__ = 127;
                  assign(marked,
                    cons_list(index_uni(g),
                      cons_list(index_uni((t + 1)),
                        cons_list(index_uni(steadyIndices[(k - 1)][(g - 1)]),
                          nil_index_list()))),
                    marked[(g - 1)][(t - 1)][(steadyIndices[(k - 1)][
                                               (g - 1)] - 1)],
                    "assigning variable marked");}
              } 
              current_statement__ = 143;
              if (logical_gt(nPulseEvents[(g - 1)], 0)) {
                current_statement__ = 141;
                if (logical_lte(pulseIndex, nPulseEvents[(g - 1)])) {
                  current_statement__ = 139;
                  while (logical_eq(
                           pulseEventsIndices[(pulseIndex - 1)][(1 - 1)][
                           (g - 1)], (t + 1))) {
                    current_statement__ = 132;
                    assign(unmarked,
                      cons_list(index_uni(g),
                        cons_list(index_uni((t + 1)),
                          cons_list(
                            index_uni(pulseEventsIndices[(pulseIndex - 1)][
                            (2 - 1)][(g - 1)]), nil_index_list()))),
                      (unmarked[(g - 1)][((t + 1) - 1)][(pulseEventsIndices[
                                                          (pulseIndex - 1)][
                                                          (2 - 1)][(g - 1)] -
                                                          1)] +
                        pulseEventsQuantities[(pulseIndex - 1)][(1 - 1)][
                        (g - 1)]), "assigning variable unmarked");
                    current_statement__ = 133;
                    assign(marked,
                      cons_list(index_uni(g),
                        cons_list(index_uni((t + 1)),
                          cons_list(
                            index_uni(pulseEventsIndices[(pulseIndex - 1)][
                            (2 - 1)][(g - 1)]), nil_index_list()))),
                      (marked[(g - 1)][((t + 1) - 1)][(pulseEventsIndices[
                                                        (pulseIndex - 1)][
                                                        (2 - 1)][(g - 1)] -
                                                        1)] +
                        pulseEventsQuantities[(pulseIndex - 1)][(2 - 1)][
                        (g - 1)]), "assigning variable marked");
                    current_statement__ = 134;
                    pulseIndex = (pulseIndex + 1);
                    current_statement__ = 137;
                    if (logical_gt(pulseIndex, nPulseEvents[(g - 1)])) {
                      break;
                    } 
                  }
                } 
              } }
          } 
          current_statement__ = 148;
          assign(sizesPred,
            cons_list(index_omni(),
              cons_list(index_uni(g), nil_index_list())),
            buildSizePredictions(nSizesObs[(g - 1)], g, maxNsizesObs,
              rvalue(unmarked,
                cons_list(index_uni(g),
                  cons_list(index_omni(), nil_index_list())), "unmarked"),
              rvalue(marked,
                cons_list(index_uni(g),
                  cons_list(index_omni(), nil_index_list())), "marked"),
              rvalue(sizesObsIndices,
                cons_list(index_omni(),
                  cons_list(index_omni(),
                    cons_list(index_uni(g), nil_index_list()))),
                "sizesObsIndices"), splitPresent,
              rvalue(splitComps,
                cons_list(index_omni(),
                  cons_list(index_uni(g), nil_index_list())), "splitComps"),
              rvalue(initRefr,
                cons_list(index_omni(),
                  cons_list(index_omni(),
                    cons_list(index_uni(g), nil_index_list()))), "initRefr"), pstream__),
            "assigning variable sizesPred");
          current_statement__ = 149;
          assign(propsPred,
            cons_list(index_omni(),
              cons_list(index_uni(g), nil_index_list())),
            buildPropPredictions(nPropsObs[(g - 1)], g, maxNpropsObs,
              rvalue(unmarked,
                cons_list(index_uni(g),
                  cons_list(index_omni(), nil_index_list())), "unmarked"),
              rvalue(marked,
                cons_list(index_uni(g),
                  cons_list(index_omni(), nil_index_list())), "marked"),
              rvalue(propsObsIndices,
                cons_list(index_omni(),
                  cons_list(index_omni(),
                    cons_list(index_uni(g), nil_index_list()))),
                "propsObsIndices"), splitPresent,
              rvalue(splitComps,
                cons_list(index_omni(),
                  cons_list(index_uni(g), nil_index_list())), "splitComps"),
              rvalue(initRefr,
                cons_list(index_omni(),
                  cons_list(index_omni(),
                    cons_list(index_uni(g), nil_index_list()))), "initRefr"), pstream__),
            "assigning variable propsPred");
          current_statement__ = 160;
          for (int k = 1; k <= nSizesObs[(g - 1)]; ++k) {
            current_statement__ = 150;
            assign(sizesPred_zeta,
              cons_list(index_uni(k),
                cons_list(index_uni(g), nil_index_list())),
              params[(sizesObsIndices[(k - 1)][(3 - 1)][(g - 1)] - 1)],
              "assigning variable sizesPred_zeta");
            current_statement__ = 154;
            if (logical_eq(sizeFamily, 1)) {
              current_statement__ = 151;
              assign(sizesPred_alpha,
                cons_list(index_uni(k),
                  cons_list(index_uni(g), nil_index_list())),
                sizesPred[(k - 1)][(g - 1)],
                "assigning variable sizesPred_alpha");
              current_statement__ = 152;
              assign(sizesPred_beta,
                cons_list(index_uni(k),
                  cons_list(index_uni(g), nil_index_list())),
                (sizesPred_zeta[(k - 1)][(g - 1)] *
                  sizesPred[(k - 1)][(g - 1)]),
                "assigning variable sizesPred_beta");
            } 
            current_statement__ = 158;
            if (logical_eq(sizeFamily, 2)) {
              current_statement__ = 155;
              assign(sizesPred_alpha,
                cons_list(index_uni(k),
                  cons_list(index_uni(g), nil_index_list())),
                sizesPred[(k - 1)][(g - 1)],
                "assigning variable sizesPred_alpha");
              current_statement__ = 156;
              assign(sizesPred_beta,
                cons_list(index_uni(k),
                  cons_list(index_uni(g), nil_index_list())),
                sizesPred_zeta[(k - 1)][(g - 1)],
                "assigning variable sizesPred_beta");
            } }
          current_statement__ = 179;
          for (int k = 1; k <= nPropsObs[(g - 1)]; ++k) {
            current_statement__ = 161;
            assign(propsPred_eta,
              cons_list(index_uni(k),
                cons_list(index_uni(g), nil_index_list())),
              params[(propsObsIndices[(k - 1)][(3 - 1)][(g - 1)] - 1)],
              "assigning variable propsPred_eta");
            current_statement__ = 165;
            if (logical_eq(propFamily, 1)) {
              current_statement__ = 162;
              assign(propsPred_alpha,
                cons_list(index_uni(k),
                  cons_list(index_uni(g), nil_index_list())),
                pow(propsPred_eta[(k - 1)][(g - 1)], -2),
                "assigning variable propsPred_alpha");
              current_statement__ = 163;
              assign(propsPred_beta,
                cons_list(index_uni(k),
                  cons_list(index_uni(g), nil_index_list())),
                (propsPred_alpha[(k - 1)][(g - 1)] /
                  propsPred[(k - 1)][(g - 1)]),
                "assigning variable propsPred_beta");
            } 
            current_statement__ = 169;
            if (logical_eq(propFamily, 2)) {
              current_statement__ = 166;
              assign(propsPred_alpha,
                cons_list(index_uni(k),
                  cons_list(index_uni(g), nil_index_list())),
                propsPred[(k - 1)][(g - 1)],
                "assigning variable propsPred_alpha");
              current_statement__ = 167;
              assign(propsPred_beta,
                cons_list(index_uni(k),
                  cons_list(index_uni(g), nil_index_list())),
                (propsPred_eta[(k - 1)][(g - 1)] *
                  propsPred_alpha[(k - 1)][(g - 1)]),
                "assigning variable propsPred_beta");
            } 
            current_statement__ = 173;
            if (logical_eq(propFamily, 3)) {
              current_statement__ = 170;
              assign(propsPred_alpha,
                cons_list(index_uni(k),
                  cons_list(index_uni(g), nil_index_list())),
                propsPred[(k - 1)][(g - 1)],
                "assigning variable propsPred_alpha");
              current_statement__ = 171;
              assign(propsPred_beta,
                cons_list(index_uni(k),
                  cons_list(index_uni(g), nil_index_list())),
                propsPred_eta[(k - 1)][(g - 1)],
                "assigning variable propsPred_beta");
            } 
            current_statement__ = 177;
            if (logical_eq(propFamily, 4)) {
              current_statement__ = 174;
              assign(propsPred_alpha,
                cons_list(index_uni(k),
                  cons_list(index_uni(g), nil_index_list())),
                (propsPred[(k - 1)][(g - 1)] *
                  propsPred_eta[(k - 1)][(g - 1)]),
                "assigning variable propsPred_alpha");
              current_statement__ = 175;
              assign(propsPred_beta,
                cons_list(index_uni(k),
                  cons_list(index_uni(g), nil_index_list())),
                (propsPred_eta[(k - 1)][(g - 1)] *
                  (1 - propsPred[(k - 1)][(g - 1)])),
                "assigning variable propsPred_beta");
            } }}
      }
      current_statement__ = 7;
      for (int sym1__ = 1; sym1__ <= nParams; ++sym1__) {
        current_statement__ = 7;
        current_statement__ = 7;
        check_greater_or_equal(function__, "params[sym1__]",
                               params[(sym1__ - 1)], 0);}
      current_statement__ = 8;
      for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
        current_statement__ = 8;
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          current_statement__ = 8;
          for (int sym3__ = 1; sym3__ <= nGroups; ++sym3__) {
            current_statement__ = 8;
            current_statement__ = 8;
            check_greater_or_equal(function__,
                                   "initRefr[sym1__, sym2__, sym3__]",
                                   initRefr[(sym1__ - 1)][(sym2__ - 1)][
                                   (sym3__ - 1)], 0);}}}
      current_statement__ = 11;
      for (int sym1__ = 1; sym1__ <= maxNsizesObs; ++sym1__) {
        current_statement__ = 11;
        for (int sym2__ = 1; sym2__ <= nGroups; ++sym2__) {
          current_statement__ = 11;
          current_statement__ = 11;
          check_greater_or_equal(function__, "sizesPred[sym1__, sym2__]",
                                 sizesPred[(sym1__ - 1)][(sym2__ - 1)], 0);}}
      current_statement__ = 12;
      for (int sym1__ = 1; sym1__ <= maxNpropsObs; ++sym1__) {
        current_statement__ = 12;
        for (int sym2__ = 1; sym2__ <= nGroups; ++sym2__) {
          current_statement__ = 12;
          current_statement__ = 12;
          check_greater_or_equal(function__, "propsPred[sym1__, sym2__]",
                                 propsPred[(sym1__ - 1)][(sym2__ - 1)], 0);}}
      current_statement__ = 13;
      for (int sym1__ = 1; sym1__ <= maxNsizesObs; ++sym1__) {
        current_statement__ = 13;
        for (int sym2__ = 1; sym2__ <= nGroups; ++sym2__) {
          current_statement__ = 13;
          current_statement__ = 13;
          check_greater_or_equal(function__,
                                 "sizesPred_zeta[sym1__, sym2__]",
                                 sizesPred_zeta[(sym1__ - 1)][(sym2__ - 1)],
                                 0);}}
      current_statement__ = 14;
      for (int sym1__ = 1; sym1__ <= maxNsizesObs; ++sym1__) {
        current_statement__ = 14;
        for (int sym2__ = 1; sym2__ <= nGroups; ++sym2__) {
          current_statement__ = 14;
          current_statement__ = 14;
          check_greater_or_equal(function__,
                                 "sizesPred_alpha[sym1__, sym2__]",
                                 sizesPred_alpha[(sym1__ - 1)][(sym2__ - 1)],
                                 0);}}
      current_statement__ = 15;
      for (int sym1__ = 1; sym1__ <= maxNsizesObs; ++sym1__) {
        current_statement__ = 15;
        for (int sym2__ = 1; sym2__ <= nGroups; ++sym2__) {
          current_statement__ = 15;
          current_statement__ = 15;
          check_greater_or_equal(function__,
                                 "sizesPred_beta[sym1__, sym2__]",
                                 sizesPred_beta[(sym1__ - 1)][(sym2__ - 1)],
                                 0);}}
      current_statement__ = 16;
      for (int sym1__ = 1; sym1__ <= maxNpropsObs; ++sym1__) {
        current_statement__ = 16;
        for (int sym2__ = 1; sym2__ <= nGroups; ++sym2__) {
          current_statement__ = 16;
          current_statement__ = 16;
          check_greater_or_equal(function__, "propsPred_eta[sym1__, sym2__]",
                                 propsPred_eta[(sym1__ - 1)][(sym2__ - 1)], 0);
        }}
      current_statement__ = 17;
      for (int sym1__ = 1; sym1__ <= maxNpropsObs; ++sym1__) {
        current_statement__ = 17;
        for (int sym2__ = 1; sym2__ <= nGroups; ++sym2__) {
          current_statement__ = 17;
          current_statement__ = 17;
          check_greater_or_equal(function__,
                                 "propsPred_alpha[sym1__, sym2__]",
                                 propsPred_alpha[(sym1__ - 1)][(sym2__ - 1)],
                                 0);}}
      current_statement__ = 18;
      for (int sym1__ = 1; sym1__ <= maxNpropsObs; ++sym1__) {
        current_statement__ = 18;
        for (int sym2__ = 1; sym2__ <= nGroups; ++sym2__) {
          current_statement__ = 18;
          current_statement__ = 18;
          check_greater_or_equal(function__,
                                 "propsPred_beta[sym1__, sym2__]",
                                 propsPred_beta[(sym1__ - 1)][(sym2__ - 1)],
                                 0);}}
      {
        current_statement__ = 242;
        for (int i = 1; i <= nParams; ++i) {
          current_statement__ = 225;
          if (logical_eq(mappingParamPriorType[(i - 1)], 1)) {
            current_statement__ = 223;
            lp_accum__.add(
              uniform_lpdf<propto__>(
                rawUniformParams[(mappingParamPriorID[(i - 1)] - 1)], 0, 1));
          } 
          current_statement__ = 228;
          if (logical_eq(mappingParamPriorType[(i - 1)], 2)) {
            current_statement__ = 226;
            lp_accum__.add(
              cauchy_lpdf<propto__>(
                rawHcauchyParams[(mappingParamPriorID[(i - 1)] - 1)], 0, 1));
          } 
          current_statement__ = 231;
          if (logical_eq(mappingParamPriorType[(i - 1)], 3)) {
            current_statement__ = 229;
            lp_accum__.add(
              beta_lpdf<propto__>(
                rawBetaParams[(mappingParamPriorID[(i - 1)] - 1)],
                rawBetaAlpha[(i - 1)], rawBetaBeta[(i - 1)]));
          } 
          current_statement__ = 234;
          if (logical_eq(mappingParamPriorType[(i - 1)], 4)) {
            current_statement__ = 232;
            lp_accum__.add(
              normal_lpdf<propto__>(
                rawTrNormParams[(mappingParamPriorID[(i - 1)] - 1)],
                trNormMeanParams[(i - 1)], trNormSdParams[(i - 1)]));
          } 
          current_statement__ = 237;
          if (logical_eq(mappingParamPriorType[(i - 1)], 5)) {
            current_statement__ = 235;
            lp_accum__.add(
              exponential_lpdf<propto__>(
                rawExponentialParams[(mappingParamPriorID[(i - 1)] - 1)],
                exponentialRateParams[(i - 1)]));
          } 
          current_statement__ = 240;
          if (logical_eq(mappingParamPriorType[(i - 1)], 6)) {
            current_statement__ = 238;
            lp_accum__.add(
              gamma_lpdf<propto__>(
                rawGammaParams[(mappingParamPriorID[(i - 1)] - 1)],
                gammaAlphaParams[(i - 1)], gammaBetaParams[(i - 1)]));
          } }
        current_statement__ = 262;
        for (int g = 1; g <= nGroups; ++g) {
          current_statement__ = 245;
          if (logical_eq(sizeFamily, 1)) {
            current_statement__ = 243;
            lp_accum__.add(
              normal_lpdf<propto__>(
                rvalue(sizesObs,
                  cons_list(index_min_max(1, nSizesObs[(g - 1)]),
                    cons_list(index_uni(g), nil_index_list())), "sizesObs"),
                rvalue(sizesPred_alpha,
                  cons_list(index_min_max(1, nSizesObs[(g - 1)]),
                    cons_list(index_uni(g), nil_index_list())),
                  "sizesPred_alpha"),
                rvalue(sizesPred_beta,
                  cons_list(index_min_max(1, nSizesObs[(g - 1)]),
                    cons_list(index_uni(g), nil_index_list())),
                  "sizesPred_beta")));
          } 
          current_statement__ = 248;
          if (logical_eq(sizeFamily, 2)) {
            current_statement__ = 246;
            lp_accum__.add(
              normal_lpdf<propto__>(
                rvalue(sizesObs,
                  cons_list(index_min_max(1, nSizesObs[(g - 1)]),
                    cons_list(index_uni(g), nil_index_list())), "sizesObs"),
                rvalue(sizesPred_alpha,
                  cons_list(index_min_max(1, nSizesObs[(g - 1)]),
                    cons_list(index_uni(g), nil_index_list())),
                  "sizesPred_alpha"),
                rvalue(sizesPred_beta,
                  cons_list(index_min_max(1, nSizesObs[(g - 1)]),
                    cons_list(index_uni(g), nil_index_list())),
                  "sizesPred_beta")));
          } 
          current_statement__ = 251;
          if (logical_eq(propFamily, 1)) {
            current_statement__ = 249;
            lp_accum__.add(
              gamma_lpdf<propto__>(
                rvalue(propsObs,
                  cons_list(index_min_max(1, nPropsObs[(g - 1)]),
                    cons_list(index_uni(g), nil_index_list())), "propsObs"),
                rvalue(propsPred_alpha,
                  cons_list(index_min_max(1, nPropsObs[(g - 1)]),
                    cons_list(index_uni(g), nil_index_list())),
                  "propsPred_alpha"),
                rvalue(propsPred_beta,
                  cons_list(index_min_max(1, nPropsObs[(g - 1)]),
                    cons_list(index_uni(g), nil_index_list())),
                  "propsPred_beta")));
          } 
          current_statement__ = 254;
          if (logical_eq(propFamily, 2)) {
            current_statement__ = 252;
            lp_accum__.add(
              normal_lpdf<propto__>(
                rvalue(propsObs,
                  cons_list(index_min_max(1, nPropsObs[(g - 1)]),
                    cons_list(index_uni(g), nil_index_list())), "propsObs"),
                rvalue(propsPred_alpha,
                  cons_list(index_min_max(1, nPropsObs[(g - 1)]),
                    cons_list(index_uni(g), nil_index_list())),
                  "propsPred_alpha"),
                rvalue(propsPred_beta,
                  cons_list(index_min_max(1, nPropsObs[(g - 1)]),
                    cons_list(index_uni(g), nil_index_list())),
                  "propsPred_beta")));
          } 
          current_statement__ = 257;
          if (logical_eq(propFamily, 3)) {
            current_statement__ = 255;
            lp_accum__.add(
              normal_lpdf<propto__>(
                rvalue(propsObs,
                  cons_list(index_min_max(1, nPropsObs[(g - 1)]),
                    cons_list(index_uni(g), nil_index_list())), "propsObs"),
                rvalue(propsPred_alpha,
                  cons_list(index_min_max(1, nPropsObs[(g - 1)]),
                    cons_list(index_uni(g), nil_index_list())),
                  "propsPred_alpha"),
                rvalue(propsPred_beta,
                  cons_list(index_min_max(1, nPropsObs[(g - 1)]),
                    cons_list(index_uni(g), nil_index_list())),
                  "propsPred_beta")));
          } 
          current_statement__ = 260;
          if (logical_eq(propFamily, 4)) {
            current_statement__ = 258;
            lp_accum__.add(
              beta_lpdf<propto__>(
                rvalue(propsObs,
                  cons_list(index_min_max(1, nPropsObs[(g - 1)]),
                    cons_list(index_uni(g), nil_index_list())), "propsObs"),
                rvalue(propsPred_alpha,
                  cons_list(index_min_max(1, nPropsObs[(g - 1)]),
                    cons_list(index_uni(g), nil_index_list())),
                  "propsPred_alpha"),
                rvalue(propsPred_beta,
                  cons_list(index_min_max(1, nPropsObs[(g - 1)]),
                    cons_list(index_uni(g), nil_index_list())),
                  "propsPred_beta")));
          } }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr>
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "model_networkModel_namespace::write_array";
(void) function__;  // suppress unused var warning
    (void) function__;  // suppress unused var warning
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      Eigen::Matrix<double, -1, 1> rawUniformParams;
      rawUniformParams = Eigen::Matrix<double, -1, 1>(nPriorUniform_code1);
      stan::math::fill(rawUniformParams, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 1;
      rawUniformParams = in__.vector(nPriorUniform_code1);
      current_statement__ = 1;
      for (int sym1__ = 1; sym1__ <= nPriorUniform_code1; ++sym1__) {
        current_statement__ = 1;
        assign(rawUniformParams,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lub_constrain(rawUniformParams[(sym1__ - 1)], 0, 1),
          "assigning variable rawUniformParams");}
      Eigen::Matrix<double, -1, 1> rawHcauchyParams;
      rawHcauchyParams = Eigen::Matrix<double, -1, 1>(nPriorHcauchy_code2);
      stan::math::fill(rawHcauchyParams, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 2;
      rawHcauchyParams = in__.vector(nPriorHcauchy_code2);
      current_statement__ = 2;
      for (int sym1__ = 1; sym1__ <= nPriorHcauchy_code2; ++sym1__) {
        current_statement__ = 2;
        assign(rawHcauchyParams,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_constrain(rawHcauchyParams[(sym1__ - 1)], 0),
          "assigning variable rawHcauchyParams");}
      Eigen::Matrix<double, -1, 1> rawBetaParams;
      rawBetaParams = Eigen::Matrix<double, -1, 1>(nPriorBeta_code3);
      stan::math::fill(rawBetaParams, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 3;
      rawBetaParams = in__.vector(nPriorBeta_code3);
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= nPriorBeta_code3; ++sym1__) {
        current_statement__ = 3;
        assign(rawBetaParams, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lub_constrain(rawBetaParams[(sym1__ - 1)], 0, 1),
          "assigning variable rawBetaParams");}
      Eigen::Matrix<double, -1, 1> rawTrNormParams;
      rawTrNormParams = Eigen::Matrix<double, -1, 1>(nPriorTrNormal_code4);
      stan::math::fill(rawTrNormParams, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 4;
      rawTrNormParams = in__.vector(nPriorTrNormal_code4);
      current_statement__ = 4;
      for (int sym1__ = 1; sym1__ <= nPriorTrNormal_code4; ++sym1__) {
        current_statement__ = 4;
        assign(rawTrNormParams,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_constrain(rawTrNormParams[(sym1__ - 1)], 0),
          "assigning variable rawTrNormParams");}
      Eigen::Matrix<double, -1, 1> rawExponentialParams;
      rawExponentialParams = Eigen::Matrix<double, -1, 1>(nPriorExponential_code5);
      stan::math::fill(rawExponentialParams, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 5;
      rawExponentialParams = in__.vector(nPriorExponential_code5);
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= nPriorExponential_code5; ++sym1__) {
        current_statement__ = 5;
        assign(rawExponentialParams,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_constrain(rawExponentialParams[(sym1__ - 1)], 0),
          "assigning variable rawExponentialParams");}
      Eigen::Matrix<double, -1, 1> rawGammaParams;
      rawGammaParams = Eigen::Matrix<double, -1, 1>(nPriorGamma_code6);
      stan::math::fill(rawGammaParams, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 6;
      rawGammaParams = in__.vector(nPriorGamma_code6);
      current_statement__ = 6;
      for (int sym1__ = 1; sym1__ <= nPriorGamma_code6; ++sym1__) {
        current_statement__ = 6;
        assign(rawGammaParams,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_constrain(rawGammaParams[(sym1__ - 1)], 0),
          "assigning variable rawGammaParams");}
      std::vector<double> params;
      params = std::vector<double>(nParams, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<std::vector<std::vector<double>>> initRefr;
      initRefr = std::vector<std::vector<std::vector<double>>>(nComps, std::vector<std::vector<double>>(2, std::vector<double>(nGroups, std::numeric_limits<double>::quiet_NaN())));
      
      std::vector<std::vector<Eigen::Matrix<double, -1, 1>>> unmarked;
      unmarked = std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>(nGroups, std::vector<Eigen::Matrix<double, -1, 1>>(n_quantity_records, Eigen::Matrix<double, -1, 1>(nComps)));
      stan::math::fill(unmarked, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<std::vector<Eigen::Matrix<double, -1, 1>>> marked;
      marked = std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>(nGroups, std::vector<Eigen::Matrix<double, -1, 1>>(n_quantity_records, Eigen::Matrix<double, -1, 1>(nComps)));
      stan::math::fill(marked, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<std::vector<double>> sizesPred;
      sizesPred = std::vector<std::vector<double>>(maxNsizesObs, std::vector<double>(nGroups, std::numeric_limits<double>::quiet_NaN()));
      
      std::vector<std::vector<double>> propsPred;
      propsPred = std::vector<std::vector<double>>(maxNpropsObs, std::vector<double>(nGroups, std::numeric_limits<double>::quiet_NaN()));
      
      std::vector<std::vector<double>> sizesPred_zeta;
      sizesPred_zeta = std::vector<std::vector<double>>(maxNsizesObs, std::vector<double>(nGroups, std::numeric_limits<double>::quiet_NaN()));
      
      std::vector<std::vector<double>> sizesPred_alpha;
      sizesPred_alpha = std::vector<std::vector<double>>(maxNsizesObs, std::vector<double>(nGroups, std::numeric_limits<double>::quiet_NaN()));
      
      std::vector<std::vector<double>> sizesPred_beta;
      sizesPred_beta = std::vector<std::vector<double>>(maxNsizesObs, std::vector<double>(nGroups, std::numeric_limits<double>::quiet_NaN()));
      
      std::vector<std::vector<double>> propsPred_eta;
      propsPred_eta = std::vector<std::vector<double>>(maxNpropsObs, std::vector<double>(nGroups, std::numeric_limits<double>::quiet_NaN()));
      
      std::vector<std::vector<double>> propsPred_alpha;
      propsPred_alpha = std::vector<std::vector<double>>(maxNpropsObs, std::vector<double>(nGroups, std::numeric_limits<double>::quiet_NaN()));
      
      std::vector<std::vector<double>> propsPred_beta;
      propsPred_beta = std::vector<std::vector<double>>(maxNpropsObs, std::vector<double>(nGroups, std::numeric_limits<double>::quiet_NaN()));
      
      std::vector<Eigen::Matrix<double, -1, -1>> transitions;
      transitions = std::vector<Eigen::Matrix<double, -1, -1>>(maxNuniqueDts, Eigen::Matrix<double, -1, -1>(nComps, nComps));
      stan::math::fill(transitions, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<Eigen::Matrix<double, -1, -1>> transitionsDecay;
      transitionsDecay = std::vector<Eigen::Matrix<double, -1, -1>>(maxNuniqueDts, Eigen::Matrix<double, -1, -1>(nComps, nComps));
      stan::math::fill(transitionsDecay, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, -1> transfer;
      transfer = Eigen::Matrix<double, -1, -1>(nComps, nComps);
      stan::math::fill(transfer, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, -1> transferDecay;
      transferDecay = Eigen::Matrix<double, -1, -1>(nComps, nComps);
      stan::math::fill(transferDecay, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, -1> transition_tmp;
      transition_tmp = Eigen::Matrix<double, -1, -1>(nComps, nComps);
      stan::math::fill(transition_tmp, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, -1> transitionDecay_tmp;
      transitionDecay_tmp = Eigen::Matrix<double, -1, -1>(nComps, nComps);
      stan::math::fill(transitionDecay_tmp, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<Eigen::Matrix<double, -1, 1>> intervals_init_states_marked;
      intervals_init_states_marked = std::vector<Eigen::Matrix<double, -1, 1>>(maxNtimeIntervals, Eigen::Matrix<double, -1, 1>(nComps));
      stan::math::fill(intervals_init_states_marked, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<Eigen::Matrix<double, -1, 1>> intervals_init_states_unmarked;
      intervals_init_states_unmarked = std::vector<Eigen::Matrix<double, -1, 1>>(maxNtimeIntervals, Eigen::Matrix<double, -1, 1>(nComps));
      stan::math::fill(intervals_init_states_unmarked, std::numeric_limits<double>::quiet_NaN());
      
      for (int sym1__ = 1; sym1__ <= nPriorUniform_code1; ++sym1__) {
        vars__.emplace_back(rawUniformParams[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= nPriorHcauchy_code2; ++sym1__) {
        vars__.emplace_back(rawHcauchyParams[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= nPriorBeta_code3; ++sym1__) {
        vars__.emplace_back(rawBetaParams[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= nPriorTrNormal_code4; ++sym1__) {
        vars__.emplace_back(rawTrNormParams[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= nPriorExponential_code5; ++sym1__) {
        vars__.emplace_back(rawExponentialParams[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= nPriorGamma_code6; ++sym1__) {
        vars__.emplace_back(rawGammaParams[(sym1__ - 1)]);}
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 8;
      assign(initRefr, nil_index_list(), rep_array(0.0, nComps, 2, nGroups),
        "assigning variable initRefr");
      current_statement__ = 13;
      assign(sizesPred_zeta, nil_index_list(),
        rep_array(0.0, maxNsizesObs, nGroups),
        "assigning variable sizesPred_zeta");
      current_statement__ = 14;
      assign(sizesPred_alpha, nil_index_list(),
        rep_array(0.0, maxNsizesObs, nGroups),
        "assigning variable sizesPred_alpha");
      current_statement__ = 15;
      assign(sizesPred_beta, nil_index_list(),
        rep_array(0.0, maxNsizesObs, nGroups),
        "assigning variable sizesPred_beta");
      current_statement__ = 16;
      assign(propsPred_eta, nil_index_list(),
        rep_array(0.0, maxNpropsObs, nGroups),
        "assigning variable propsPred_eta");
      current_statement__ = 17;
      assign(propsPred_alpha, nil_index_list(),
        rep_array(0.0, maxNpropsObs, nGroups),
        "assigning variable propsPred_alpha");
      current_statement__ = 18;
      assign(propsPred_beta, nil_index_list(),
        rep_array(0.0, maxNpropsObs, nGroups),
        "assigning variable propsPred_beta");
      {
        int pulseIndex;
        pulseIndex = std::numeric_limits<int>::min();
        
        current_statement__ = 50;
        for (int i = 1; i <= nParams; ++i) {
          current_statement__ = 30;
          if (logical_eq(mappingParamPriorType[(i - 1)], 0)) {
            current_statement__ = 28;
            assign(params, cons_list(index_uni(i), nil_index_list()),
              constantParams[(i - 1)], "assigning variable params");
          } 
          current_statement__ = 33;
          if (logical_eq(mappingParamPriorType[(i - 1)], 1)) {
            current_statement__ = 31;
            assign(params, cons_list(index_uni(i), nil_index_list()),
              (lowerParams[(i - 1)] +
                ((upperParams[(i - 1)] - lowerParams[(i - 1)]) *
                  rawUniformParams[(mappingParamPriorID[(i - 1)] - 1)])),
              "assigning variable params");
          } 
          current_statement__ = 36;
          if (logical_eq(mappingParamPriorType[(i - 1)], 2)) {
            current_statement__ = 34;
            assign(params, cons_list(index_uni(i), nil_index_list()),
              (hcauchyScaleParams[(i - 1)] *
                rawHcauchyParams[(mappingParamPriorID[(i - 1)] - 1)]),
              "assigning variable params");
          } 
          current_statement__ = 39;
          if (logical_eq(mappingParamPriorType[(i - 1)], 3)) {
            current_statement__ = 37;
            assign(params, cons_list(index_uni(i), nil_index_list()),
              (betaScaleParams[(i - 1)] *
                rawBetaParams[(mappingParamPriorID[(i - 1)] - 1)]),
              "assigning variable params");
          } 
          current_statement__ = 42;
          if (logical_eq(mappingParamPriorType[(i - 1)], 4)) {
            current_statement__ = 40;
            assign(params, cons_list(index_uni(i), nil_index_list()),
              rawTrNormParams[(mappingParamPriorID[(i - 1)] - 1)],
              "assigning variable params");
          } 
          current_statement__ = 45;
          if (logical_eq(mappingParamPriorType[(i - 1)], 5)) {
            current_statement__ = 43;
            assign(params, cons_list(index_uni(i), nil_index_list()),
              rawExponentialParams[(mappingParamPriorID[(i - 1)] - 1)],
              "assigning variable params");
          } 
          current_statement__ = 48;
          if (logical_eq(mappingParamPriorType[(i - 1)], 6)) {
            current_statement__ = 46;
            assign(params, cons_list(index_uni(i), nil_index_list()),
              rawGammaParams[(mappingParamPriorID[(i - 1)] - 1)],
              "assigning variable params");
          } }
        current_statement__ = 181;
        for (int g = 1; g <= nGroups; ++g) {
          current_statement__ = 54;
          if (logical_eq(ode_method, 1)) {
            current_statement__ = 51;
            assign(transfer, nil_index_list(),
              buildTransferMatrix(nComps, nSteady[(g - 1)],
                rvalue(steadyIndices,
                  cons_list(index_omni(),
                    cons_list(index_uni(g), nil_index_list())),
                  "steadyIndices"), nUpsilons[(g - 1)],
                rvalue(upsilonMapping,
                  cons_list(index_omni(),
                    cons_list(index_omni(),
                      cons_list(index_uni(g), nil_index_list()))),
                  "upsilonMapping"), nLambdas[(g - 1)],
                rvalue(lambdaMapping,
                  cons_list(index_omni(),
                    cons_list(index_omni(),
                      cons_list(index_uni(g), nil_index_list()))),
                  "lambdaMapping"), params, pstream__),
              "assigning variable transfer");
            current_statement__ = 52;
            assign(transferDecay, nil_index_list(),
              buildTransferMatrixDecay(nComps, transfer,
                lambda_decay, pstream__), "assigning variable transferDecay");
          } 
          current_statement__ = 60;
          if (logical_eq(ode_method, 2)) {
            current_statement__ = 58;
            for (int i = 1; i <= nUniqueDts[(g - 1)]; ++i) {
              current_statement__ = 55;
              assign(transitions, cons_list(index_uni(i), nil_index_list()),
                buildTransitionMatrix(nComps, nUpsilons[(g - 1)],
                  rvalue(upsilonMapping,
                    cons_list(index_omni(),
                      cons_list(index_omni(),
                        cons_list(index_uni(g), nil_index_list()))),
                    "upsilonMapping"), nLambdas[(g - 1)],
                  rvalue(lambdaMapping,
                    cons_list(index_omni(),
                      cons_list(index_omni(),
                        cons_list(index_uni(g), nil_index_list()))),
                    "lambdaMapping"), unique_dts[(i - 1)][(g - 1)],
                  params, pstream__), "assigning variable transitions");
              current_statement__ = 56;
              assign(transitionsDecay,
                cons_list(index_uni(i), nil_index_list()),
                buildTransitionMatrixDecay(nComps, transitions[(i - 1)],
                  lambda_decay, unique_dts[(i - 1)][(g - 1)], pstream__),
                "assigning variable transitionsDecay");}
          } 
          current_statement__ = 61;
          pulseIndex = 1;
          current_statement__ = 62;
          assign(unmarked,
            cons_list(index_uni(g),
              cons_list(index_uni(1), nil_index_list())),
            to_vector(
              rvalue(initialQuantities,
                cons_list(index_omni(),
                  cons_list(index_uni(1),
                    cons_list(index_uni(g), nil_index_list()))),
                "initialQuantities")), "assigning variable unmarked");
          current_statement__ = 63;
          assign(marked,
            cons_list(index_uni(g),
              cons_list(index_uni(1), nil_index_list())),
            to_vector(
              rvalue(initialQuantities,
                cons_list(index_omni(),
                  cons_list(index_uni(2),
                    cons_list(index_uni(g), nil_index_list()))),
                "initialQuantities")), "assigning variable marked");
          current_statement__ = 73;
          if (logical_gt(splitPresent, 0)) {
            current_statement__ = 71;
            for (int j = 1; j <= nComps; ++j) {
              current_statement__ = 69;
              if (logical_gt(splitComps[(j - 1)][(g - 1)], 0)) {
                current_statement__ = 64;
                assign(initRefr,
                  cons_list(index_uni(j),
                    cons_list(index_uni(1),
                      cons_list(index_uni(g), nil_index_list()))),
                  (unmarked[(g - 1)][(1 - 1)][(j - 1)] *
                    (1 - params[(piMapping[(j - 1)][(g - 1)] - 1)])),
                  "assigning variable initRefr");
                current_statement__ = 65;
                assign(initRefr,
                  cons_list(index_uni(j),
                    cons_list(index_uni(2),
                      cons_list(index_uni(g), nil_index_list()))),
                  (marked[(g - 1)][(1 - 1)][(j - 1)] *
                    (1 - params[(piMapping[(j - 1)][(g - 1)] - 1)])),
                  "assigning variable initRefr");
                current_statement__ = 66;
                assign(unmarked,
                  cons_list(index_uni(g),
                    cons_list(index_uni(1),
                      cons_list(index_uni(j), nil_index_list()))),
                  (unmarked[(g - 1)][(1 - 1)][(j - 1)] *
                    params[(piMapping[(j - 1)][(g - 1)] - 1)]),
                  "assigning variable unmarked");
                current_statement__ = 67;
                assign(marked,
                  cons_list(index_uni(g),
                    cons_list(index_uni(1),
                      cons_list(index_uni(j), nil_index_list()))),
                  (marked[(g - 1)][(1 - 1)][(j - 1)] *
                    params[(piMapping[(j - 1)][(g - 1)] - 1)]),
                  "assigning variable marked");
              } }
          } 
          current_statement__ = 85;
          if (logical_gt(nPulseEvents[(g - 1)], 0)) {
            current_statement__ = 83;
            if (logical_lte(pulseIndex, nPulseEvents[(g - 1)])) {
              current_statement__ = 81;
              while (logical_eq(
                       pulseEventsIndices[(pulseIndex - 1)][(1 - 1)][
                       (g - 1)], 1)) {
                current_statement__ = 74;
                assign(unmarked,
                  cons_list(index_uni(g),
                    cons_list(index_uni(1),
                      cons_list(
                        index_uni(pulseEventsIndices[(pulseIndex - 1)][
                        (2 - 1)][(g - 1)]), nil_index_list()))),
                  (unmarked[(g - 1)][(1 - 1)][(pulseEventsIndices[(pulseIndex
                                                                    - 1)][
                                                (2 - 1)][(g - 1)] - 1)] +
                    pulseEventsQuantities[(pulseIndex - 1)][(1 - 1)][
                    (g - 1)]), "assigning variable unmarked");
                current_statement__ = 75;
                assign(marked,
                  cons_list(index_uni(g),
                    cons_list(index_uni(1),
                      cons_list(
                        index_uni(pulseEventsIndices[(pulseIndex - 1)][
                        (2 - 1)][(g - 1)]), nil_index_list()))),
                  (marked[(g - 1)][(1 - 1)][(pulseEventsIndices[(pulseIndex -
                                                                  1)][
                                              (2 - 1)][(g - 1)] - 1)] +
                    pulseEventsQuantities[(pulseIndex - 1)][(2 - 1)][
                    (g - 1)]), "assigning variable marked");
                current_statement__ = 76;
                pulseIndex = (pulseIndex + 1);
                current_statement__ = 79;
                if (logical_gt(pulseIndex, nPulseEvents[(g - 1)])) {
                  break;
                } 
              }
            } 
          } 
          current_statement__ = 123;
          if (logical_eq(ode_method, 1)) {
            current_statement__ = 86;
            assign(intervals_init_states_unmarked,
              cons_list(index_uni(1), nil_index_list()),
              unmarked[(g - 1)][(1 - 1)],
              "assigning variable intervals_init_states_unmarked");
            current_statement__ = 87;
            assign(intervals_init_states_marked,
              cons_list(index_uni(1), nil_index_list()),
              marked[(g - 1)][(1 - 1)],
              "assigning variable intervals_init_states_marked");
            current_statement__ = 111;
            if (logical_gt(nTimeIntervals[(g - 1)], 1)) {
              current_statement__ = 109;
              for (int t = 2; t <= nTimeIntervals[(g - 1)]; ++t) {
                current_statement__ = 88;
                assign(transition_tmp, nil_index_list(),
                  matrix_exp(
                    multiply(intervalsLengths[((t - 1) - 1)][(g - 1)],
                      transfer)), "assigning variable transition_tmp");
                current_statement__ = 93;
                if (logical_eq(lambda_decay, 0)) {
                  current_statement__ = 91;
                  assign(transitionDecay_tmp, nil_index_list(),
                    transition_tmp, "assigning variable transitionDecay_tmp");
                } else {
                  current_statement__ = 89;
                  assign(transitionDecay_tmp, nil_index_list(),
                    matrix_exp(
                      multiply(intervalsLengths[((t - 1) - 1)][(g - 1)],
                        transferDecay)),
                    "assigning variable transitionDecay_tmp");
                }
                current_statement__ = 94;
                assign(intervals_init_states_unmarked,
                  cons_list(index_uni(t), nil_index_list()),
                  multiply(transition_tmp,
                    stan::model::deep_copy(
                      intervals_init_states_unmarked[((t - 1) - 1)])),
                  "assigning variable intervals_init_states_unmarked");
                current_statement__ = 95;
                assign(intervals_init_states_marked,
                  cons_list(index_uni(t), nil_index_list()),
                  multiply(transitionDecay_tmp,
                    stan::model::deep_copy(
                      intervals_init_states_marked[((t - 1) - 1)])),
                  "assigning variable intervals_init_states_marked");
                current_statement__ = 107;
                if (logical_gt(nPulseEvents[(g - 1)], 0)) {
                  current_statement__ = 105;
                  if (logical_lte(pulseIndex, nPulseEvents[(g - 1)])) {
                    current_statement__ = 103;
                    while (logical_eq(
                             pulseEventsIndices[(pulseIndex - 1)][(1 - 1)][
                             (g - 1)], t)) {
                      current_statement__ = 96;
                      assign(intervals_init_states_unmarked,
                        cons_list(index_uni(t),
                          cons_list(
                            index_uni(pulseEventsIndices[(pulseIndex - 1)][
                            (2 - 1)][(g - 1)]), nil_index_list())),
                        (intervals_init_states_unmarked[(t - 1)][(pulseEventsIndices[
                                                                   (pulseIndex
                                                                    - 1)][
                                                                   (2 - 1)][
                                                                   (g - 1)] -
                                                                   1)] +
                          pulseEventsQuantities[(pulseIndex - 1)][(1 - 1)][
                          (g - 1)]),
                        "assigning variable intervals_init_states_unmarked");
                      current_statement__ = 97;
                      assign(intervals_init_states_marked,
                        cons_list(index_uni(t),
                          cons_list(
                            index_uni(pulseEventsIndices[(pulseIndex - 1)][
                            (2 - 1)][(g - 1)]), nil_index_list())),
                        (intervals_init_states_marked[(t - 1)][(pulseEventsIndices[
                                                                 (pulseIndex
                                                                   - 1)][
                                                                 (2 - 1)][
                                                                 (g - 1)] -
                                                                 1)] +
                          pulseEventsQuantities[(pulseIndex - 1)][(2 - 1)][
                          (g - 1)]),
                        "assigning variable intervals_init_states_marked");
                      current_statement__ = 98;
                      pulseIndex = (pulseIndex + 1);
                      current_statement__ = 101;
                      if (logical_gt(pulseIndex, nPulseEvents[(g - 1)])) {
                        break;
                      } 
                    }
                  } 
                } }
            } 
            current_statement__ = 121;
            for (int k = 1; k <= nObsTimes[(g - 1)]; ++k) {
              current_statement__ = 112;
              assign(transition_tmp, nil_index_list(),
                matrix_exp(
                  multiply(elapsedTimeSinceEvent[(g - 1)][(k - 1)], transfer)),
                "assigning variable transition_tmp");
              current_statement__ = 117;
              if (logical_eq(lambda_decay, 0)) {
                current_statement__ = 115;
                assign(transitionDecay_tmp, nil_index_list(), transition_tmp,
                  "assigning variable transitionDecay_tmp");
              } else {
                current_statement__ = 113;
                assign(transitionDecay_tmp, nil_index_list(),
                  matrix_exp(
                    multiply(elapsedTimeSinceEvent[(g - 1)][(k - 1)],
                      transferDecay)),
                  "assigning variable transitionDecay_tmp");
              }
              current_statement__ = 118;
              assign(unmarked,
                cons_list(index_uni(g),
                  cons_list(index_uni(k), nil_index_list())),
                multiply(transition_tmp,
                  intervals_init_states_unmarked[(obsIntervalsIndices[
                                                   (g - 1)][(k - 1)] - 1)]),
                "assigning variable unmarked");
              current_statement__ = 119;
              assign(marked,
                cons_list(index_uni(g),
                  cons_list(index_uni(k), nil_index_list())),
                multiply(transitionDecay_tmp,
                  intervals_init_states_marked[(obsIntervalsIndices[(g - 1)][
                                                 (k - 1)] - 1)]),
                "assigning variable marked");}
          } 
          current_statement__ = 147;
          if (logical_eq(ode_method, 2)) {
            current_statement__ = 145;
            for (int t = 1; t <= nTimesteps[(g - 1)]; ++t) {
              current_statement__ = 124;
              assign(unmarked,
                cons_list(index_uni(g),
                  cons_list(index_uni((t + 1)), nil_index_list())),
                multiply(transitions[(timesteps[(t - 1)][(g - 1)] - 1)],
                  stan::model::deep_copy(unmarked[(g - 1)][(t - 1)])),
                "assigning variable unmarked");
              current_statement__ = 125;
              assign(marked,
                cons_list(index_uni(g),
                  cons_list(index_uni((t + 1)), nil_index_list())),
                multiply(transitionsDecay[(timesteps[(t - 1)][(g - 1)] - 1)],
                  stan::model::deep_copy(marked[(g - 1)][(t - 1)])),
                "assigning variable marked");
              current_statement__ = 131;
              if (logical_gt(nSteady[(g - 1)], 0)) {
                current_statement__ = 129;
                for (int k = 1; k <= nSteady[(g - 1)]; ++k) {
                  current_statement__ = 126;
                  assign(unmarked,
                    cons_list(index_uni(g),
                      cons_list(index_uni((t + 1)),
                        cons_list(index_uni(steadyIndices[(k - 1)][(g - 1)]),
                          nil_index_list()))),
                    unmarked[(g - 1)][(t - 1)][(steadyIndices[(k - 1)][
                                                 (g - 1)] - 1)],
                    "assigning variable unmarked");
                  current_statement__ = 127;
                  assign(marked,
                    cons_list(index_uni(g),
                      cons_list(index_uni((t + 1)),
                        cons_list(index_uni(steadyIndices[(k - 1)][(g - 1)]),
                          nil_index_list()))),
                    marked[(g - 1)][(t - 1)][(steadyIndices[(k - 1)][
                                               (g - 1)] - 1)],
                    "assigning variable marked");}
              } 
              current_statement__ = 143;
              if (logical_gt(nPulseEvents[(g - 1)], 0)) {
                current_statement__ = 141;
                if (logical_lte(pulseIndex, nPulseEvents[(g - 1)])) {
                  current_statement__ = 139;
                  while (logical_eq(
                           pulseEventsIndices[(pulseIndex - 1)][(1 - 1)][
                           (g - 1)], (t + 1))) {
                    current_statement__ = 132;
                    assign(unmarked,
                      cons_list(index_uni(g),
                        cons_list(index_uni((t + 1)),
                          cons_list(
                            index_uni(pulseEventsIndices[(pulseIndex - 1)][
                            (2 - 1)][(g - 1)]), nil_index_list()))),
                      (unmarked[(g - 1)][((t + 1) - 1)][(pulseEventsIndices[
                                                          (pulseIndex - 1)][
                                                          (2 - 1)][(g - 1)] -
                                                          1)] +
                        pulseEventsQuantities[(pulseIndex - 1)][(1 - 1)][
                        (g - 1)]), "assigning variable unmarked");
                    current_statement__ = 133;
                    assign(marked,
                      cons_list(index_uni(g),
                        cons_list(index_uni((t + 1)),
                          cons_list(
                            index_uni(pulseEventsIndices[(pulseIndex - 1)][
                            (2 - 1)][(g - 1)]), nil_index_list()))),
                      (marked[(g - 1)][((t + 1) - 1)][(pulseEventsIndices[
                                                        (pulseIndex - 1)][
                                                        (2 - 1)][(g - 1)] -
                                                        1)] +
                        pulseEventsQuantities[(pulseIndex - 1)][(2 - 1)][
                        (g - 1)]), "assigning variable marked");
                    current_statement__ = 134;
                    pulseIndex = (pulseIndex + 1);
                    current_statement__ = 137;
                    if (logical_gt(pulseIndex, nPulseEvents[(g - 1)])) {
                      break;
                    } 
                  }
                } 
              } }
          } 
          current_statement__ = 148;
          assign(sizesPred,
            cons_list(index_omni(),
              cons_list(index_uni(g), nil_index_list())),
            buildSizePredictions(nSizesObs[(g - 1)], g, maxNsizesObs,
              rvalue(unmarked,
                cons_list(index_uni(g),
                  cons_list(index_omni(), nil_index_list())), "unmarked"),
              rvalue(marked,
                cons_list(index_uni(g),
                  cons_list(index_omni(), nil_index_list())), "marked"),
              rvalue(sizesObsIndices,
                cons_list(index_omni(),
                  cons_list(index_omni(),
                    cons_list(index_uni(g), nil_index_list()))),
                "sizesObsIndices"), splitPresent,
              rvalue(splitComps,
                cons_list(index_omni(),
                  cons_list(index_uni(g), nil_index_list())), "splitComps"),
              rvalue(initRefr,
                cons_list(index_omni(),
                  cons_list(index_omni(),
                    cons_list(index_uni(g), nil_index_list()))), "initRefr"), pstream__),
            "assigning variable sizesPred");
          current_statement__ = 149;
          assign(propsPred,
            cons_list(index_omni(),
              cons_list(index_uni(g), nil_index_list())),
            buildPropPredictions(nPropsObs[(g - 1)], g, maxNpropsObs,
              rvalue(unmarked,
                cons_list(index_uni(g),
                  cons_list(index_omni(), nil_index_list())), "unmarked"),
              rvalue(marked,
                cons_list(index_uni(g),
                  cons_list(index_omni(), nil_index_list())), "marked"),
              rvalue(propsObsIndices,
                cons_list(index_omni(),
                  cons_list(index_omni(),
                    cons_list(index_uni(g), nil_index_list()))),
                "propsObsIndices"), splitPresent,
              rvalue(splitComps,
                cons_list(index_omni(),
                  cons_list(index_uni(g), nil_index_list())), "splitComps"),
              rvalue(initRefr,
                cons_list(index_omni(),
                  cons_list(index_omni(),
                    cons_list(index_uni(g), nil_index_list()))), "initRefr"), pstream__),
            "assigning variable propsPred");
          current_statement__ = 160;
          for (int k = 1; k <= nSizesObs[(g - 1)]; ++k) {
            current_statement__ = 150;
            assign(sizesPred_zeta,
              cons_list(index_uni(k),
                cons_list(index_uni(g), nil_index_list())),
              params[(sizesObsIndices[(k - 1)][(3 - 1)][(g - 1)] - 1)],
              "assigning variable sizesPred_zeta");
            current_statement__ = 154;
            if (logical_eq(sizeFamily, 1)) {
              current_statement__ = 151;
              assign(sizesPred_alpha,
                cons_list(index_uni(k),
                  cons_list(index_uni(g), nil_index_list())),
                sizesPred[(k - 1)][(g - 1)],
                "assigning variable sizesPred_alpha");
              current_statement__ = 152;
              assign(sizesPred_beta,
                cons_list(index_uni(k),
                  cons_list(index_uni(g), nil_index_list())),
                (sizesPred_zeta[(k - 1)][(g - 1)] *
                  sizesPred[(k - 1)][(g - 1)]),
                "assigning variable sizesPred_beta");
            } 
            current_statement__ = 158;
            if (logical_eq(sizeFamily, 2)) {
              current_statement__ = 155;
              assign(sizesPred_alpha,
                cons_list(index_uni(k),
                  cons_list(index_uni(g), nil_index_list())),
                sizesPred[(k - 1)][(g - 1)],
                "assigning variable sizesPred_alpha");
              current_statement__ = 156;
              assign(sizesPred_beta,
                cons_list(index_uni(k),
                  cons_list(index_uni(g), nil_index_list())),
                sizesPred_zeta[(k - 1)][(g - 1)],
                "assigning variable sizesPred_beta");
            } }
          current_statement__ = 179;
          for (int k = 1; k <= nPropsObs[(g - 1)]; ++k) {
            current_statement__ = 161;
            assign(propsPred_eta,
              cons_list(index_uni(k),
                cons_list(index_uni(g), nil_index_list())),
              params[(propsObsIndices[(k - 1)][(3 - 1)][(g - 1)] - 1)],
              "assigning variable propsPred_eta");
            current_statement__ = 165;
            if (logical_eq(propFamily, 1)) {
              current_statement__ = 162;
              assign(propsPred_alpha,
                cons_list(index_uni(k),
                  cons_list(index_uni(g), nil_index_list())),
                pow(propsPred_eta[(k - 1)][(g - 1)], -2),
                "assigning variable propsPred_alpha");
              current_statement__ = 163;
              assign(propsPred_beta,
                cons_list(index_uni(k),
                  cons_list(index_uni(g), nil_index_list())),
                (propsPred_alpha[(k - 1)][(g - 1)] /
                  propsPred[(k - 1)][(g - 1)]),
                "assigning variable propsPred_beta");
            } 
            current_statement__ = 169;
            if (logical_eq(propFamily, 2)) {
              current_statement__ = 166;
              assign(propsPred_alpha,
                cons_list(index_uni(k),
                  cons_list(index_uni(g), nil_index_list())),
                propsPred[(k - 1)][(g - 1)],
                "assigning variable propsPred_alpha");
              current_statement__ = 167;
              assign(propsPred_beta,
                cons_list(index_uni(k),
                  cons_list(index_uni(g), nil_index_list())),
                (propsPred_eta[(k - 1)][(g - 1)] *
                  propsPred_alpha[(k - 1)][(g - 1)]),
                "assigning variable propsPred_beta");
            } 
            current_statement__ = 173;
            if (logical_eq(propFamily, 3)) {
              current_statement__ = 170;
              assign(propsPred_alpha,
                cons_list(index_uni(k),
                  cons_list(index_uni(g), nil_index_list())),
                propsPred[(k - 1)][(g - 1)],
                "assigning variable propsPred_alpha");
              current_statement__ = 171;
              assign(propsPred_beta,
                cons_list(index_uni(k),
                  cons_list(index_uni(g), nil_index_list())),
                propsPred_eta[(k - 1)][(g - 1)],
                "assigning variable propsPred_beta");
            } 
            current_statement__ = 177;
            if (logical_eq(propFamily, 4)) {
              current_statement__ = 174;
              assign(propsPred_alpha,
                cons_list(index_uni(k),
                  cons_list(index_uni(g), nil_index_list())),
                (propsPred[(k - 1)][(g - 1)] *
                  propsPred_eta[(k - 1)][(g - 1)]),
                "assigning variable propsPred_alpha");
              current_statement__ = 175;
              assign(propsPred_beta,
                cons_list(index_uni(k),
                  cons_list(index_uni(g), nil_index_list())),
                (propsPred_eta[(k - 1)][(g - 1)] *
                  (1 - propsPred[(k - 1)][(g - 1)])),
                "assigning variable propsPred_beta");
            } }}
      }
      current_statement__ = 7;
      for (int sym1__ = 1; sym1__ <= nParams; ++sym1__) {
        current_statement__ = 7;
        current_statement__ = 7;
        check_greater_or_equal(function__, "params[sym1__]",
                               params[(sym1__ - 1)], 0);}
      current_statement__ = 8;
      for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
        current_statement__ = 8;
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          current_statement__ = 8;
          for (int sym3__ = 1; sym3__ <= nGroups; ++sym3__) {
            current_statement__ = 8;
            current_statement__ = 8;
            check_greater_or_equal(function__,
                                   "initRefr[sym1__, sym2__, sym3__]",
                                   initRefr[(sym1__ - 1)][(sym2__ - 1)][
                                   (sym3__ - 1)], 0);}}}
      current_statement__ = 11;
      for (int sym1__ = 1; sym1__ <= maxNsizesObs; ++sym1__) {
        current_statement__ = 11;
        for (int sym2__ = 1; sym2__ <= nGroups; ++sym2__) {
          current_statement__ = 11;
          current_statement__ = 11;
          check_greater_or_equal(function__, "sizesPred[sym1__, sym2__]",
                                 sizesPred[(sym1__ - 1)][(sym2__ - 1)], 0);}}
      current_statement__ = 12;
      for (int sym1__ = 1; sym1__ <= maxNpropsObs; ++sym1__) {
        current_statement__ = 12;
        for (int sym2__ = 1; sym2__ <= nGroups; ++sym2__) {
          current_statement__ = 12;
          current_statement__ = 12;
          check_greater_or_equal(function__, "propsPred[sym1__, sym2__]",
                                 propsPred[(sym1__ - 1)][(sym2__ - 1)], 0);}}
      current_statement__ = 13;
      for (int sym1__ = 1; sym1__ <= maxNsizesObs; ++sym1__) {
        current_statement__ = 13;
        for (int sym2__ = 1; sym2__ <= nGroups; ++sym2__) {
          current_statement__ = 13;
          current_statement__ = 13;
          check_greater_or_equal(function__,
                                 "sizesPred_zeta[sym1__, sym2__]",
                                 sizesPred_zeta[(sym1__ - 1)][(sym2__ - 1)],
                                 0);}}
      current_statement__ = 14;
      for (int sym1__ = 1; sym1__ <= maxNsizesObs; ++sym1__) {
        current_statement__ = 14;
        for (int sym2__ = 1; sym2__ <= nGroups; ++sym2__) {
          current_statement__ = 14;
          current_statement__ = 14;
          check_greater_or_equal(function__,
                                 "sizesPred_alpha[sym1__, sym2__]",
                                 sizesPred_alpha[(sym1__ - 1)][(sym2__ - 1)],
                                 0);}}
      current_statement__ = 15;
      for (int sym1__ = 1; sym1__ <= maxNsizesObs; ++sym1__) {
        current_statement__ = 15;
        for (int sym2__ = 1; sym2__ <= nGroups; ++sym2__) {
          current_statement__ = 15;
          current_statement__ = 15;
          check_greater_or_equal(function__,
                                 "sizesPred_beta[sym1__, sym2__]",
                                 sizesPred_beta[(sym1__ - 1)][(sym2__ - 1)],
                                 0);}}
      current_statement__ = 16;
      for (int sym1__ = 1; sym1__ <= maxNpropsObs; ++sym1__) {
        current_statement__ = 16;
        for (int sym2__ = 1; sym2__ <= nGroups; ++sym2__) {
          current_statement__ = 16;
          current_statement__ = 16;
          check_greater_or_equal(function__, "propsPred_eta[sym1__, sym2__]",
                                 propsPred_eta[(sym1__ - 1)][(sym2__ - 1)], 0);
        }}
      current_statement__ = 17;
      for (int sym1__ = 1; sym1__ <= maxNpropsObs; ++sym1__) {
        current_statement__ = 17;
        for (int sym2__ = 1; sym2__ <= nGroups; ++sym2__) {
          current_statement__ = 17;
          current_statement__ = 17;
          check_greater_or_equal(function__,
                                 "propsPred_alpha[sym1__, sym2__]",
                                 propsPred_alpha[(sym1__ - 1)][(sym2__ - 1)],
                                 0);}}
      current_statement__ = 18;
      for (int sym1__ = 1; sym1__ <= maxNpropsObs; ++sym1__) {
        current_statement__ = 18;
        for (int sym2__ = 1; sym2__ <= nGroups; ++sym2__) {
          current_statement__ = 18;
          current_statement__ = 18;
          check_greater_or_equal(function__,
                                 "propsPred_beta[sym1__, sym2__]",
                                 propsPred_beta[(sym1__ - 1)][(sym2__ - 1)],
                                 0);}}
      if (emit_transformed_parameters__) {
        for (int sym1__ = 1; sym1__ <= nParams; ++sym1__) {
          vars__.emplace_back(params[(sym1__ - 1)]);}
        for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= nComps; ++sym3__) {
              vars__.emplace_back(
                initRefr[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);}}}
        for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= n_quantity_records; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= nGroups; ++sym3__) {
              vars__.emplace_back(
                unmarked[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);}}}
        for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= n_quantity_records; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= nGroups; ++sym3__) {
              vars__.emplace_back(
                marked[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);}}}
        for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= maxNsizesObs; ++sym2__) {
            vars__.emplace_back(sizesPred[(sym2__ - 1)][(sym1__ - 1)]);}}
        for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= maxNpropsObs; ++sym2__) {
            vars__.emplace_back(propsPred[(sym2__ - 1)][(sym1__ - 1)]);}}
        for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= maxNsizesObs; ++sym2__) {
            vars__.emplace_back(sizesPred_zeta[(sym2__ - 1)][(sym1__ - 1)]);}
        }
        for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= maxNsizesObs; ++sym2__) {
            vars__.emplace_back(sizesPred_alpha[(sym2__ - 1)][(sym1__ - 1)]);
          }}
        for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= maxNsizesObs; ++sym2__) {
            vars__.emplace_back(sizesPred_beta[(sym2__ - 1)][(sym1__ - 1)]);}
        }
        for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= maxNpropsObs; ++sym2__) {
            vars__.emplace_back(propsPred_eta[(sym2__ - 1)][(sym1__ - 1)]);}}
        for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= maxNpropsObs; ++sym2__) {
            vars__.emplace_back(propsPred_alpha[(sym2__ - 1)][(sym1__ - 1)]);
          }}
        for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= maxNpropsObs; ++sym2__) {
            vars__.emplace_back(propsPred_beta[(sym2__ - 1)][(sym1__ - 1)]);}
        }
        for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= nComps; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= maxNuniqueDts; ++sym3__) {
              vars__.emplace_back(
                rvalue(transitions,
                  cons_list(index_uni(sym3__),
                    cons_list(index_uni(sym2__),
                      cons_list(index_uni(sym1__), nil_index_list()))),
                  "transitions"));}}}
        for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= nComps; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= maxNuniqueDts; ++sym3__) {
              vars__.emplace_back(
                rvalue(transitionsDecay,
                  cons_list(index_uni(sym3__),
                    cons_list(index_uni(sym2__),
                      cons_list(index_uni(sym1__), nil_index_list()))),
                  "transitionsDecay"));}}}
        for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= nComps; ++sym2__) {
            vars__.emplace_back(
              rvalue(transfer,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())),
                "transfer"));}}
        for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= nComps; ++sym2__) {
            vars__.emplace_back(
              rvalue(transferDecay,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())),
                "transferDecay"));}}
        for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= nComps; ++sym2__) {
            vars__.emplace_back(
              rvalue(transition_tmp,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())),
                "transition_tmp"));}}
        for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= nComps; ++sym2__) {
            vars__.emplace_back(
              rvalue(transitionDecay_tmp,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())),
                "transitionDecay_tmp"));}}
        for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= maxNtimeIntervals; ++sym2__) {
            vars__.emplace_back(
              intervals_init_states_marked[(sym2__ - 1)][(sym1__ - 1)]);}}
        for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= maxNtimeIntervals; ++sym2__) {
            vars__.emplace_back(
              intervals_init_states_unmarked[(sym2__ - 1)][(sym1__ - 1)]);}}
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
      Eigen::Matrix<double, -1, 1> nonConstantParams;
      nonConstantParams = Eigen::Matrix<double, -1, 1>(nNonConstantPriors);
      stan::math::fill(nonConstantParams, std::numeric_limits<double>::quiet_NaN());
      
      int paramIndex;
      paramIndex = std::numeric_limits<int>::min();
      
      Eigen::Matrix<double, -1, 1> log_lik;
      log_lik = Eigen::Matrix<double, -1, 1>(nTotal);
      stan::math::fill(log_lik, std::numeric_limits<double>::quiet_NaN());
      
      int llIndexShift;
      llIndexShift = std::numeric_limits<int>::min();
      
      current_statement__ = 187;
      llIndexShift = 0;
      current_statement__ = 188;
      paramIndex = 1;
      current_statement__ = 194;
      for (int i = 1; i <= nParams; ++i) {
        current_statement__ = 192;
        if (logical_neq(mappingParamPriorType[(i - 1)], 0)) {
          current_statement__ = 189;
          assign(nonConstantParams,
            cons_list(index_uni(paramIndex), nil_index_list()),
            params[(i - 1)], "assigning variable nonConstantParams");
          current_statement__ = 190;
          paramIndex = (paramIndex + 1);
        } }
      current_statement__ = 205;
      for (int g = 1; g <= nGroups; ++g) {
        current_statement__ = 202;
        for (int o = 1; o <= nSizesObs[(g - 1)]; ++o) {
          current_statement__ = 197;
          if (logical_eq(sizeFamily, 1)) {
            current_statement__ = 195;
            assign(log_lik,
              cons_list(index_uni((o + llIndexShift)), nil_index_list()),
              normal_lpdf<false>(sizesObs[(o - 1)][(g - 1)],
                sizesPred_alpha[(o - 1)][(g - 1)],
                sizesPred_beta[(o - 1)][(g - 1)]),
              "assigning variable log_lik");
          } 
          current_statement__ = 200;
          if (logical_eq(sizeFamily, 2)) {
            current_statement__ = 198;
            assign(log_lik,
              cons_list(index_uni((o + llIndexShift)), nil_index_list()),
              normal_lpdf<false>(sizesObs[(o - 1)][(g - 1)],
                sizesPred_alpha[(o - 1)][(g - 1)],
                sizesPred_beta[(o - 1)][(g - 1)]),
              "assigning variable log_lik");
          } }
        current_statement__ = 203;
        llIndexShift = (llIndexShift + nSizesObs[(g - 1)]);}
      current_statement__ = 222;
      for (int g = 1; g <= nGroups; ++g) {
        current_statement__ = 219;
        for (int o = 1; o <= nPropsObs[(g - 1)]; ++o) {
          current_statement__ = 208;
          if (logical_eq(propFamily, 1)) {
            current_statement__ = 206;
            assign(log_lik,
              cons_list(index_uni((o + llIndexShift)), nil_index_list()),
              gamma_lpdf<false>(propsObs[(o - 1)][(g - 1)],
                propsPred_alpha[(o - 1)][(g - 1)],
                propsPred_beta[(o - 1)][(g - 1)]),
              "assigning variable log_lik");
          } 
          current_statement__ = 211;
          if (logical_eq(propFamily, 2)) {
            current_statement__ = 209;
            assign(log_lik,
              cons_list(index_uni((o + llIndexShift)), nil_index_list()),
              normal_lpdf<false>(propsObs[(o - 1)][(g - 1)],
                propsPred_alpha[(o - 1)][(g - 1)],
                propsPred_beta[(o - 1)][(g - 1)]),
              "assigning variable log_lik");
          } 
          current_statement__ = 214;
          if (logical_eq(propFamily, 3)) {
            current_statement__ = 212;
            assign(log_lik,
              cons_list(index_uni((o + llIndexShift)), nil_index_list()),
              normal_lpdf<false>(propsObs[(o - 1)][(g - 1)],
                propsPred_alpha[(o - 1)][(g - 1)],
                propsPred_beta[(o - 1)][(g - 1)]),
              "assigning variable log_lik");
          } 
          current_statement__ = 217;
          if (logical_eq(propFamily, 4)) {
            current_statement__ = 215;
            assign(log_lik,
              cons_list(index_uni((o + llIndexShift)), nil_index_list()),
              beta_lpdf<false>(propsObs[(o - 1)][(g - 1)],
                propsPred_alpha[(o - 1)][(g - 1)],
                propsPred_beta[(o - 1)][(g - 1)]),
              "assigning variable log_lik");
          } }
        current_statement__ = 220;
        llIndexShift = (llIndexShift + nPropsObs[(g - 1)]);}
      for (int sym1__ = 1; sym1__ <= nNonConstantPriors; ++sym1__) {
        vars__.emplace_back(nonConstantParams[(sym1__ - 1)]);}
      vars__.emplace_back(paramIndex);
      for (int sym1__ = 1; sym1__ <= nTotal; ++sym1__) {
        vars__.emplace_back(log_lik[(sym1__ - 1)]);}
      vars__.emplace_back(llIndexShift);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, stan::require_std_vector_t<VecVar>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void transform_inits_impl(const stan::io::var_context& context__,
                                   VecI& params_i__, VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.clear();
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      Eigen::Matrix<double, -1, 1> rawUniformParams;
      rawUniformParams = Eigen::Matrix<double, -1, 1>(nPriorUniform_code1);
      stan::math::fill(rawUniformParams, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> rawUniformParams_flat__;
        current_statement__ = 1;
        assign(rawUniformParams_flat__, nil_index_list(),
          context__.vals_r("rawUniformParams"),
          "assigning variable rawUniformParams_flat__");
        current_statement__ = 1;
        pos__ = 1;
        current_statement__ = 1;
        for (int sym1__ = 1; sym1__ <= nPriorUniform_code1; ++sym1__) {
          current_statement__ = 1;
          assign(rawUniformParams,
            cons_list(index_uni(sym1__), nil_index_list()),
            rawUniformParams_flat__[(pos__ - 1)],
            "assigning variable rawUniformParams");
          current_statement__ = 1;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> rawUniformParams_free__;
      rawUniformParams_free__ = Eigen::Matrix<double, -1, 1>(nPriorUniform_code1);
      stan::math::fill(rawUniformParams_free__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 1;
      for (int sym1__ = 1; sym1__ <= nPriorUniform_code1; ++sym1__) {
        current_statement__ = 1;
        assign(rawUniformParams_free__,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lub_free(rawUniformParams[(sym1__ - 1)], 0, 1),
          "assigning variable rawUniformParams_free__");}
      Eigen::Matrix<double, -1, 1> rawHcauchyParams;
      rawHcauchyParams = Eigen::Matrix<double, -1, 1>(nPriorHcauchy_code2);
      stan::math::fill(rawHcauchyParams, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> rawHcauchyParams_flat__;
        current_statement__ = 2;
        assign(rawHcauchyParams_flat__, nil_index_list(),
          context__.vals_r("rawHcauchyParams"),
          "assigning variable rawHcauchyParams_flat__");
        current_statement__ = 2;
        pos__ = 1;
        current_statement__ = 2;
        for (int sym1__ = 1; sym1__ <= nPriorHcauchy_code2; ++sym1__) {
          current_statement__ = 2;
          assign(rawHcauchyParams,
            cons_list(index_uni(sym1__), nil_index_list()),
            rawHcauchyParams_flat__[(pos__ - 1)],
            "assigning variable rawHcauchyParams");
          current_statement__ = 2;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> rawHcauchyParams_free__;
      rawHcauchyParams_free__ = Eigen::Matrix<double, -1, 1>(nPriorHcauchy_code2);
      stan::math::fill(rawHcauchyParams_free__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 2;
      for (int sym1__ = 1; sym1__ <= nPriorHcauchy_code2; ++sym1__) {
        current_statement__ = 2;
        assign(rawHcauchyParams_free__,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_free(rawHcauchyParams[(sym1__ - 1)], 0),
          "assigning variable rawHcauchyParams_free__");}
      Eigen::Matrix<double, -1, 1> rawBetaParams;
      rawBetaParams = Eigen::Matrix<double, -1, 1>(nPriorBeta_code3);
      stan::math::fill(rawBetaParams, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> rawBetaParams_flat__;
        current_statement__ = 3;
        assign(rawBetaParams_flat__, nil_index_list(),
          context__.vals_r("rawBetaParams"),
          "assigning variable rawBetaParams_flat__");
        current_statement__ = 3;
        pos__ = 1;
        current_statement__ = 3;
        for (int sym1__ = 1; sym1__ <= nPriorBeta_code3; ++sym1__) {
          current_statement__ = 3;
          assign(rawBetaParams,
            cons_list(index_uni(sym1__), nil_index_list()),
            rawBetaParams_flat__[(pos__ - 1)],
            "assigning variable rawBetaParams");
          current_statement__ = 3;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> rawBetaParams_free__;
      rawBetaParams_free__ = Eigen::Matrix<double, -1, 1>(nPriorBeta_code3);
      stan::math::fill(rawBetaParams_free__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= nPriorBeta_code3; ++sym1__) {
        current_statement__ = 3;
        assign(rawBetaParams_free__,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lub_free(rawBetaParams[(sym1__ - 1)], 0, 1),
          "assigning variable rawBetaParams_free__");}
      Eigen::Matrix<double, -1, 1> rawTrNormParams;
      rawTrNormParams = Eigen::Matrix<double, -1, 1>(nPriorTrNormal_code4);
      stan::math::fill(rawTrNormParams, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> rawTrNormParams_flat__;
        current_statement__ = 4;
        assign(rawTrNormParams_flat__, nil_index_list(),
          context__.vals_r("rawTrNormParams"),
          "assigning variable rawTrNormParams_flat__");
        current_statement__ = 4;
        pos__ = 1;
        current_statement__ = 4;
        for (int sym1__ = 1; sym1__ <= nPriorTrNormal_code4; ++sym1__) {
          current_statement__ = 4;
          assign(rawTrNormParams,
            cons_list(index_uni(sym1__), nil_index_list()),
            rawTrNormParams_flat__[(pos__ - 1)],
            "assigning variable rawTrNormParams");
          current_statement__ = 4;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> rawTrNormParams_free__;
      rawTrNormParams_free__ = Eigen::Matrix<double, -1, 1>(nPriorTrNormal_code4);
      stan::math::fill(rawTrNormParams_free__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 4;
      for (int sym1__ = 1; sym1__ <= nPriorTrNormal_code4; ++sym1__) {
        current_statement__ = 4;
        assign(rawTrNormParams_free__,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_free(rawTrNormParams[(sym1__ - 1)], 0),
          "assigning variable rawTrNormParams_free__");}
      Eigen::Matrix<double, -1, 1> rawExponentialParams;
      rawExponentialParams = Eigen::Matrix<double, -1, 1>(nPriorExponential_code5);
      stan::math::fill(rawExponentialParams, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> rawExponentialParams_flat__;
        current_statement__ = 5;
        assign(rawExponentialParams_flat__, nil_index_list(),
          context__.vals_r("rawExponentialParams"),
          "assigning variable rawExponentialParams_flat__");
        current_statement__ = 5;
        pos__ = 1;
        current_statement__ = 5;
        for (int sym1__ = 1; sym1__ <= nPriorExponential_code5; ++sym1__) {
          current_statement__ = 5;
          assign(rawExponentialParams,
            cons_list(index_uni(sym1__), nil_index_list()),
            rawExponentialParams_flat__[(pos__ - 1)],
            "assigning variable rawExponentialParams");
          current_statement__ = 5;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> rawExponentialParams_free__;
      rawExponentialParams_free__ = Eigen::Matrix<double, -1, 1>(nPriorExponential_code5);
      stan::math::fill(rawExponentialParams_free__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= nPriorExponential_code5; ++sym1__) {
        current_statement__ = 5;
        assign(rawExponentialParams_free__,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_free(rawExponentialParams[(sym1__ - 1)], 0),
          "assigning variable rawExponentialParams_free__");}
      Eigen::Matrix<double, -1, 1> rawGammaParams;
      rawGammaParams = Eigen::Matrix<double, -1, 1>(nPriorGamma_code6);
      stan::math::fill(rawGammaParams, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> rawGammaParams_flat__;
        current_statement__ = 6;
        assign(rawGammaParams_flat__, nil_index_list(),
          context__.vals_r("rawGammaParams"),
          "assigning variable rawGammaParams_flat__");
        current_statement__ = 6;
        pos__ = 1;
        current_statement__ = 6;
        for (int sym1__ = 1; sym1__ <= nPriorGamma_code6; ++sym1__) {
          current_statement__ = 6;
          assign(rawGammaParams,
            cons_list(index_uni(sym1__), nil_index_list()),
            rawGammaParams_flat__[(pos__ - 1)],
            "assigning variable rawGammaParams");
          current_statement__ = 6;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> rawGammaParams_free__;
      rawGammaParams_free__ = Eigen::Matrix<double, -1, 1>(nPriorGamma_code6);
      stan::math::fill(rawGammaParams_free__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 6;
      for (int sym1__ = 1; sym1__ <= nPriorGamma_code6; ++sym1__) {
        current_statement__ = 6;
        assign(rawGammaParams_free__,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_free(rawGammaParams[(sym1__ - 1)], 0),
          "assigning variable rawGammaParams_free__");}
      for (int sym1__ = 1; sym1__ <= nPriorUniform_code1; ++sym1__) {
        vars__.emplace_back(rawUniformParams_free__[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= nPriorHcauchy_code2; ++sym1__) {
        vars__.emplace_back(rawHcauchyParams_free__[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= nPriorBeta_code3; ++sym1__) {
        vars__.emplace_back(rawBetaParams_free__[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= nPriorTrNormal_code4; ++sym1__) {
        vars__.emplace_back(rawTrNormParams_free__[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= nPriorExponential_code5; ++sym1__) {
        vars__.emplace_back(rawExponentialParams_free__[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= nPriorGamma_code6; ++sym1__) {
        vars__.emplace_back(rawGammaParams_free__[(sym1__ - 1)]);}
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__.clear();
    names__.emplace_back("rawUniformParams");
    names__.emplace_back("rawHcauchyParams");
    names__.emplace_back("rawBetaParams");
    names__.emplace_back("rawTrNormParams");
    names__.emplace_back("rawExponentialParams");
    names__.emplace_back("rawGammaParams");
    names__.emplace_back("params");
    names__.emplace_back("initRefr");
    names__.emplace_back("unmarked");
    names__.emplace_back("marked");
    names__.emplace_back("sizesPred");
    names__.emplace_back("propsPred");
    names__.emplace_back("sizesPred_zeta");
    names__.emplace_back("sizesPred_alpha");
    names__.emplace_back("sizesPred_beta");
    names__.emplace_back("propsPred_eta");
    names__.emplace_back("propsPred_alpha");
    names__.emplace_back("propsPred_beta");
    names__.emplace_back("transitions");
    names__.emplace_back("transitionsDecay");
    names__.emplace_back("transfer");
    names__.emplace_back("transferDecay");
    names__.emplace_back("transition_tmp");
    names__.emplace_back("transitionDecay_tmp");
    names__.emplace_back("intervals_init_states_marked");
    names__.emplace_back("intervals_init_states_unmarked");
    names__.emplace_back("nonConstantParams");
    names__.emplace_back("paramIndex");
    names__.emplace_back("log_lik");
    names__.emplace_back("llIndexShift");
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.clear();
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(nPriorUniform_code1)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(nPriorHcauchy_code2)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(nPriorBeta_code3)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(nPriorTrNormal_code4)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(nPriorExponential_code5)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(nPriorGamma_code6)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nParams)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nComps),
                                             static_cast<size_t>(2),
                                             static_cast<size_t>(nGroups)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nGroups),
                                             static_cast<size_t>(n_quantity_records)
                                             , static_cast<size_t>(nComps)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nGroups),
                                             static_cast<size_t>(n_quantity_records)
                                             , static_cast<size_t>(nComps)});
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(maxNsizesObs)
                                             , static_cast<size_t>(nGroups)});
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(maxNpropsObs)
                                             , static_cast<size_t>(nGroups)});
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(maxNsizesObs)
                                             , static_cast<size_t>(nGroups)});
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(maxNsizesObs)
                                             , static_cast<size_t>(nGroups)});
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(maxNsizesObs)
                                             , static_cast<size_t>(nGroups)});
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(maxNpropsObs)
                                             , static_cast<size_t>(nGroups)});
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(maxNpropsObs)
                                             , static_cast<size_t>(nGroups)});
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(maxNpropsObs)
                                             , static_cast<size_t>(nGroups)});
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(maxNuniqueDts)
                                             , static_cast<size_t>(nComps),
                                             static_cast<size_t>(nComps)});
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(maxNuniqueDts)
                                             , static_cast<size_t>(nComps),
                                             static_cast<size_t>(nComps)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nComps),
                                             static_cast<size_t>(nComps)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nComps),
                                             static_cast<size_t>(nComps)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nComps),
                                             static_cast<size_t>(nComps)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nComps),
                                             static_cast<size_t>(nComps)});
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(maxNtimeIntervals)
                                             , static_cast<size_t>(nComps)});
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(maxNtimeIntervals)
                                             , static_cast<size_t>(nComps)});
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(nNonConstantPriors)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nTotal)});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= nPriorUniform_code1; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "rawUniformParams" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= nPriorHcauchy_code2; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "rawHcauchyParams" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= nPriorBeta_code3; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "rawBetaParams" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= nPriorTrNormal_code4; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "rawTrNormParams" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= nPriorExponential_code5; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "rawExponentialParams" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= nPriorGamma_code6; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "rawGammaParams" + '.' + std::to_string(sym1__));
      }}
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= nParams; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "params" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= nComps; ++sym3__) {
                {
                  param_names__.emplace_back(std::string() + "initRefr" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= n_quantity_records; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= nGroups; ++sym3__) {
                {
                  param_names__.emplace_back(std::string() + "unmarked" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= n_quantity_records; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= nGroups; ++sym3__) {
                {
                  param_names__.emplace_back(std::string() + "marked" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= maxNsizesObs; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "sizesPred" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= maxNpropsObs; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "propsPred" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= maxNsizesObs; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "sizesPred_zeta" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= maxNsizesObs; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "sizesPred_alpha" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= maxNsizesObs; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "sizesPred_beta" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= maxNpropsObs; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "propsPred_eta" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= maxNpropsObs; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "propsPred_alpha" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= maxNpropsObs; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "propsPred_beta" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nComps; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= maxNuniqueDts; ++sym3__) {
                {
                  param_names__.emplace_back(std::string() + "transitions" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nComps; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= maxNuniqueDts; ++sym3__) {
                {
                  param_names__.emplace_back(std::string() + "transitionsDecay" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nComps; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "transfer" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nComps; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "transferDecay" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nComps; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "transition_tmp" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nComps; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "transitionDecay_tmp" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= maxNtimeIntervals; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "intervals_init_states_marked" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= maxNtimeIntervals; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "intervals_init_states_unmarked" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
    }
    
    if (emit_generated_quantities__) {
      for (int sym1__ = 1; sym1__ <= nNonConstantPriors; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "nonConstantParams" + '.' + std::to_string(sym1__));
        }}
      param_names__.emplace_back(std::string() + "paramIndex");
      for (int sym1__ = 1; sym1__ <= nTotal; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "log_lik" + '.' + std::to_string(sym1__));
        }}
      param_names__.emplace_back(std::string() + "llIndexShift");
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= nPriorUniform_code1; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "rawUniformParams" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= nPriorHcauchy_code2; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "rawHcauchyParams" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= nPriorBeta_code3; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "rawBetaParams" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= nPriorTrNormal_code4; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "rawTrNormParams" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= nPriorExponential_code5; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "rawExponentialParams" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= nPriorGamma_code6; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "rawGammaParams" + '.' + std::to_string(sym1__));
      }}
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= nParams; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "params" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= nComps; ++sym3__) {
                {
                  param_names__.emplace_back(std::string() + "initRefr" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= n_quantity_records; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= nGroups; ++sym3__) {
                {
                  param_names__.emplace_back(std::string() + "unmarked" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= n_quantity_records; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= nGroups; ++sym3__) {
                {
                  param_names__.emplace_back(std::string() + "marked" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= maxNsizesObs; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "sizesPred" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= maxNpropsObs; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "propsPred" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= maxNsizesObs; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "sizesPred_zeta" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= maxNsizesObs; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "sizesPred_alpha" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= maxNsizesObs; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "sizesPred_beta" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= maxNpropsObs; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "propsPred_eta" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= maxNpropsObs; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "propsPred_alpha" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nGroups; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= maxNpropsObs; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "propsPred_beta" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nComps; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= maxNuniqueDts; ++sym3__) {
                {
                  param_names__.emplace_back(std::string() + "transitions" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nComps; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= maxNuniqueDts; ++sym3__) {
                {
                  param_names__.emplace_back(std::string() + "transitionsDecay" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nComps; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "transfer" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nComps; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "transferDecay" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nComps; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "transition_tmp" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nComps; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "transitionDecay_tmp" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= maxNtimeIntervals; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "intervals_init_states_marked" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nComps; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= maxNtimeIntervals; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "intervals_init_states_unmarked" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
    }
    
    if (emit_generated_quantities__) {
      for (int sym1__ = 1; sym1__ <= nNonConstantPriors; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "nonConstantParams" + '.' + std::to_string(sym1__));
        }}
      param_names__.emplace_back(std::string() + "paramIndex");
      for (int sym1__ = 1; sym1__ <= nTotal; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "log_lik" + '.' + std::to_string(sym1__));
        }}
      param_names__.emplace_back(std::string() + "llIndexShift");
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"rawUniformParams\",\"type\":{\"name\":\"vector\",\"length\":" << nPriorUniform_code1 << "},\"block\":\"parameters\"},{\"name\":\"rawHcauchyParams\",\"type\":{\"name\":\"vector\",\"length\":" << nPriorHcauchy_code2 << "},\"block\":\"parameters\"},{\"name\":\"rawBetaParams\",\"type\":{\"name\":\"vector\",\"length\":" << nPriorBeta_code3 << "},\"block\":\"parameters\"},{\"name\":\"rawTrNormParams\",\"type\":{\"name\":\"vector\",\"length\":" << nPriorTrNormal_code4 << "},\"block\":\"parameters\"},{\"name\":\"rawExponentialParams\",\"type\":{\"name\":\"vector\",\"length\":" << nPriorExponential_code5 << "},\"block\":\"parameters\"},{\"name\":\"rawGammaParams\",\"type\":{\"name\":\"vector\",\"length\":" << nPriorGamma_code6 << "},\"block\":\"parameters\"},{\"name\":\"params\",\"type\":{\"name\":\"array\",\"length\":" << nParams << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"initRefr\",\"type\":{\"name\":\"array\",\"length\":" << nComps << ",\"element_type\":{\"name\":\"array\",\"length\":" << 2 << ",\"element_type\":{\"name\":\"array\",\"length\":" << nGroups << ",\"element_type\":{\"name\":\"real\"}}}},\"block\":\"transformed_parameters\"},{\"name\":\"unmarked\",\"type\":{\"name\":\"array\",\"length\":" << nGroups << ",\"element_type\":{\"name\":\"array\",\"length\":" << n_quantity_records << ",\"element_type\":{\"name\":\"vector\",\"length\":" << nComps << "}}},\"block\":\"transformed_parameters\"},{\"name\":\"marked\",\"type\":{\"name\":\"array\",\"length\":" << nGroups << ",\"element_type\":{\"name\":\"array\",\"length\":" << n_quantity_records << ",\"element_type\":{\"name\":\"vector\",\"length\":" << nComps << "}}},\"block\":\"transformed_parameters\"},{\"name\":\"sizesPred\",\"type\":{\"name\":\"array\",\"length\":" << maxNsizesObs << ",\"element_type\":{\"name\":\"array\",\"length\":" << nGroups << ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"},{\"name\":\"propsPred\",\"type\":{\"name\":\"array\",\"length\":" << maxNpropsObs << ",\"element_type\":{\"name\":\"array\",\"length\":" << nGroups << ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"},{\"name\":\"sizesPred_zeta\",\"type\":{\"name\":\"array\",\"length\":" << maxNsizesObs << ",\"element_type\":{\"name\":\"array\",\"length\":" << nGroups << ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"},{\"name\":\"sizesPred_alpha\",\"type\":{\"name\":\"array\",\"length\":" << maxNsizesObs << ",\"element_type\":{\"name\":\"array\",\"length\":" << nGroups << ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"},{\"name\":\"sizesPred_beta\",\"type\":{\"name\":\"array\",\"length\":" << maxNsizesObs << ",\"element_type\":{\"name\":\"array\",\"length\":" << nGroups << ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"},{\"name\":\"propsPred_eta\",\"type\":{\"name\":\"array\",\"length\":" << maxNpropsObs << ",\"element_type\":{\"name\":\"array\",\"length\":" << nGroups << ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"},{\"name\":\"propsPred_alpha\",\"type\":{\"name\":\"array\",\"length\":" << maxNpropsObs << ",\"element_type\":{\"name\":\"array\",\"length\":" << nGroups << ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"},{\"name\":\"propsPred_beta\",\"type\":{\"name\":\"array\",\"length\":" << maxNpropsObs << ",\"element_type\":{\"name\":\"array\",\"length\":" << nGroups << ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"},{\"name\":\"transitions\",\"type\":{\"name\":\"array\",\"length\":" << maxNuniqueDts << ",\"element_type\":{\"name\":\"matrix\",\"rows\":" << nComps << ",\"cols\":" << nComps << "}},\"block\":\"transformed_parameters\"},{\"name\":\"transitionsDecay\",\"type\":{\"name\":\"array\",\"length\":" << maxNuniqueDts << ",\"element_type\":{\"name\":\"matrix\",\"rows\":" << nComps << ",\"cols\":" << nComps << "}},\"block\":\"transformed_parameters\"},{\"name\":\"transfer\",\"type\":{\"name\":\"matrix\",\"rows\":" << nComps << ",\"cols\":" << nComps << "},\"block\":\"transformed_parameters\"},{\"name\":\"transferDecay\",\"type\":{\"name\":\"matrix\",\"rows\":" << nComps << ",\"cols\":" << nComps << "},\"block\":\"transformed_parameters\"},{\"name\":\"transition_tmp\",\"type\":{\"name\":\"matrix\",\"rows\":" << nComps << ",\"cols\":" << nComps << "},\"block\":\"transformed_parameters\"},{\"name\":\"transitionDecay_tmp\",\"type\":{\"name\":\"matrix\",\"rows\":" << nComps << ",\"cols\":" << nComps << "},\"block\":\"transformed_parameters\"},{\"name\":\"intervals_init_states_marked\",\"type\":{\"name\":\"array\",\"length\":" << maxNtimeIntervals << ",\"element_type\":{\"name\":\"vector\",\"length\":" << nComps << "}},\"block\":\"transformed_parameters\"},{\"name\":\"intervals_init_states_unmarked\",\"type\":{\"name\":\"array\",\"length\":" << maxNtimeIntervals << ",\"element_type\":{\"name\":\"vector\",\"length\":" << nComps << "}},\"block\":\"transformed_parameters\"},{\"name\":\"nonConstantParams\",\"type\":{\"name\":\"vector\",\"length\":" << nNonConstantPriors << "},\"block\":\"generated_quantities\"},{\"name\":\"paramIndex\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"},{\"name\":\"log_lik\",\"type\":{\"name\":\"vector\",\"length\":" << nTotal << "},\"block\":\"generated_quantities\"},{\"name\":\"llIndexShift\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"rawUniformParams\",\"type\":{\"name\":\"vector\",\"length\":" << nPriorUniform_code1 << "},\"block\":\"parameters\"},{\"name\":\"rawHcauchyParams\",\"type\":{\"name\":\"vector\",\"length\":" << nPriorHcauchy_code2 << "},\"block\":\"parameters\"},{\"name\":\"rawBetaParams\",\"type\":{\"name\":\"vector\",\"length\":" << nPriorBeta_code3 << "},\"block\":\"parameters\"},{\"name\":\"rawTrNormParams\",\"type\":{\"name\":\"vector\",\"length\":" << nPriorTrNormal_code4 << "},\"block\":\"parameters\"},{\"name\":\"rawExponentialParams\",\"type\":{\"name\":\"vector\",\"length\":" << nPriorExponential_code5 << "},\"block\":\"parameters\"},{\"name\":\"rawGammaParams\",\"type\":{\"name\":\"vector\",\"length\":" << nPriorGamma_code6 << "},\"block\":\"parameters\"},{\"name\":\"params\",\"type\":{\"name\":\"array\",\"length\":" << nParams << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"initRefr\",\"type\":{\"name\":\"array\",\"length\":" << nComps << ",\"element_type\":{\"name\":\"array\",\"length\":" << 2 << ",\"element_type\":{\"name\":\"array\",\"length\":" << nGroups << ",\"element_type\":{\"name\":\"real\"}}}},\"block\":\"transformed_parameters\"},{\"name\":\"unmarked\",\"type\":{\"name\":\"array\",\"length\":" << nGroups << ",\"element_type\":{\"name\":\"array\",\"length\":" << n_quantity_records << ",\"element_type\":{\"name\":\"vector\",\"length\":" << nComps << "}}},\"block\":\"transformed_parameters\"},{\"name\":\"marked\",\"type\":{\"name\":\"array\",\"length\":" << nGroups << ",\"element_type\":{\"name\":\"array\",\"length\":" << n_quantity_records << ",\"element_type\":{\"name\":\"vector\",\"length\":" << nComps << "}}},\"block\":\"transformed_parameters\"},{\"name\":\"sizesPred\",\"type\":{\"name\":\"array\",\"length\":" << maxNsizesObs << ",\"element_type\":{\"name\":\"array\",\"length\":" << nGroups << ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"},{\"name\":\"propsPred\",\"type\":{\"name\":\"array\",\"length\":" << maxNpropsObs << ",\"element_type\":{\"name\":\"array\",\"length\":" << nGroups << ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"},{\"name\":\"sizesPred_zeta\",\"type\":{\"name\":\"array\",\"length\":" << maxNsizesObs << ",\"element_type\":{\"name\":\"array\",\"length\":" << nGroups << ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"},{\"name\":\"sizesPred_alpha\",\"type\":{\"name\":\"array\",\"length\":" << maxNsizesObs << ",\"element_type\":{\"name\":\"array\",\"length\":" << nGroups << ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"},{\"name\":\"sizesPred_beta\",\"type\":{\"name\":\"array\",\"length\":" << maxNsizesObs << ",\"element_type\":{\"name\":\"array\",\"length\":" << nGroups << ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"},{\"name\":\"propsPred_eta\",\"type\":{\"name\":\"array\",\"length\":" << maxNpropsObs << ",\"element_type\":{\"name\":\"array\",\"length\":" << nGroups << ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"},{\"name\":\"propsPred_alpha\",\"type\":{\"name\":\"array\",\"length\":" << maxNpropsObs << ",\"element_type\":{\"name\":\"array\",\"length\":" << nGroups << ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"},{\"name\":\"propsPred_beta\",\"type\":{\"name\":\"array\",\"length\":" << maxNpropsObs << ",\"element_type\":{\"name\":\"array\",\"length\":" << nGroups << ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"},{\"name\":\"transitions\",\"type\":{\"name\":\"array\",\"length\":" << maxNuniqueDts << ",\"element_type\":{\"name\":\"matrix\",\"rows\":" << nComps << ",\"cols\":" << nComps << "}},\"block\":\"transformed_parameters\"},{\"name\":\"transitionsDecay\",\"type\":{\"name\":\"array\",\"length\":" << maxNuniqueDts << ",\"element_type\":{\"name\":\"matrix\",\"rows\":" << nComps << ",\"cols\":" << nComps << "}},\"block\":\"transformed_parameters\"},{\"name\":\"transfer\",\"type\":{\"name\":\"matrix\",\"rows\":" << nComps << ",\"cols\":" << nComps << "},\"block\":\"transformed_parameters\"},{\"name\":\"transferDecay\",\"type\":{\"name\":\"matrix\",\"rows\":" << nComps << ",\"cols\":" << nComps << "},\"block\":\"transformed_parameters\"},{\"name\":\"transition_tmp\",\"type\":{\"name\":\"matrix\",\"rows\":" << nComps << ",\"cols\":" << nComps << "},\"block\":\"transformed_parameters\"},{\"name\":\"transitionDecay_tmp\",\"type\":{\"name\":\"matrix\",\"rows\":" << nComps << ",\"cols\":" << nComps << "},\"block\":\"transformed_parameters\"},{\"name\":\"intervals_init_states_marked\",\"type\":{\"name\":\"array\",\"length\":" << maxNtimeIntervals << ",\"element_type\":{\"name\":\"vector\",\"length\":" << nComps << "}},\"block\":\"transformed_parameters\"},{\"name\":\"intervals_init_states_unmarked\",\"type\":{\"name\":\"array\",\"length\":" << maxNtimeIntervals << ",\"element_type\":{\"name\":\"vector\",\"length\":" << nComps << "}},\"block\":\"transformed_parameters\"},{\"name\":\"nonConstantParams\",\"type\":{\"name\":\"vector\",\"length\":" << nNonConstantPriors << "},\"block\":\"generated_quantities\"},{\"name\":\"paramIndex\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"},{\"name\":\"log_lik\",\"type\":{\"name\":\"vector\",\"length\":" << nTotal << "},\"block\":\"generated_quantities\"},{\"name\":\"llIndexShift\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      std::vector<double> vars_vec(vars.size());
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i) {
        vars.coeffRef(i) = vars_vec[i];
      }
    }
    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }
    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }
    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }
  
    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits_impl(context, params_i, params_r_vec, pstream);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i) {
        params_r.coeffRef(i) = params_r_vec[i];
      }
    }
    inline void transform_inits(const stan::io::var_context& context,
                                std::vector<int>& params_i,
                                std::vector<double>& vars,
                                std::ostream* pstream = nullptr) const final {
      transform_inits_impl(context, params_i, vars, pstream);
    }        
};
}
using stan_model = model_networkModel_namespace::model_networkModel;
#ifndef USING_R
// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return model_networkModel_namespace::profiles__;
}
#endif
#endif
